import { useState, useEffect, useRef, useCallback } from 'react'
import { createChart } from 'lightweight-charts'
import BentoGrid, { BentoItem } from '../ui/BentoGrid'
import { useWalletState } from '../../context/WalletContext'
import { useBuiltInWallet } from '../../context/BuiltInWalletContext'
import ManualWatchlist from '../trading/ManualWatchlist'
import SafetyReport from '../trading/SafetyReport'
import PresetSelector from '../trading/PresetSelector'
import { TRADING_PRESETS, getPresetConfig } from '../../config/tradingPresets'
import DemoTradeHistory from './DemoTradeHistory'
import DemoLeadCapture from './DemoLeadCapture'
import DemoUpgradeCTA from './DemoUpgradeCTA'
import StrikeAgentPricing from './StrikeAgentPricing'
import TopSignalsWidget from '../sniper/TopSignalsWidget'
import './SniperBotTab.css'

const API_BASE = ''

const GLOSSARY_DATA = {
  'ema': {
    term: 'EMA (Exponential Moving Average)',
    definition: 'A type of moving average that gives more weight to recent prices, making it more responsive to new information than a simple moving average.'
  },
  'sma': {
    term: 'SMA (Simple Moving Average)',
    definition: 'The average price of an asset over a specific period, calculated by adding prices and dividing by the number of periods.'
  },
  'rsi': {
    term: 'RSI (Relative Strength Index)',
    definition: 'A momentum indicator measuring the speed and magnitude of price changes. Values above 70 suggest overbought conditions, below 30 suggest oversold.'
  },
  'macd': {
    term: 'MACD (Moving Average Convergence Divergence)',
    definition: 'A trend-following momentum indicator showing the relationship between two moving averages, used to identify potential buy/sell signals.'
  },
  'volume': {
    term: 'Volume',
    definition: 'The total number of tokens traded during a specific time period. High volume often indicates strong interest and liquidity.'
  },
  'liquidity': {
    term: 'Liquidity',
    definition: 'The ease with which a token can be bought or sold without significantly affecting its price. Higher liquidity means better trading conditions.'
  },
  'market_cap': {
    term: 'Market Cap',
    definition: 'The total market value of a token, calculated by multiplying the current price by the total supply in circulation.'
  },
  'safety_score': {
    term: 'Safety Score',
    definition: 'An AI-calculated score assessing the risk level of a token based on contract analysis, holder distribution, liquidity, and trading patterns.'
  },
  'composite_score': {
    term: 'Composite Score',
    definition: 'A combined metric that weighs multiple factors including safety, momentum, volume, and holder growth to rate trading opportunities.'
  },
  'win_rate': {
    term: 'Win Rate',
    definition: 'The percentage of trades that resulted in profit. A win rate above 50% combined with good risk management indicates a profitable strategy.'
  },
  'pnl': {
    term: 'P&L (Profit & Loss)',
    definition: 'The net financial result of your trading activity, calculated as the difference between gains and losses.'
  },
  'honeypot': {
    term: 'Honeypot',
    definition: 'A malicious token contract designed to prevent selling after purchase, trapping buyers\' funds. Always check for honeypot risks before trading.'
  },
  'rug_pull': {
    term: 'Rug Pull',
    definition: 'A scam where developers abandon a project and run away with investor funds, often by draining liquidity pools or selling their holdings.'
  },
  'total_predictions': {
    term: 'Total Predictions',
    definition: 'The cumulative number of trading signals or recommendations generated by the AI system over time.'
  },
  'model_accuracy': {
    term: 'Model Accuracy',
    definition: 'The percentage of correct predictions made by the AI trading model, measuring how well the system learns from historical data.'
  },
  'system_learning_progress': {
    term: 'System Learning Progress',
    definition: 'A visual indicator showing how much the AI has learned and improved from analyzing market patterns and trade outcomes.'
  },
  'best_trade': {
    term: 'Best Trade',
    definition: 'The single most profitable trade recorded by the system, showing the highest percentage gain achieved.'
  },
  'worst_trade': {
    term: 'Worst Trade',
    definition: 'The single most unprofitable trade recorded by the system, showing the largest percentage loss incurred.'
  },
  'fdv': {
    term: 'FDV (Fully Diluted Valuation)',
    definition: 'The theoretical market cap if all tokens (including locked, vested, or unreleased) were in circulation at the current price.'
  }
}

const DEFAULT_CONFIG = {
  mode: 'simple',
  safetyFilters: {
    maxBotPercent: 80,
    maxBundlePercent: 50,
    maxTop10HoldersPercent: 80,
    minLiquidityUsd: 5000,
    checkCreatorWallet: true,
  },
  discoveryFilters: {
    minTokenAgeMinutes: 5,
    maxTokenAgeMinutes: 1440,
    minHolders: 50,
    minWatchers: 10,
  },
  movementFilters: {
    minPriceChangePercent: 1.5,
    movementTimeframeMinutes: 5,
    minVolumeMultiplier: 2,
    minTradesPerMinute: 5,
    minBuySellRatio: 1.2,
    minHolderGrowthPercent: 5,
  },
  dexPreferences: {
    enabledDexes: ['raydium', 'pumpfun', 'jupiter', 'orca', 'meteora'],
    preferredDex: 'jupiter',
  },
  tradeControls: {
    buyAmountSol: 0.5,
    slippagePercent: 5,
    priorityFee: 'auto',
    takeProfitPercent: 50,
    stopLossPercent: 20,
  },
  autoModeSettings: {
    maxTradesPerSession: 10,
    maxSolPerSession: 5,
    cooldownSeconds: 60,
    maxConsecutiveLosses: 3,
  },
}

function LiveCandleChart({ tokenSymbol, priceData, entryPrice, takeProfitPrice, stopLossPrice }) {
  const chartContainerRef = useRef(null)
  const chartRef = useRef(null)
  const candleSeriesRef = useRef(null)

  useEffect(() => {
    if (!chartContainerRef.current) return

    const chart = createChart(chartContainerRef.current, {
      layout: {
        background: { type: 'solid', color: '#0a0a0a' },
        textColor: '#888',
      },
      grid: {
        vertLines: { color: 'rgba(255,255,255,0.03)' },
        horzLines: { color: 'rgba(255,255,255,0.03)' },
      },
      width: chartContainerRef.current.clientWidth,
      height: 180,
      timeScale: {
        timeVisible: true,
        secondsVisible: true,
        borderColor: '#222',
      },
      rightPriceScale: {
        borderColor: '#222',
      },
      crosshair: {
        mode: 1,
        vertLine: { color: 'rgba(0, 212, 255, 0.3)', width: 1, style: 2 },
        horzLine: { color: 'rgba(0, 212, 255, 0.3)', width: 1, style: 2 },
      },
    })

    const candleSeries = chart.addCandlestickSeries({
      upColor: '#39FF14',
      downColor: '#FF4444',
      borderUpColor: '#39FF14',
      borderDownColor: '#FF4444',
      wickUpColor: '#39FF14',
      wickDownColor: '#FF4444',
    })

    if (entryPrice) {
      candleSeries.createPriceLine({
        price: entryPrice,
        color: '#00D4FF',
        lineWidth: 2,
        lineStyle: 2,
        axisLabelVisible: true,
        title: 'ENTRY',
      })
    }

    if (takeProfitPrice) {
      candleSeries.createPriceLine({
        price: takeProfitPrice,
        color: '#39FF14',
        lineWidth: 1,
        lineStyle: 2,
        axisLabelVisible: true,
        title: 'TP',
      })
    }

    if (stopLossPrice) {
      candleSeries.createPriceLine({
        price: stopLossPrice,
        color: '#FF4444',
        lineWidth: 1,
        lineStyle: 2,
        axisLabelVisible: true,
        title: 'SL',
      })
    }

    chartRef.current = chart
    candleSeriesRef.current = candleSeries

    const handleResize = () => {
      if (chartContainerRef.current) {
        chart.applyOptions({ width: chartContainerRef.current.clientWidth })
      }
    }
    window.addEventListener('resize', handleResize)

    return () => {
      window.removeEventListener('resize', handleResize)
      chart.remove()
    }
  }, [entryPrice, takeProfitPrice, stopLossPrice])

  useEffect(() => {
    if (candleSeriesRef.current && priceData?.length > 0) {
      candleSeriesRef.current.setData(priceData)
    }
  }, [priceData])

  return (
    <div className="sniper-chart-container">
      <div className="sniper-chart-header">
        <span className="sniper-chart-symbol">{tokenSymbol || 'SELECT TOKEN'}</span>
        <span className="sniper-chart-timeframe">1s</span>
      </div>
      <div ref={chartContainerRef} className="sniper-chart-canvas" />
    </div>
  )
}

function SessionStatsCard({ stats, isActive }) {
  return (
    <div className="section-box sniper-stats-card">
      <div className="sniper-stats-header">
        <div className="sniper-status-indicator">
          <span className={`sniper-status-dot ${isActive ? 'active' : ''}`} />
          <span className="sniper-status-text">
            {isActive ? 'SESSION ACTIVE' : 'SESSION IDLE'}
          </span>
        </div>
      </div>
      <div className="sniper-stats-grid">
        <div className="sniper-stat-item">
          <div className="sniper-stat-label">TRADES</div>
          <div className="sniper-stat-value cyan">
            {stats?.tradesExecuted || 0}
            <span className="sniper-stat-max">/{stats?.maxTrades || 10}</span>
          </div>
        </div>
        <div className="sniper-stat-item">
          <div className="sniper-stat-label">WIN RATE</div>
          <div className={`sniper-stat-value ${(stats?.winRate || 0) >= 50 ? 'green' : 'red'}`}>
            {(stats?.winRate || 0).toFixed(0)}%
          </div>
        </div>
        <div className="sniper-stat-item">
          <div className="sniper-stat-label">SOL USED</div>
          <div className="sniper-stat-value cyan">
            {(stats?.solUsed || 0).toFixed(2)}
            <span className="sniper-stat-max">/{stats?.maxSol || 5}</span>
          </div>
        </div>
        <div className="sniper-stat-item">
          <div className="sniper-stat-label">P&L</div>
          <div className={`sniper-stat-value ${(stats?.totalPnl || 0) >= 0 ? 'green' : 'red'}`}>
            {(stats?.totalPnl || 0) >= 0 ? '+' : ''}{(stats?.totalPnl || 0).toFixed(3)}
          </div>
        </div>
      </div>
    </div>
  )
}

function ActivePositionCard({ position, onClose }) {
  const pnlPercent = ((position.currentPrice - position.entryPrice) / position.entryPrice) * 100
  const isProfit = pnlPercent >= 0
  const pnlSol = position.amountSol * (pnlPercent / 100)

  return (
    <div className={`section-box sniper-position-card ${isProfit ? 'profit' : 'loss'}`}>
      <div className="sniper-position-header">
        <div className="sniper-position-token">
          <div className="sniper-token-icon">
            {position.symbol?.slice(0, 2) || '??'}
          </div>
          <div className="sniper-token-info">
            <div className="sniper-token-symbol">{position.symbol}</div>
            <div className="sniper-token-meta">via {position.dex} ‚Ä¢ {position.age}</div>
          </div>
        </div>
        <div className="sniper-position-pnl">
          <div className={`sniper-pnl-percent ${isProfit ? 'green' : 'red'}`}>
            {isProfit ? '+' : ''}{pnlPercent.toFixed(2)}%
          </div>
          <div className={`sniper-pnl-sol ${isProfit ? 'green' : 'red'}`}>
            {isProfit ? '+' : ''}{pnlSol.toFixed(4)} SOL
          </div>
        </div>
      </div>
      <div className="sniper-position-prices">
        <div className="sniper-price-item">
          <span className="sniper-price-label">Entry</span>
          <span className="sniper-price-value">${position.entryPrice?.toFixed(8)}</span>
        </div>
        <div className="sniper-price-item">
          <span className="sniper-price-label">Current</span>
          <span className="sniper-price-value">${position.currentPrice?.toFixed(8)}</span>
        </div>
      </div>
      <div className="sniper-position-actions">
        <button className="sniper-btn-close" onClick={() => onClose(position.id, 'manual')}>
          Close Position
        </button>
        <button className="sniper-btn-adjust">Adjust TP/SL</button>
      </div>
    </div>
  )
}

function getSafetyGradeColor(grade) {
  switch(grade) {
    case 'A': return '#39FF14'
    case 'B': return '#7CFC00'
    case 'C': return '#FFD700'
    case 'D': return '#FF8C00'
    case 'F': return '#FF4444'
    default: return '#888'
  }
}

const CHAIN_CONFIG = {
  solana: { icon: '‚óé', name: 'SOL', color: '#9945FF' },
  ethereum: { icon: '‚¨°', name: 'ETH', color: '#627EEA' },
  base: { icon: '‚¨°', name: 'BASE', color: '#0052FF' },
  polygon: { icon: '‚¨°', name: 'MATIC', color: '#8247E5' },
  arbitrum: { icon: '‚¨°', name: 'ARB', color: '#28A0F0' },
  bsc: { icon: '‚¨°', name: 'BSC', color: '#F3BA2F' },
}

function getChainInfo(chain) {
  const normalizedChain = (chain || 'solana').toLowerCase()
  return CHAIN_CONFIG[normalizedChain] || CHAIN_CONFIG.solana
}

function DiscoveredTokenCard({ token, onSnipe, onWatch, onSafetyCheck, disabled, isDemoMode, onTermClick, isLocked = false }) {
  const gradeColor = getSafetyGradeColor(token.safetyGrade)
  const dexColor = token.dex === 'pumpfun' ? '#FF69B4' : token.dex === 'raydium' ? '#9D4EDD' : '#00D4FF'
  const chainInfo = getChainInfo(token.chain)
  const isDisabled = disabled || isLocked

  return (
    <div className="section-box sniper-token-card" style={{ position: 'relative' }}>
      <div className="sniper-token-row">
        <div className="sniper-token-left">
          <div className="sniper-safety-badge" style={{ '--grade-color': gradeColor }}>
            <span className="sniper-grade-value">{token.safetyGrade || '?'}</span>
            <span className="sniper-grade-score">{token.safetyScore || 0}</span>
          </div>
          <div className="sniper-token-details">
            <div className="sniper-token-name-row">
              <span className="sniper-token-name">{token.symbol}</span>
              <span 
                className="sniper-chain-badge"
                style={{
                  '--chain-color': chainInfo.color
                }}
              >
                <span className="sniper-chain-icon">{chainInfo.icon}</span>
                <span className="sniper-chain-name">{chainInfo.name}</span>
              </span>
            </div>
            <div className="sniper-token-fullname">{token.name?.slice(0, 20)}</div>
            <div className="sniper-token-dex" style={{ color: dexColor }}>{token.dex}</div>
          </div>
        </div>
        <div className="sniper-token-right">
          <div className="sniper-token-price">${token.price < 0.01 ? token.price.toExponential(2) : token.price?.toFixed(4)}</div>
          <div className={`sniper-token-change ${(token.priceChange24h || 0) >= 0 ? 'green' : 'red'}`}>
            {(token.priceChange24h || 0) >= 0 ? '+' : ''}{(token.priceChange24h || 0).toFixed(1)}%
          </div>
        </div>
      </div>
      <div className="sniper-token-metrics">
        <div className="sniper-metric">
          <span className="sniper-metric-label">
            {onTermClick ? <GlossaryTerm term="liquidity" onTermClick={onTermClick}>Liq</GlossaryTerm> : 'Liq'}
          </span>
          <span className="sniper-metric-value">${((token.liquidity || 0) / 1000).toFixed(1)}K</span>
        </div>
        <div className="sniper-metric">
          <span className="sniper-metric-label">
            {onTermClick ? <GlossaryTerm term="volume" onTermClick={onTermClick}>24h Vol</GlossaryTerm> : '24h Vol'}
          </span>
          <span className="sniper-metric-value">${((token.volume || 0) / 1000).toFixed(1)}K</span>
        </div>
        <div className="sniper-metric">
          <span className="sniper-metric-label">
            {onTermClick ? <GlossaryTerm term="fdv" onTermClick={onTermClick}>FDV</GlossaryTerm> : 'FDV'}
          </span>
          <span className="sniper-metric-value">${((token.fdv || 0) / 1000000).toFixed(2)}M</span>
        </div>
      </div>
      {token.risks && token.risks.length > 0 && (
        <div className="sniper-token-risks">
          {token.risks.slice(0, 2).map((risk, i) => (
            <span key={i} className="sniper-risk-tag">‚ö†Ô∏è {risk}</span>
          ))}
        </div>
      )}
      <div className="sniper-token-actions">
        <button 
          className="sniper-btn-snipe" 
          onClick={() => !isDisabled && onSnipe(token)}
          disabled={isDisabled && !isDemoMode}
          style={isLocked ? { opacity: 0.5, cursor: 'not-allowed' } : {}}
        >
          {isLocked ? 'üîí Subscribe' : (disabled && !isDemoMode ? 'Connect Wallet' : 'üéØ BUY')}
        </button>
        <button 
          className="sniper-btn-watch" 
          onClick={() => !isLocked && onWatch(token)}
          disabled={isLocked}
          style={isLocked ? { opacity: 0.5, cursor: 'not-allowed' } : {}}
        >
          {isLocked ? 'üîí' : 'üëÅÔ∏è'}
        </button>
        <button 
          className="sniper-btn-safety" 
          onClick={() => onSafetyCheck && onSafetyCheck(token)}
          title="Run Safety Check"
        >
          üõ°Ô∏è
        </button>
      </div>
    </div>
  )
}

function DemoPositionCard({ position, onSell, currentPrice }) {
  const pnlPercent = position.pnlPercent || ((currentPrice - position.entryPriceUsd) / position.entryPriceUsd) * 100
  const isProfit = pnlPercent >= 0
  const currentValue = position.tokenAmount * (currentPrice || position.currentPriceUsd || position.entryPriceUsd)
  const pnlAmount = currentValue - position.entryPriceSol

  return (
    <div className={`section-box demo-position-card ${isProfit ? 'profit' : 'loss'}`}>
      <div className="demo-position-header">
        <div className="demo-position-token">
          <div className="demo-position-icon">
            {position.tokenSymbol?.slice(0, 2) || '??'}
          </div>
          <div className="demo-position-info">
            <div className="demo-position-symbol">{position.tokenSymbol}</div>
            <div className="demo-position-name">{position.tokenName?.slice(0, 15)}</div>
          </div>
        </div>
        <div className="demo-position-pnl">
          <div className={`demo-pnl-percent ${isProfit ? 'green' : 'red'}`}>
            {isProfit ? '+' : ''}{pnlPercent.toFixed(2)}%
          </div>
          <div className={`demo-pnl-amount ${isProfit ? 'green' : 'red'}`}>
            {isProfit ? '+' : ''}${pnlAmount.toFixed(2)}
          </div>
        </div>
      </div>
      <div className="demo-position-prices">
        <div className="demo-price-item">
          <span className="demo-price-label">Entry</span>
          <span className="demo-price-value">${position.entryPriceUsd < 0.01 ? position.entryPriceUsd.toExponential(2) : position.entryPriceUsd?.toFixed(6)}</span>
        </div>
        <div className="demo-price-item">
          <span className="demo-price-label">Current</span>
          <span className="demo-price-value">${(currentPrice || position.currentPriceUsd || position.entryPriceUsd) < 0.01 ? (currentPrice || position.currentPriceUsd || position.entryPriceUsd).toExponential(2) : (currentPrice || position.currentPriceUsd || position.entryPriceUsd)?.toFixed(6)}</span>
        </div>
        <div className="demo-price-item">
          <span className="demo-price-label">Value</span>
          <span className="demo-price-value">${currentValue.toFixed(2)}</span>
        </div>
      </div>
      <button 
        className="demo-sell-btn"
        onClick={() => onSell(position, currentPrice || position.currentPriceUsd || position.entryPriceUsd)}
      >
        üí∞ SELL
      </button>
    </div>
  )
}

function SmartAutoModePanel({ isActive, onToggle, config, disabled }) {
  return (
    <div className={`section-box sniper-automode-panel ${disabled ? 'disabled' : ''}`}>
      <div className="sniper-automode-header">
        <div>
          <h4 className="sniper-automode-title">Smart Auto Mode</h4>
          <p className="sniper-automode-desc">
            {disabled ? 'Connect wallet to enable' : 'AI-powered autonomous trading'}
          </p>
        </div>
        <button 
          className={`sniper-automode-btn ${isActive ? 'active' : ''}`}
          onClick={onToggle}
          disabled={disabled}
        >
          {isActive ? 'STOP' : 'START'}
        </button>
      </div>
      <div className="sniper-automode-limits">
        <div className="sniper-limit-item">
          <span className="sniper-limit-label">Max Trades</span>
          <span className="sniper-limit-value">{config?.autoModeSettings?.maxTradesPerSession || 10}</span>
        </div>
        <div className="sniper-limit-item">
          <span className="sniper-limit-label">Max SOL</span>
          <span className="sniper-limit-value">{config?.autoModeSettings?.maxSolPerSession || 5}</span>
        </div>
        <div className="sniper-limit-item">
          <span className="sniper-limit-label">Cooldown</span>
          <span className="sniper-limit-value">{config?.autoModeSettings?.cooldownSeconds || 60}s</span>
        </div>
        <div className="sniper-limit-item">
          <span className="sniper-limit-label">Auto-Stop</span>
          <span className="sniper-limit-value">{config?.autoModeSettings?.maxConsecutiveLosses || 3} losses</span>
        </div>
      </div>
    </div>
  )
}

function BuiltInWalletUnlock({ onUnlock, loading }) {
  const [password, setPassword] = useState('')
  const [error, setError] = useState('')

  const handleUnlock = async () => {
    if (!password) {
      setError('Please enter your password')
      return
    }
    setError('')
    try {
      await onUnlock(password)
    } catch (err) {
      setError(err.message || 'Invalid password')
    }
  }

  return (
    <div className="sniper-wallet-unlock-form">
      <p>Enter password to unlock your built-in wallet:</p>
      <div className="sniper-unlock-row">
        <input
          type="password"
          value={password}
          onChange={(e) => setPassword(e.target.value)}
          placeholder="Wallet password"
          className="sniper-unlock-input"
          onKeyDown={(e) => e.key === 'Enter' && handleUnlock()}
        />
        <button
          className="sniper-unlock-btn"
          onClick={handleUnlock}
          disabled={loading}
        >
          {loading ? 'Unlocking...' : 'Unlock'}
        </button>
      </div>
      {error && <p className="sniper-unlock-error">{error}</p>}
    </div>
  )
}

function QuickActionBar({ mode, setMode, amount, setAmount, onGo, disabled, modeSettings, onModeSettingsSave }) {
  const [showModeModal, setShowModeModal] = useState(false)
  
  return (
    <>
      <ModeSettingsModal
        mode={mode}
        isOpen={showModeModal}
        onClose={() => setShowModeModal(false)}
        settings={modeSettings?.[mode] || {}}
        onSave={(settings) => onModeSettingsSave(mode, settings)}
      />
      <div className="quick-action-bar section-box">
        <div className="quick-action-modes">
          <button className={mode === 'manual' ? 'active' : ''} onClick={() => setMode('manual')}>Manual</button>
          <button className={mode === 'semi-auto' ? 'active' : ''} onClick={() => setMode('semi-auto')}>Semi-Auto</button>
          <button className={mode === 'full-auto' ? 'active' : ''} onClick={() => setMode('full-auto')}>Full Auto</button>
          <button className="quick-action-settings" onClick={() => setShowModeModal(true)} title="Configure settings">‚öôÔ∏è</button>
        </div>
        <div className="quick-action-amount">
          <input type="number" value={amount} onChange={(e) => setAmount(e.target.value)} step="0.1" min="0.01" />
          <span>SOL</span>
        </div>
        <button className="quick-action-go" onClick={onGo} disabled={disabled}>GO</button>
        <p className="quick-action-hint">Select mode, tap ‚öôÔ∏è to configure, then GO</p>
      </div>
    </>
  )
}

function AdvancedSettingsSection({ children, expanded, onToggle }) {
  return (
    <div className={`advanced-settings-section ${expanded ? 'expanded' : ''}`}>
      <button className="advanced-settings-toggle" onClick={onToggle}>
        {expanded ? '‚ñº Hide Advanced Settings' : '‚ñ∂ Show Advanced Settings'}
      </button>
      {expanded && <div className="advanced-settings-content">{children}</div>}
    </div>
  )
}

function ActiveTradesPanel({ positions, expanded, onToggle, onStopAll, livePrices, modeSettings, selectedChain }) {
  const calculatePnl = (position, currentPrice) => {
    const entry = position.entryPriceUsd || position.entryPrice || 0
    const current = currentPrice || position.currentPriceUsd || entry
    if (entry === 0) return 0
    return ((current - entry) / entry) * 100
  }

  const getProgressToTarget = (position, currentPrice) => {
    const entry = parseFloat(position.entryPriceUsd || position.entryPrice) || 0
    const current = parseFloat(currentPrice || position.currentPriceUsd) || entry
    const rawTP = parseFloat(modeSettings?.['full-auto']?.takeProfit)
    const rawSL = parseFloat(modeSettings?.['full-auto']?.stopLoss)
    const takeProfit = isNaN(rawTP) || rawTP <= 0 ? 50 : rawTP
    const stopLoss = isNaN(rawSL) || rawSL <= 0 ? 20 : rawSL
    
    if (entry === 0 || isNaN(entry)) return 0
    
    const pnlPercent = ((current - entry) / entry) * 100
    if (isNaN(pnlPercent)) return 0
    
    if (pnlPercent >= 0) {
      return Math.min(100, Math.max(0, (pnlPercent / takeProfit) * 100))
    } else {
      return Math.max(-100, Math.min(0, (pnlPercent / stopLoss) * 100))
    }
  }

  const getChainBadge = (chain) => {
    const chains = {
      solana: { icon: '‚óé', color: '#9945FF' },
      ethereum: { icon: '‚¨°', color: '#627EEA' },
      base: { icon: 'üîµ', color: '#0052FF' },
      polygon: { icon: '‚¨¢', color: '#8247E5' },
      arbitrum: { icon: 'üî∑', color: '#28A0F0' },
      bsc: { icon: '‚ö´', color: '#F0B90B' }
    }
    return chains[chain] || chains.solana
  }

  return (
    <div className={`active-trades-panel section-box ${expanded ? 'expanded' : 'collapsed'}`}>
      <div className="active-trades-header" onClick={onToggle}>
        <div className="active-trades-title">
          <span className="active-trades-icon">üìä</span>
          <span>Active Trades</span>
          <span className="active-trades-count">{positions?.length || 0}</span>
        </div>
        <div className="active-trades-actions">
          <button 
            className="kill-switch-btn"
            onClick={(e) => {
              e.stopPropagation()
              if (window.confirm('Stop all active trades? This will immediately close all positions.')) {
                onStopAll()
              }
            }}
            disabled={!positions || positions.length === 0}
          >
            ‚õî STOP ALL
          </button>
          <span className="active-trades-toggle">
            {expanded ? '‚ñ≤' : '‚ñº'}
          </span>
        </div>
      </div>

      {expanded && (
        <div className="active-trades-content">
          {(!positions || positions.length === 0) ? (
            <div className="active-trades-empty">
              <span className="empty-icon">üì≠</span>
              <span>No active trades</span>
            </div>
          ) : (
            <>
              <div className="active-trades-list">
                {positions.map((position, index) => {
                  const currentPrice = livePrices?.[position.tokenAddress] || position.currentPriceUsd
                  const pnl = calculatePnl(position, currentPrice)
                  const progress = getProgressToTarget(position, currentPrice)
                  const chainBadge = getChainBadge(position.chain || selectedChain)
                  
                  return (
                    <div key={position.id || index} className="active-trade-item">
                      <div className="trade-token-info">
                        <span 
                          className="trade-chain-badge" 
                          style={{ backgroundColor: chainBadge.color }}
                        >
                          {chainBadge.icon}
                        </span>
                        <span className="trade-token-symbol">{position.tokenSymbol || position.symbol || '???'}</span>
                      </div>
                      <div className="trade-prices">
                        <div className="trade-price-row">
                          <span className="trade-price-label">Entry:</span>
                          <span className="trade-price-value">${(position.entryPriceUsd || position.entryPrice || 0).toFixed(6)}</span>
                        </div>
                        <div className="trade-price-row">
                          <span className="trade-price-label">Current:</span>
                          <span className="trade-price-value">${(currentPrice || 0).toFixed(6)}</span>
                        </div>
                      </div>
                      <div className={`trade-pnl ${pnl >= 0 ? 'positive' : 'negative'}`}>
                        {pnl >= 0 ? '+' : ''}{pnl.toFixed(2)}%
                      </div>
                      <div className="trade-progress-container">
                        <div className="trade-progress-bar">
                          <div 
                            className={`trade-progress-fill ${progress >= 0 ? 'profit' : 'loss'}`}
                            style={{ 
                              width: `${Math.abs(progress)}%`,
                              marginLeft: progress < 0 ? 'auto' : 0
                            }}
                          />
                        </div>
                        <div className="trade-progress-labels">
                          <span className="progress-label loss">SL</span>
                          <span className="progress-label profit">TP</span>
                        </div>
                      </div>
                    </div>
                  )
                })}
              </div>
              
              {positions.length > 0 && (
                <div className="active-trades-chart">
                  <div className="mini-chart-placeholder">
                    <span className="chart-icon">üìà</span>
                    <span className="chart-label">{positions[0]?.tokenSymbol || 'Token'} Mini Chart</span>
                    <div className="mini-candles">
                      {[...Array(20)].map((_, i) => (
                        <div 
                          key={i} 
                          className={`mini-candle ${Math.random() > 0.5 ? 'green' : 'red'}`}
                          style={{ height: `${20 + Math.random() * 60}%` }}
                        />
                      ))}
                    </div>
                  </div>
                </div>
              )}
            </>
          )}
        </div>
      )}
    </div>
  )
}

function AIInsightsCard({ stats, isActive }) {
  const confidenceLevel = stats?.winRate >= 60 ? 'high' : stats?.winRate >= 40 ? 'medium' : 'low'
  const riskLevel = stats?.totalPnl >= 0 ? 'low' : stats?.totalPnl >= -1 ? 'medium' : 'high'
  
  return (
    <div className="section-box ai-insights-card">
      <div className="ai-insights-header">
        <span className="ai-insights-title">ü§ñ AI Insights</span>
        <span className={`ai-status-badge ${isActive ? 'active' : ''}`}>
          {isActive ? 'Analyzing' : 'Ready'}
        </span>
      </div>
      <div className="ai-insights-metrics">
        <div className="ai-insight-item">
          <span className="ai-insight-label">Confidence</span>
          <span className={`ai-insight-value ${confidenceLevel}`}>
            {confidenceLevel === 'high' ? 'üü¢ High' : confidenceLevel === 'medium' ? 'üü° Medium' : 'üî¥ Low'}
          </span>
        </div>
        <div className="ai-insight-item">
          <span className="ai-insight-label">Risk Level</span>
          <span className={`ai-insight-value ${riskLevel}`}>
            {riskLevel === 'low' ? 'üü¢ Low' : riskLevel === 'medium' ? 'üü° Medium' : 'üî¥ High'}
          </span>
        </div>
        <div className="ai-insight-item">
          <span className="ai-insight-label">Session P&L</span>
          <span className={`ai-insight-value ${(stats?.totalPnl || 0) >= 0 ? 'positive' : 'negative'}`}>
            {(stats?.totalPnl || 0) >= 0 ? '+' : ''}{(stats?.totalPnl || 0).toFixed(3)} SOL
          </span>
        </div>
      </div>
      <div className="ai-insights-reasoning">
        <span className="ai-reasoning-label">Current Strategy</span>
        <p className="ai-reasoning-text">
          {isActive 
            ? 'Monitoring market for high-confidence entry signals. Applying safety filters and volume analysis.'
            : 'Ready to analyze. Start a session to receive AI trading recommendations.'}
        </p>
      </div>
    </div>
  )
}

function GlossaryModal({ term, onClose }) {
  if (!term || !GLOSSARY_DATA[term]) return null
  
  const data = GLOSSARY_DATA[term]
  
  return (
    <div className="glossary-modal-overlay" onClick={onClose}>
      <div className="glossary-modal" onClick={(e) => e.stopPropagation()}>
        <button className="glossary-modal-close" onClick={onClose}>√ó</button>
        <div className="glossary-modal-content">
          <h3 className="glossary-modal-term">{data.term}</h3>
          <p className="glossary-modal-definition">{data.definition}</p>
        </div>
      </div>
    </div>
  )
}

function GlossaryTerm({ term, children, onTermClick }) {
  return (
    <span 
      className="glossary-term" 
      onClick={() => onTermClick(term)}
    >
      {children || term}
    </span>
  )
}

function ModeSettingsModal({ mode, isOpen, onClose, settings, onSave }) {
  const [localSettings, setLocalSettings] = useState(settings || {})
  
  useEffect(() => {
    if (settings) {
      setLocalSettings(settings)
    }
  }, [settings, mode])
  
  if (!isOpen) return null
  
  const modeLabels = {
    'manual': 'Manual Mode',
    'semi-auto': 'Semi-Auto Mode',
    'full-auto': 'Full Auto Mode'
  }
  
  const modeIcons = {
    'manual': 'üéØ',
    'semi-auto': 'ü§ñ',
    'full-auto': '‚ö°'
  }
  
  const handleChange = (field, value) => {
    setLocalSettings(prev => ({ ...prev, [field]: value }))
  }
  
  const handleSave = () => {
    onSave(localSettings)
    onClose()
  }
  
  return (
    <div className="mode-settings-overlay" onClick={onClose}>
      <div className="mode-settings-modal" onClick={(e) => e.stopPropagation()}>
        <div className="mode-settings-header">
          <div className="mode-settings-title">
            <span className="mode-settings-icon">{modeIcons[mode]}</span>
            <span>{modeLabels[mode]} Settings</span>
          </div>
          <button className="mode-settings-close" onClick={onClose}>√ó</button>
        </div>
        
        <div className="mode-settings-content">
          {mode === 'manual' && (
            <>
              <div className="mode-setting-group">
                <label className="mode-setting-label">Token Address</label>
                <input 
                  type="text" 
                  className="mode-setting-input"
                  placeholder="Enter token contract address..."
                  value={localSettings.tokenAddress || ''}
                  onChange={(e) => handleChange('tokenAddress', e.target.value)}
                />
              </div>
              <div className="mode-setting-row">
                <div className="mode-setting-group">
                  <label className="mode-setting-label">Buy Amount (SOL)</label>
                  <input 
                    type="number" 
                    className="mode-setting-input"
                    step="0.1"
                    min="0.01"
                    value={localSettings.buyAmount || 0.1}
                    onChange={(e) => handleChange('buyAmount', parseFloat(e.target.value))}
                  />
                </div>
                <div className="mode-setting-group">
                  <label className="mode-setting-label">Slippage %</label>
                  <input 
                    type="number" 
                    className="mode-setting-input"
                    step="0.5"
                    min="0.1"
                    max="50"
                    value={localSettings.slippage || 5}
                    onChange={(e) => handleChange('slippage', parseFloat(e.target.value))}
                  />
                </div>
              </div>
              <div className="mode-setting-row">
                <div className="mode-setting-group">
                  <label className="mode-setting-label">Take Profit %</label>
                  <input 
                    type="number" 
                    className="mode-setting-input"
                    step="5"
                    min="1"
                    value={localSettings.takeProfit || 50}
                    onChange={(e) => handleChange('takeProfit', parseFloat(e.target.value))}
                  />
                </div>
                <div className="mode-setting-group">
                  <label className="mode-setting-label">Stop Loss %</label>
                  <input 
                    type="number" 
                    className="mode-setting-input"
                    step="5"
                    min="1"
                    value={localSettings.stopLoss || 20}
                    onChange={(e) => handleChange('stopLoss', parseFloat(e.target.value))}
                  />
                </div>
              </div>
            </>
          )}
          
          {mode === 'semi-auto' && (
            <>
              <div className="mode-setting-group">
                <label className="mode-setting-label">Auto-Detect Tokens</label>
                <div className="mode-setting-toggle-row">
                  <span className="mode-setting-desc">AI finds tokens for you to approve</span>
                  <button 
                    className={`mode-setting-toggle ${localSettings.autoDetect ? 'active' : ''}`}
                    onClick={() => handleChange('autoDetect', !localSettings.autoDetect)}
                  >
                    {localSettings.autoDetect ? 'ON' : 'OFF'}
                  </button>
                </div>
              </div>
              <div className="mode-setting-row">
                <div className="mode-setting-group">
                  <label className="mode-setting-label">Approval Timeout (sec)</label>
                  <input 
                    type="number" 
                    className="mode-setting-input"
                    step="5"
                    min="5"
                    max="300"
                    value={localSettings.approvalTimeout || 30}
                    onChange={(e) => handleChange('approvalTimeout', parseInt(e.target.value))}
                  />
                </div>
                <div className="mode-setting-group">
                  <label className="mode-setting-label">Max Trades/Session</label>
                  <input 
                    type="number" 
                    className="mode-setting-input"
                    step="1"
                    min="1"
                    max="100"
                    value={localSettings.maxTrades || 10}
                    onChange={(e) => handleChange('maxTrades', parseInt(e.target.value))}
                  />
                </div>
              </div>
              <div className="mode-setting-group">
                <label className="mode-setting-label">Risk Level</label>
                <div className="mode-setting-buttons">
                  {['Conservative', 'Moderate', 'Aggressive'].map(level => (
                    <button 
                      key={level}
                      className={`mode-setting-btn ${localSettings.riskLevel === level ? 'active' : ''}`}
                      onClick={() => handleChange('riskLevel', level)}
                    >
                      {level}
                    </button>
                  ))}
                </div>
              </div>
              <div className="mode-setting-row">
                <div className="mode-setting-group">
                  <label className="mode-setting-label">Buy Amount (SOL)</label>
                  <input 
                    type="number" 
                    className="mode-setting-input"
                    step="0.1"
                    min="0.01"
                    value={localSettings.buyAmount || 0.1}
                    onChange={(e) => handleChange('buyAmount', parseFloat(e.target.value))}
                  />
                </div>
              </div>
              <div className="mode-setting-row">
                <div className="mode-setting-group">
                  <label className="mode-setting-label">Take Profit %</label>
                  <input 
                    type="number" 
                    className="mode-setting-input"
                    step="5"
                    min="1"
                    value={localSettings.takeProfit || 50}
                    onChange={(e) => handleChange('takeProfit', parseFloat(e.target.value))}
                  />
                </div>
                <div className="mode-setting-group">
                  <label className="mode-setting-label">Stop Loss %</label>
                  <input 
                    type="number" 
                    className="mode-setting-input"
                    step="5"
                    min="1"
                    value={localSettings.stopLoss || 20}
                    onChange={(e) => handleChange('stopLoss', parseFloat(e.target.value))}
                  />
                </div>
              </div>
            </>
          )}
          
          {mode === 'full-auto' && (
            <>
              <div className="mode-setting-row">
                <div className="mode-setting-group">
                  <label className="mode-setting-label">Max SOL/Session</label>
                  <input 
                    type="number" 
                    className="mode-setting-input"
                    step="0.5"
                    min="0.1"
                    value={localSettings.maxSol || 5}
                    onChange={(e) => handleChange('maxSol', parseFloat(e.target.value))}
                  />
                </div>
                <div className="mode-setting-group">
                  <label className="mode-setting-label">Max Trades/Session</label>
                  <input 
                    type="number" 
                    className="mode-setting-input"
                    step="1"
                    min="1"
                    max="100"
                    value={localSettings.maxTrades || 10}
                    onChange={(e) => handleChange('maxTrades', parseInt(e.target.value))}
                  />
                </div>
              </div>
              <div className="mode-setting-row">
                <div className="mode-setting-group">
                  <label className="mode-setting-label">Min Safety Score (0-100)</label>
                  <input 
                    type="number" 
                    className="mode-setting-input"
                    step="5"
                    min="0"
                    max="100"
                    value={localSettings.minSafetyScore || 60}
                    onChange={(e) => handleChange('minSafetyScore', parseInt(e.target.value))}
                  />
                </div>
                <div className="mode-setting-group">
                  <label className="mode-setting-label">Cooldown (seconds)</label>
                  <input 
                    type="number" 
                    className="mode-setting-input"
                    step="5"
                    min="0"
                    max="600"
                    value={localSettings.cooldown || 60}
                    onChange={(e) => handleChange('cooldown', parseInt(e.target.value))}
                  />
                </div>
              </div>
              <div className="mode-setting-group">
                <label className="mode-setting-label">Max Consecutive Losses</label>
                <input 
                  type="number" 
                  className="mode-setting-input"
                  step="1"
                  min="1"
                  max="20"
                  value={localSettings.maxLosses || 3}
                  onChange={(e) => handleChange('maxLosses', parseInt(e.target.value))}
                />
              </div>
              <div className="mode-setting-group">
                <label className="mode-setting-label">Auto-Compound Profits</label>
                <div className="mode-setting-toggle-row">
                  <span className="mode-setting-desc">Reinvest gains into new trades</span>
                  <button 
                    className={`mode-setting-toggle ${localSettings.autoCompound ? 'active' : ''}`}
                    onClick={() => handleChange('autoCompound', !localSettings.autoCompound)}
                  >
                    {localSettings.autoCompound ? 'ON' : 'OFF'}
                  </button>
                </div>
              </div>
              
              <div className="notification-settings">
                <div className="notification-settings-header">
                  <span className="notification-settings-title">üîî Notifications</span>
                </div>
                
                <div className="mode-setting-group">
                  <label className="mode-setting-label">Enable Telegram Notifications</label>
                  <div className="mode-setting-toggle-row">
                    <span className="mode-setting-desc">Receive alerts via Telegram</span>
                    <button 
                      className={`mode-setting-toggle ${localSettings.notifications?.telegram ? 'active' : ''}`}
                      onClick={() => handleChange('notifications', { 
                        ...localSettings.notifications, 
                        telegram: !localSettings.notifications?.telegram 
                      })}
                    >
                      {localSettings.notifications?.telegram ? 'ON' : 'OFF'}
                    </button>
                  </div>
                </div>
                
                <div className="mode-setting-group">
                  <label className="mode-setting-label">Enable In-App Notifications</label>
                  <div className="mode-setting-toggle-row">
                    <span className="mode-setting-desc">Show in-app alerts and sounds</span>
                    <button 
                      className={`mode-setting-toggle ${localSettings.notifications?.inApp ? 'active' : ''}`}
                      onClick={() => handleChange('notifications', { 
                        ...localSettings.notifications, 
                        inApp: !localSettings.notifications?.inApp 
                      })}
                    >
                      {localSettings.notifications?.inApp ? 'ON' : 'OFF'}
                    </button>
                  </div>
                </div>
                
                <div className="notification-triggers">
                  <label className="mode-setting-label">Notification Triggers</label>
                  <div className="notification-triggers-grid">
                    <label className="notification-checkbox-item">
                      <input 
                        type="checkbox" 
                        checked={localSettings.notifications?.triggers?.everyTrade ?? true}
                        onChange={(e) => handleChange('notifications', { 
                          ...localSettings.notifications, 
                          triggers: { ...localSettings.notifications?.triggers, everyTrade: e.target.checked }
                        })}
                      />
                      <span>On every trade</span>
                    </label>
                    <label className="notification-checkbox-item">
                      <input 
                        type="checkbox" 
                        checked={localSettings.notifications?.triggers?.takeProfit ?? true}
                        onChange={(e) => handleChange('notifications', { 
                          ...localSettings.notifications, 
                          triggers: { ...localSettings.notifications?.triggers, takeProfit: e.target.checked }
                        })}
                      />
                      <span>On take profit hit</span>
                    </label>
                    <label className="notification-checkbox-item">
                      <input 
                        type="checkbox" 
                        checked={localSettings.notifications?.triggers?.stopLoss ?? true}
                        onChange={(e) => handleChange('notifications', { 
                          ...localSettings.notifications, 
                          triggers: { ...localSettings.notifications?.triggers, stopLoss: e.target.checked }
                        })}
                      />
                      <span>On stop loss triggered</span>
                    </label>
                    <label className="notification-checkbox-item">
                      <input 
                        type="checkbox" 
                        checked={localSettings.notifications?.triggers?.sessionPaused ?? true}
                        onChange={(e) => handleChange('notifications', { 
                          ...localSettings.notifications, 
                          triggers: { ...localSettings.notifications?.triggers, sessionPaused: e.target.checked }
                        })}
                      />
                      <span>On session paused</span>
                    </label>
                    <label className="notification-checkbox-item">
                      <input 
                        type="checkbox" 
                        checked={localSettings.notifications?.triggers?.dailySummary ?? false}
                        onChange={(e) => handleChange('notifications', { 
                          ...localSettings.notifications, 
                          triggers: { ...localSettings.notifications?.triggers, dailySummary: e.target.checked }
                        })}
                      />
                      <span>Daily P&L summary</span>
                    </label>
                  </div>
                </div>
              </div>
            </>
          )}
        </div>
        
        <div className="mode-settings-footer">
          <button className="mode-settings-cancel" onClick={onClose}>Cancel</button>
          <button className="mode-settings-save" onClick={handleSave}>Save & Apply</button>
        </div>
      </div>
    </div>
  )
}

function QuantSystemSection() {
  const [selectedGlossaryTerm, setSelectedGlossaryTerm] = useState(null)
  const [quantMetrics, setQuantMetrics] = useState({
    totalScans: 12847,
    tokensAnalyzed: 89234,
    signalsGenerated: 3421,
    modelAccuracy: 73.2
  })
  
  const [tradeFeed, setTradeFeed] = useState([
    { id: 1, type: 'buy', token: 'BONK', price: 0.00002341, pnl: null, timestamp: new Date(Date.now() - 120000) },
    { id: 2, type: 'sell', token: 'WIF', price: 2.34, pnl: 12.5, timestamp: new Date(Date.now() - 300000) },
    { id: 3, type: 'sell', token: 'POPCAT', price: 1.87, pnl: -5.2, timestamp: new Date(Date.now() - 600000) },
    { id: 4, type: 'buy', token: 'MEW', price: 0.0089, pnl: null, timestamp: new Date(Date.now() - 900000) },
    { id: 5, type: 'sell', token: 'MYRO', price: 0.156, pnl: 28.3, timestamp: new Date(Date.now() - 1200000) },
  ])
  
  const [accuracyStats, setAccuracyStats] = useState({
    winRate: 67.8,
    totalPredictions: 1247,
    bestTrade: { token: 'BONK', pnl: 156.2 },
    worstTrade: { token: 'SLERF', pnl: -42.5 }
  })
  
  const [pinUnlocked, setPinUnlocked] = useState(false)
  const [pinInput, setPinInput] = useState('')
  const [scannerActive, setScannerActive] = useState(false)
  const [scanInterval, setScanInterval] = useState(5)
  const [selectedCategory, setSelectedCategory] = useState('all')

  useEffect(() => {
    const fetchQuantData = async () => {
      try {
        const [metricsRes, feedRes] = await Promise.all([
          fetch('/api/quant/metrics').catch(() => null),
          fetch('/api/quant/trade-feed').catch(() => null)
        ])
        if (metricsRes?.ok) {
          const data = await metricsRes.json()
          if (data.totalScans !== undefined) {
            setQuantMetrics({
              totalScans: data.totalScans || 0,
              tokensAnalyzed: data.totalTokensAnalyzed || 0,
              signalsGenerated: data.signalsGenerated || 0,
              modelAccuracy: parseFloat(data.modelAccuracy) || 0
            })
          }
          if (data.winRate !== undefined) {
            setAccuracyStats(prev => ({
              ...prev,
              winRate: parseFloat(data.winRate) || prev.winRate,
              totalPredictions: data.tradesExecuted || prev.totalPredictions
            }))
          }
        }
        if (feedRes?.ok) {
          const data = await feedRes.json()
          if (data.trades && data.trades.length > 0) {
            setTradeFeed(data.trades.map(t => ({
              id: t.id,
              type: t.type?.toLowerCase() || 'buy',
              token: t.tokenSymbol || t.token || '???',
              price: parseFloat(t.priceUsd) || parseFloat(t.price) || 0,
              pnl: t.pnlPercent !== null ? parseFloat(t.pnlPercent) : null,
              timestamp: t.executedAt || t.timestamp || new Date()
            })))
          }
        }
      } catch (err) {
        console.log('Using mock quant data')
      }
    }
    fetchQuantData()
  }, [])

  const handlePinSubmit = () => {
    if (pinInput === '0424') {
      setPinUnlocked(true)
      setPinInput('')
    } else {
      alert('Invalid PIN')
      setPinInput('')
    }
  }

  const formatTime = (date) => {
    const now = new Date()
    const diff = Math.floor((now - new Date(date)) / 1000)
    if (diff < 60) return `${diff}s ago`
    if (diff < 3600) return `${Math.floor(diff / 60)}m ago`
    return `${Math.floor(diff / 3600)}h ago`
  }

  return (
    <div className="quant-system-container">
      {selectedGlossaryTerm && (
        <GlossaryModal 
          term={selectedGlossaryTerm} 
          onClose={() => setSelectedGlossaryTerm(null)} 
        />
      )}
      <div className="quant-system-header">
        <div className="quant-header-left">
          <h2 className="quant-title">
            <span className="quant-icon">üß†</span>
            QUANT SYSTEM
          </h2>
          <p className="quant-subtitle">AI-Powered Market Intelligence</p>
        </div>
        <div className="quant-header-badge">
          <span className="quant-badge-dot"></span>
          <span className="quant-badge-text">LEARNING</span>
        </div>
      </div>

      <div className="quant-cards-grid">
        <div className="quant-glass-card quant-metrics-card">
          <div className="quant-card-header">
            <span className="quant-card-icon">üìä</span>
            <h3 className="quant-card-title">Learning Metrics</h3>
          </div>
          <div className="quant-metrics-grid">
            <div className="quant-metric-item">
              <div className="quant-metric-value cyan">{quantMetrics.totalScans.toLocaleString()}</div>
              <div className="quant-metric-label">Total Scans</div>
            </div>
            <div className="quant-metric-item">
              <div className="quant-metric-value purple">{quantMetrics.tokensAnalyzed.toLocaleString()}</div>
              <div className="quant-metric-label">Tokens Analyzed</div>
            </div>
            <div className="quant-metric-item">
              <div className="quant-metric-value cyan">{quantMetrics.signalsGenerated.toLocaleString()}</div>
              <div className="quant-metric-label">Signals Generated</div>
            </div>
            <div className="quant-metric-item">
              <div className="quant-metric-value green">{quantMetrics.modelAccuracy}%</div>
              <div className="quant-metric-label">
                <GlossaryTerm term="model_accuracy" onTermClick={setSelectedGlossaryTerm}>Model Accuracy</GlossaryTerm>
              </div>
            </div>
          </div>
          <div className="quant-progress-bar">
            <div className="quant-progress-fill" style={{ width: `${quantMetrics.modelAccuracy}%` }}></div>
          </div>
          <div className="quant-progress-label">
            <GlossaryTerm term="system_learning_progress" onTermClick={setSelectedGlossaryTerm}>System Learning Progress</GlossaryTerm>
          </div>
        </div>

        <div className="quant-glass-card quant-feed-card">
          <div className="quant-card-header">
            <span className="quant-card-icon">‚ö°</span>
            <h3 className="quant-card-title">Live Trade Feed</h3>
            <span className="quant-live-indicator">‚óè LIVE</span>
          </div>
          <div className="quant-feed-list">
            {tradeFeed.map(trade => (
              <div key={trade.id} className={`quant-feed-item ${trade.type}`}>
                <div className="quant-feed-left">
                  <span className={`quant-feed-type ${trade.type}`}>
                    {trade.type === 'buy' ? 'üü¢' : 'üî¥'} {trade.type.toUpperCase()}
                  </span>
                  <span className="quant-feed-token">{trade.token}</span>
                </div>
                <div className="quant-feed-right">
                  <span className="quant-feed-price">
                    ${trade.price < 0.01 ? trade.price.toExponential(2) : trade.price.toFixed(4)}
                  </span>
                  {trade.pnl !== null && (
                    <span className={`quant-feed-pnl ${trade.pnl >= 0 ? 'green' : 'red'}`}>
                      {trade.pnl >= 0 ? '+' : ''}{trade.pnl.toFixed(1)}%
                    </span>
                  )}
                  <span className="quant-feed-time">{formatTime(trade.timestamp)}</span>
                </div>
              </div>
            ))}
          </div>
        </div>

        <div className="quant-glass-card quant-accuracy-card">
          <div className="quant-card-header">
            <span className="quant-card-icon">üéØ</span>
            <h3 className="quant-card-title">Accuracy Stats</h3>
          </div>
          <div className="quant-accuracy-main">
            <div className="quant-winrate-circle">
              <svg viewBox="0 0 100 100">
                <circle cx="50" cy="50" r="45" className="quant-circle-bg" />
                <circle 
                  cx="50" cy="50" r="45" 
                  className="quant-circle-progress"
                  strokeDasharray={`${accuracyStats.winRate * 2.83} 283`}
                />
              </svg>
              <div className="quant-winrate-value">{accuracyStats.winRate}%</div>
              <div className="quant-winrate-label">
                <GlossaryTerm term="win_rate" onTermClick={setSelectedGlossaryTerm}>WIN RATE</GlossaryTerm>
              </div>
            </div>
          </div>
          <div className="quant-accuracy-stats">
            <div className="quant-accuracy-stat">
              <span className="quant-accuracy-label">
                <GlossaryTerm term="total_predictions" onTermClick={setSelectedGlossaryTerm}>Total Predictions</GlossaryTerm>
              </span>
              <span className="quant-accuracy-value cyan">{accuracyStats.totalPredictions.toLocaleString()}</span>
            </div>
            <div className="quant-accuracy-stat best">
              <span className="quant-accuracy-label">
                <GlossaryTerm term="best_trade" onTermClick={setSelectedGlossaryTerm}>Best Trade</GlossaryTerm>
              </span>
              <span className="quant-accuracy-value green">
                {accuracyStats.bestTrade.token} +{accuracyStats.bestTrade.pnl}%
              </span>
            </div>
            <div className="quant-accuracy-stat worst">
              <span className="quant-accuracy-label">
                <GlossaryTerm term="worst_trade" onTermClick={setSelectedGlossaryTerm}>Worst Trade</GlossaryTerm>
              </span>
              <span className="quant-accuracy-value red">
                {accuracyStats.worstTrade.token} {accuracyStats.worstTrade.pnl}%
              </span>
            </div>
          </div>
        </div>
      </div>

      <div className="quant-private-section">
        <div className="quant-private-header">
          <span className="quant-private-icon">üîí</span>
          <h3 className="quant-private-title">Quant Controls</h3>
          {pinUnlocked && <span className="quant-unlocked-badge">UNLOCKED</span>}
        </div>
        
        {!pinUnlocked ? (
          <div className="quant-pin-gate">
            <p className="quant-pin-text">Enter PIN to access trading controls</p>
            <div className="quant-pin-input-row">
              <input
                type="password"
                value={pinInput}
                onChange={(e) => setPinInput(e.target.value)}
                placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢"
                maxLength={4}
                className="quant-pin-input"
                onKeyDown={(e) => e.key === 'Enter' && handlePinSubmit()}
              />
              <button className="quant-pin-btn" onClick={handlePinSubmit}>
                Unlock
              </button>
            </div>
          </div>
        ) : (
          <div className="quant-controls-grid">
            <div className="quant-glass-card quant-control-card">
              <div className="quant-control-header">
                <span>Auto-Scanner</span>
                <button 
                  className={`quant-toggle-btn ${scannerActive ? 'active' : ''}`}
                  onClick={() => setScannerActive(!scannerActive)}
                >
                  {scannerActive ? 'ON' : 'OFF'}
                </button>
              </div>
              <div className="quant-control-options">
                <label className="quant-control-label">
                  <span>Interval (min)</span>
                  <input 
                    type="number" 
                    value={scanInterval}
                    onChange={(e) => setScanInterval(Number(e.target.value))}
                    className="quant-control-input"
                    min={1}
                    max={60}
                  />
                </label>
                <label className="quant-control-label">
                  <span>Category</span>
                  <select 
                    value={selectedCategory}
                    onChange={(e) => setSelectedCategory(e.target.value)}
                    className="quant-control-select"
                  >
                    <option value="all">All</option>
                    <option value="meme">Meme</option>
                    <option value="defi">DeFi</option>
                    <option value="gaming">Gaming</option>
                  </select>
                </label>
              </div>
            </div>

            <div className="quant-glass-card quant-control-card">
              <div className="quant-control-header">
                <span>Trade Actions</span>
              </div>
              <div className="quant-trade-buttons">
                <button className="quant-trade-btn buy">üü¢ BUY NOW</button>
                <button className="quant-trade-btn sell">üî¥ SELL NOW</button>
                <button className="quant-trade-btn stop">‚õî STOP ALL</button>
              </div>
            </div>

            <div className="quant-glass-card quant-control-card quant-settings-card">
              <div className="quant-control-header">
                <span>Settings</span>
              </div>
              <div className="quant-settings-grid">
                <label className="quant-setting-item">
                  <span>Min Score</span>
                  <input type="number" defaultValue={60} className="quant-control-input" />
                </label>
                <label className="quant-setting-item">
                  <span>Max Risk</span>
                  <input type="number" defaultValue={30} className="quant-control-input" />
                </label>
                <label className="quant-setting-item">
                  <span>Stop Loss %</span>
                  <input type="number" defaultValue={15} className="quant-control-input" />
                </label>
                <label className="quant-setting-item">
                  <span>Take Profit %</span>
                  <input type="number" defaultValue={50} className="quant-control-input" />
                </label>
              </div>
            </div>
          </div>
        )}
      </div>
    </div>
  )
}

function QuickSettingsPanel({ config, updateConfig, expanded, onToggle }) {
  return (
    <div className="section-box sniper-settings-panel">
      <button className="sniper-accordion-header" onClick={onToggle}>
        <span className="sniper-accordion-title">Quick Settings</span>
        <span className={`sniper-accordion-arrow ${expanded ? 'expanded' : ''}`}>‚ñº</span>
      </button>
      {expanded && (
        <div className="sniper-settings-grid">
          <label className="sniper-setting-item">
            <span className="sniper-setting-label">Buy Amount (SOL)</span>
            <input
              type="number"
              step="0.1"
              value={config.tradeControls.buyAmountSol}
              onChange={(e) => updateConfig('tradeControls', 'buyAmountSol', parseFloat(e.target.value))}
              className="sniper-input"
            />
          </label>
          <label className="sniper-setting-item">
            <span className="sniper-setting-label">Slippage %</span>
            <input
              type="number"
              value={config.tradeControls.slippagePercent}
              onChange={(e) => updateConfig('tradeControls', 'slippagePercent', parseInt(e.target.value))}
              className="sniper-input"
            />
          </label>
          <label className="sniper-setting-item">
            <span className="sniper-setting-label">Take Profit %</span>
            <input
              type="number"
              value={config.tradeControls.takeProfitPercent}
              onChange={(e) => updateConfig('tradeControls', 'takeProfitPercent', parseInt(e.target.value))}
              className="sniper-input"
            />
          </label>
          <label className="sniper-setting-item">
            <span className="sniper-setting-label">Stop Loss %</span>
            <input
              type="number"
              value={config.tradeControls.stopLossPercent}
              onChange={(e) => updateConfig('tradeControls', 'stopLossPercent', parseInt(e.target.value))}
              className="sniper-input"
            />
          </label>
        </div>
      )}
    </div>
  )
}

function SafetyFiltersPanel({ config, updateConfig, expanded, onToggle }) {
  return (
    <div className="section-box sniper-settings-panel">
      <button className="sniper-accordion-header" onClick={onToggle}>
        <span className="sniper-accordion-title">Safety Filters</span>
        <span className={`sniper-accordion-arrow ${expanded ? 'expanded' : ''}`}>‚ñº</span>
      </button>
      {expanded && (
        <div className="sniper-settings-grid">
          <label className="sniper-setting-item">
            <span className="sniper-setting-label">Max Bot %</span>
            <input
              type="number"
              value={config.safetyFilters.maxBotPercent}
              onChange={(e) => updateConfig('safetyFilters', 'maxBotPercent', parseInt(e.target.value))}
              className="sniper-input"
            />
          </label>
          <label className="sniper-setting-item">
            <span className="sniper-setting-label">Max Bundle %</span>
            <input
              type="number"
              value={config.safetyFilters.maxBundlePercent}
              onChange={(e) => updateConfig('safetyFilters', 'maxBundlePercent', parseInt(e.target.value))}
              className="sniper-input"
            />
          </label>
          <label className="sniper-setting-item">
            <span className="sniper-setting-label">Max Top10 %</span>
            <input
              type="number"
              value={config.safetyFilters.maxTop10HoldersPercent}
              onChange={(e) => updateConfig('safetyFilters', 'maxTop10HoldersPercent', parseInt(e.target.value))}
              className="sniper-input"
            />
          </label>
          <label className="sniper-setting-item">
            <span className="sniper-setting-label">Min Liquidity $</span>
            <input
              type="number"
              value={config.safetyFilters.minLiquidityUsd}
              onChange={(e) => updateConfig('safetyFilters', 'minLiquidityUsd', parseInt(e.target.value))}
              className="sniper-input"
            />
          </label>
        </div>
      )}
    </div>
  )
}

function RPCSettingsPanel({ rpcStatus, customRPC, setCustomRPC, onSaveCustomRPC, expanded, onToggle }) {
  const getStatusColor = (status) => {
    if (status === 'healthy') return '#39FF14'
    if (status === 'degraded') return '#FFD700'
    return '#FF4444'
  }

  return (
    <div className="section-box sniper-settings-panel">
      <button className="sniper-accordion-header" onClick={onToggle}>
        <span className="sniper-accordion-title">RPC Configuration</span>
        <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
          <span 
            className="sniper-rpc-badge"
            style={{
              padding: '2px 8px',
              borderRadius: '4px',
              fontSize: '9px',
              fontWeight: 700,
              background: rpcStatus?.type === 'helius' ? 'rgba(0, 212, 255, 0.2)' : 'rgba(157, 78, 221, 0.2)',
              color: rpcStatus?.type === 'helius' ? '#00D4FF' : '#9D4EDD',
              border: `1px solid ${rpcStatus?.type === 'helius' ? 'rgba(0, 212, 255, 0.4)' : 'rgba(157, 78, 221, 0.4)'}`,
            }}
          >
            {rpcStatus?.active || 'Loading...'}
          </span>
          <span className={`sniper-accordion-arrow ${expanded ? 'expanded' : ''}`}>‚ñº</span>
        </div>
      </button>
      {expanded && (
        <div style={{ padding: '0 16px 16px' }}>
          <div className="sniper-rpc-status" style={{ 
            display: 'flex', 
            flexWrap: 'wrap',
            gap: '16px', 
            marginBottom: '16px',
            padding: '12px',
            background: 'rgba(0,0,0,0.3)',
            borderRadius: '8px',
          }}>
            <div>
              <div style={{ fontSize: '9px', color: '#666', textTransform: 'uppercase' }}>Status</div>
              <div style={{ 
                fontSize: '13px', 
                fontWeight: 700, 
                color: getStatusColor(rpcStatus?.status),
                display: 'flex',
                alignItems: 'center',
                gap: '6px',
              }}>
                <span style={{
                  width: '8px',
                  height: '8px',
                  borderRadius: '50%',
                  background: getStatusColor(rpcStatus?.status),
                  boxShadow: `0 0 8px ${getStatusColor(rpcStatus?.status)}`,
                }} />
                {rpcStatus?.status?.toUpperCase() || 'CHECKING'}
              </div>
            </div>
            <div>
              <div style={{ fontSize: '9px', color: '#666', textTransform: 'uppercase' }}>Latency</div>
              <div style={{ fontSize: '13px', fontWeight: 700, color: '#fff' }}>
                {rpcStatus?.latencyMs ? `${rpcStatus.latencyMs}ms` : '--'}
              </div>
            </div>
            <div>
              <div style={{ fontSize: '9px', color: '#666', textTransform: 'uppercase' }}>Type</div>
              <div style={{ fontSize: '13px', fontWeight: 700, color: '#00D4FF' }}>
                {rpcStatus?.type === 'helius' ? 'Premium (Helius)' : rpcStatus?.type === 'custom' ? 'Custom' : 'Public'}
              </div>
            </div>
          </div>

          <div style={{ marginBottom: '12px' }}>
            <label style={{ display: 'block', marginBottom: '6px' }}>
              <span style={{ fontSize: '10px', color: '#666' }}>Custom RPC Endpoint (Optional)</span>
            </label>
            <div style={{ display: 'flex', gap: '8px', flexWrap: 'wrap' }}>
              <input
                type="text"
                placeholder="https://your-rpc-endpoint.com"
                value={customRPC}
                onChange={(e) => setCustomRPC(e.target.value)}
                className="sniper-input"
                style={{ flex: 1, minWidth: '200px' }}
              />
              <button
                onClick={onSaveCustomRPC}
                style={{
                  padding: '10px 16px',
                  fontSize: '11px',
                  fontWeight: 600,
                  background: customRPC ? 'rgba(0, 212, 255, 0.15)' : 'rgba(255, 68, 68, 0.15)',
                  color: customRPC ? '#00D4FF' : '#FF4444',
                  border: `1px solid ${customRPC ? 'rgba(0, 212, 255, 0.4)' : 'rgba(255, 68, 68, 0.4)'}`,
                  borderRadius: '6px',
                  cursor: 'pointer',
                  whiteSpace: 'nowrap',
                }}
              >
                {customRPC ? 'Set Custom RPC' : 'Use Default'}
              </button>
            </div>
            <div style={{ fontSize: '10px', color: '#444', marginTop: '6px' }}>
              Power users can use their own Helius, QuickNode, or Triton endpoint for faster execution
            </div>
          </div>
        </div>
      )}
    </div>
  )
}

export default function SniperBotTab({ canTrade = true, onNavigate, isViewOnly: viewOnlyProp = false, isAdmin = false, userId, userConfig }) {
  const isViewOnly = viewOnlyProp || !canTrade
  const hasControlAccess = isAdmin || !isViewOnly
  const externalWallet = useWalletState()
  const builtInWallet = useBuiltInWallet()
  const [walletSource, setWalletSource] = useState('external')
  const [mode, setMode] = useState('simple')
  const [config, setConfig] = useState(DEFAULT_CONFIG)
  const [discoveredTokens, setDiscoveredTokens] = useState([])
  const [isScanning, setIsScanning] = useState(false)
  const [activePositions, setActivePositions] = useState([])
  const [stats, setStats] = useState({ tradesExecuted: 0, winRate: 0, solUsed: 0, totalPnl: 0, maxTrades: 10, maxSol: 5 })
  const [solPrice, setSolPrice] = useState(0)
  const [autoModeActive, setAutoModeActive] = useState(false)
  const [scanInterval, setScanInterval] = useState(null)
  const [expandedSettings, setExpandedSettings] = useState(false)
  const [expandedSafety, setExpandedSafety] = useState(false)
  const [expandedRPC, setExpandedRPC] = useState(false)
  const [rpcStatus, setRpcStatus] = useState(null)
  const [customRPC, setCustomRPC] = useState('')
  const [quickMode, setQuickMode] = useState('manual')
  const [quickAmount, setQuickAmount] = useState('0.1')
  const [showAdvanced, setShowAdvanced] = useState(false)
  const [modeSettings, setModeSettings] = useState({
    manual: { buyAmount: 0.1, slippage: 5, takeProfit: 50, stopLoss: 20, tokenAddress: '' },
    'semi-auto': { autoDetect: true, approvalTimeout: 30, maxTrades: 10, riskLevel: 'Moderate', buyAmount: 0.1, takeProfit: 50, stopLoss: 20 },
    'full-auto': { 
      maxSol: 5, 
      maxTrades: 10, 
      minSafetyScore: 60, 
      cooldown: 60, 
      maxLosses: 3, 
      autoCompound: false,
      notifications: {
        telegram: true,
        inApp: true,
        triggers: {
          everyTrade: true,
          takeProfit: true,
          stopLoss: true,
          sessionPaused: true,
          dailySummary: false
        }
      }
    }
  })
  const [activeTradesPanelExpanded, setActiveTradesPanelExpanded] = useState(true)
  const [toasts, setToasts] = useState([])
  
  const showToast = useCallback((type, title, message) => {
    const notifSettings = modeSettings?.['full-auto']?.notifications
    if (notifSettings && !notifSettings.inApp) return
    
    const id = Date.now() + Math.random()
    const newToast = { id, type, title, message, exiting: false }
    setToasts(prev => [...prev.slice(-4), newToast])
    
    setTimeout(() => {
      setToasts(prev => prev.map(t => t.id === id ? { ...t, exiting: true } : t))
      setTimeout(() => {
        setToasts(prev => prev.filter(t => t.id !== id))
      }, 300)
    }, 5000)
  }, [modeSettings])
  
  const dismissToast = useCallback((id) => {
    setToasts(prev => prev.map(t => t.id === id ? { ...t, exiting: true } : t))
    setTimeout(() => {
      setToasts(prev => prev.filter(t => t.id !== id))
    }, 300)
  }, [])
  
  const handleModeSettingsSave = useCallback((mode, settings) => {
    const validated = { ...settings }
    const numericDefaults = {
      buyAmount: 0.1, slippage: 5, takeProfit: 50, stopLoss: 20,
      minSafetyScore: 60, maxTrades: 10, cooldown: 60, maxLosses: 3,
      approvalTimeout: 30, maxSol: 5
    }
    const numericRanges = {
      buyAmount: [0.01, 1000], slippage: [0.1, 50], takeProfit: [1, 1000], stopLoss: [1, 100],
      minSafetyScore: [0, 100], maxTrades: [1, 100], cooldown: [0, 600], maxLosses: [1, 20],
      approvalTimeout: [5, 300], maxSol: [0.1, 1000]
    }
    
    Object.keys(validated).forEach(key => {
      let val = validated[key]
      
      if (key in numericDefaults) {
        val = parseFloat(val)
        if (isNaN(val) || val < 0) {
          validated[key] = numericDefaults[key]
        } else if (numericRanges[key]) {
          const [min, max] = numericRanges[key]
          validated[key] = Math.max(min, Math.min(max, val))
        } else {
          validated[key] = val
        }
      }
      
      if (key === 'autoDetect' || key === 'autoCompound') {
        validated[key] = Boolean(val)
      }
    })
    
    setModeSettings(prev => ({
      ...prev,
      [mode]: { ...prev[mode], ...validated }
    }))
  }, [])
  const [safetyCheckToken, setSafetyCheckToken] = useState(null)
  const [selectedChain, setSelectedChain] = useState('solana')
  const [availableChains] = useState([
    { id: 'solana', name: 'Solana', symbol: 'SOL', isEvm: false },
    { id: 'ethereum', name: 'Ethereum', symbol: 'ETH', isEvm: true },
    { id: 'base', name: 'Base', symbol: 'ETH', isEvm: true },
    { id: 'polygon', name: 'Polygon', symbol: 'MATIC', isEvm: true },
    { id: 'arbitrum', name: 'Arbitrum', symbol: 'ETH', isEvm: true },
    { id: 'bsc', name: 'BSC', symbol: 'BNB', isEvm: true },
    { id: 'avalanche', name: 'Avalanche', symbol: 'AVAX', isEvm: true },
    { id: 'fantom', name: 'Fantom', symbol: 'FTM', isEvm: true },
    { id: 'optimism', name: 'Optimism', symbol: 'ETH', isEvm: true },
    { id: 'cronos', name: 'Cronos', symbol: 'CRO', isEvm: true },
    { id: 'gnosis', name: 'Gnosis', symbol: 'xDAI', isEvm: true },
    { id: 'celo', name: 'Celo', symbol: 'CELO', isEvm: true },
    { id: 'moonbeam', name: 'Moonbeam', symbol: 'GLMR', isEvm: true },
    { id: 'moonriver', name: 'Moonriver', symbol: 'MOVR', isEvm: true },
    { id: 'harmony', name: 'Harmony', symbol: 'ONE', isEvm: true },
    { id: 'metis', name: 'Metis', symbol: 'METIS', isEvm: true },
    { id: 'aurora', name: 'Aurora', symbol: 'ETH', isEvm: true },
    { id: 'zksync', name: 'zkSync', symbol: 'ETH', isEvm: true },
    { id: 'linea', name: 'Linea', symbol: 'ETH', isEvm: true },
    { id: 'scroll', name: 'Scroll', symbol: 'ETH', isEvm: true },
    { id: 'mantle', name: 'Mantle', symbol: 'MNT', isEvm: true },
    { id: 'kava', name: 'Kava', symbol: 'KAVA', isEvm: true },
    { id: 'evmos', name: 'Evmos', symbol: 'EVMOS', isEvm: true },
  ])
  
  const isDemoMode = sessionStorage.getItem('dwp_demo_mode') === 'true'
  const [demoBalance, setDemoBalance] = useState(parseFloat(sessionStorage.getItem('dwp_demo_balance') || '10000'))
  const [demoPositions, setDemoPositions] = useState(() => {
    try {
      return JSON.parse(sessionStorage.getItem('dwp_demo_positions') || '[]')
    } catch { return [] }
  })
  const [demoSessionId] = useState(() => {
    const stored = sessionStorage.getItem('dwp_demo_session_id')
    if (stored) return stored
    const newId = `demo_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
    sessionStorage.setItem('dwp_demo_session_id', newId)
    return newId
  })
  const [showTradeHistory, setShowTradeHistory] = useState(false)
  const [isDiscovering, setIsDiscovering] = useState(false)
  const [livePrices, setLivePrices] = useState({})
  const [activeSubTab, setActiveSubTab] = useState('discovery')
  const [historyRefreshKey, setHistoryRefreshKey] = useState(0)
  const [showLeadCapture, setShowLeadCapture] = useState(false)
  const [leadCaptured, setLeadCaptured] = useState(() => {
    return sessionStorage.getItem('dwp_lead_captured') === 'true'
  })
  const [showPricing, setShowPricing] = useState(false)
  const [checkoutLoading, setCheckoutLoading] = useState(false)
  const [selectedGlossaryTerm, setSelectedGlossaryTerm] = useState(null)
  const [selectedPreset, setSelectedPreset] = useState(() => {
    return localStorage.getItem('strikeagent_preset') || 'pathfinder'
  })
  
  const handlePresetSelect = useCallback((presetId) => {
    setSelectedPreset(presetId)
    localStorage.setItem('strikeagent_preset', presetId)
    const presetConfig = getPresetConfig(presetId)
    if (presetConfig) {
      setConfig(prev => ({
        ...prev,
        safetyFilters: { ...prev.safetyFilters, ...presetConfig.safetyFilters },
        discoveryFilters: { ...prev.discoveryFilters, ...presetConfig.discoveryFilters },
        tradeControls: { ...prev.tradeControls, ...presetConfig.tradeControls },
        autoModeSettings: { ...prev.autoModeSettings, ...presetConfig.autoModeSettings },
      }))
    }
  }, [])
  
  const wallet = isDemoMode
    ? {
        connected: true,
        address: 'DEMO_WALLET_' + demoSessionId.slice(0, 8),
        shortAddress: 'DEMO...' + demoSessionId.slice(-4),
        balance: (demoBalance / (solPrice || 1)).toFixed(4),
        isDemoWallet: true
      }
    : walletSource === 'external' 
      ? { 
          connected: externalWallet.connected, 
          address: externalWallet.address,
          shortAddress: externalWallet.shortAddress,
          balance: externalWallet.balance 
        }
      : { 
          connected: builtInWallet.isUnlocked, 
          address: builtInWallet.solanaAddress,
          shortAddress: builtInWallet.solanaAddress?.slice(0, 4) + '...' + builtInWallet.solanaAddress?.slice(-4),
          balance: builtInWallet.solanaBalance?.toFixed(4)
        }

  useEffect(() => {
    fetchSolPrice()
    fetchRPCStatus()
    const interval = setInterval(fetchSolPrice, 30000)
    const rpcInterval = setInterval(fetchRPCStatus, 60000)
    return () => {
      clearInterval(interval)
      clearInterval(rpcInterval)
    }
  }, [])

  useEffect(() => {
    if (isDemoMode && demoPositions.length > 0) {
      fetchLivePrices()
      const priceInterval = setInterval(fetchLivePrices, 10000)
      return () => clearInterval(priceInterval)
    }
  }, [isDemoMode, demoPositions.length])

  useEffect(() => {
    if (isDemoMode) {
      sessionStorage.setItem('dwp_demo_positions', JSON.stringify(demoPositions))
    }
  }, [demoPositions, isDemoMode])

  useEffect(() => {
    if (!wallet.connected && autoModeActive) {
      setAutoModeActive(false)
    }
  }, [wallet.connected])

  useEffect(() => {
    if (autoModeActive && !scanInterval) {
      const interval = setInterval(discoverTokens, 10000)
      setScanInterval(interval)
    } else if (!autoModeActive && scanInterval) {
      clearInterval(scanInterval)
      setScanInterval(null)
    }
    return () => {
      if (scanInterval) clearInterval(scanInterval)
    }
  }, [autoModeActive])

  const fetchSolPrice = async () => {
    try {
      const res = await fetch(`${API_BASE}/api/sniper/sol-price`)
      const data = await res.json()
      if (data.price) setSolPrice(data.price)
    } catch (err) {
      console.error('Error fetching SOL price:', err)
    }
  }

  const fetchRPCStatus = async () => {
    try {
      const res = await fetch(`${API_BASE}/api/sniper/rpc/status`)
      const data = await res.json()
      setRpcStatus(data)
    } catch (err) {
      console.error('Error fetching RPC status:', err)
      setRpcStatus({ status: 'unhealthy', active: 'Unknown', type: 'unknown' })
    }
  }

  const saveCustomRPC = async () => {
    try {
      const res = await fetch(`${API_BASE}/api/sniper/rpc/custom`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ endpoint: customRPC || null })
      })
      const data = await res.json()
      if (data.success) {
        await fetchRPCStatus()
      } else {
        alert(data.error || 'Failed to set custom RPC')
      }
    } catch (err) {
      console.error('Error saving custom RPC:', err)
      alert('Failed to connect to RPC endpoint')
    }
  }

  const discoverTokens = async () => {
    setIsScanning(true)
    try {
      const res = await fetch(`${API_BASE}/api/sniper/discover`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ config })
      })
      const data = await res.json()
      setDiscoveredTokens(data.tokens || [])
    } catch (err) {
      console.error('Discovery error:', err)
    }
    setIsScanning(false)
  }

  const discoverAITokens = async () => {
    setIsDiscovering(true)
    try {
      const res = await fetch(`${API_BASE}/api/demo/discover`)
      const data = await res.json()
      if (data.success) {
        setDiscoveredTokens(data.tokens || [])
        console.log('üîç AI Discovery found', data.tokens?.length, 'tokens')
      }
    } catch (err) {
      console.error('AI Discovery error:', err)
    }
    setIsDiscovering(false)
  }

  const handleSelectPlan = async (planId) => {
    if (planId === 'free_demo') return
    
    setCheckoutLoading(true)
    try {
      const capturedEmail = sessionStorage.getItem('dwp_lead_email')
      const res = await fetch(`${API_BASE}/api/demo/checkout`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          planId,
          email: capturedEmail || undefined,
          sessionId: demoSessionId
        })
      })
      const data = await res.json()
      if (data.success && data.url) {
        window.location.href = data.url
      } else {
        alert(data.error || 'Failed to start checkout')
      }
    } catch (err) {
      console.error('Checkout error:', err)
      alert('Failed to start checkout. Please try again.')
    }
    setCheckoutLoading(false)
  }

  const fetchLivePrices = async () => {
    if (demoPositions.length === 0) return
    try {
      const addresses = demoPositions.map(p => p.tokenAddress)
      const res = await fetch(`${API_BASE}/api/demo/prices`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ addresses })
      })
      const data = await res.json()
      if (data.success && data.prices) {
        setLivePrices(data.prices)
      }
    } catch (err) {
      console.error('Price fetch error:', err)
    }
  }

  const handleSnipe = async (token) => {
    if (!wallet.connected && !isDemoMode) {
      alert('Please connect your wallet first')
      return
    }
    
    if (isDemoMode) {
      const buyAmount = config.tradeControls?.buyAmountSol || 0.5
      const buyAmountUsd = buyAmount * solPrice
      
      if (buyAmountUsd > demoBalance) {
        alert('Insufficient demo balance')
        return
      }
      
      try {
        const res = await fetch(`${API_BASE}/api/demo/buy`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            sessionId: demoSessionId,
            token: {
              address: token.address || token.mint,
              symbol: token.symbol,
              name: token.name,
              priceUsd: token.priceUsd || token.price || 0.001,
              priceSol: (token.priceUsd || token.price || 0.001) / solPrice
            },
            amountUsd: buyAmountUsd
          })
        })
        const data = await res.json()
        if (data.success) {
          setDemoBalance(data.portfolio.balanceSol)
          setDemoPositions(data.portfolio.positions)
          setStats(prev => ({
            ...prev,
            tradesExecuted: data.portfolio.stats.totalTrades,
            totalPnl: data.portfolio.stats.totalPnlSol
          }))
          sessionStorage.setItem('dwp_demo_balance', data.portfolio.balanceSol.toString())
          setHistoryRefreshKey(prev => prev + 1)
          console.log('üìä Demo buy executed:', token.symbol, buyAmountUsd)
          showToast('success', 'Trade Executed', `Bought ${token.symbol} for $${buyAmountUsd.toFixed(2)}`)
        } else {
          alert(data.error || 'Demo trade failed')
          showToast('error', 'Trade Failed', data.error || 'Demo trade failed')
        }
      } catch (err) {
        console.error('Demo buy error:', err)
        alert('Failed to execute demo trade')
        showToast('error', 'Trade Error', 'Failed to execute demo trade')
      }
      return
    }
    
    console.log('StrikeAgent executing on token:', token, 'from wallet:', wallet.address)
  }
  
  const handleDemoSell = async (position, currentPrice) => {
    if (!isDemoMode) return
    
    const sellPrice = currentPrice || livePrices[position.tokenAddress] || position.currentPriceUsd || position.entryPriceUsd * 1.05
    
    try {
      const res = await fetch(`${API_BASE}/api/demo/sell`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          sessionId: demoSessionId,
          positionId: position.id,
          currentPriceUsd: sellPrice
        })
      })
      const data = await res.json()
      if (data.success) {
        setDemoBalance(data.portfolio.balanceSol)
        setDemoPositions(data.portfolio.positions)
        setStats(prev => ({
          ...prev,
          tradesExecuted: data.portfolio.stats.totalTrades,
          winRate: data.portfolio.stats.winRate,
          totalPnl: data.portfolio.stats.totalPnlSol
        }))
        sessionStorage.setItem('dwp_demo_balance', data.portfolio.balanceSol.toString())
        sessionStorage.setItem('dwp_demo_positions', JSON.stringify(data.portfolio.positions))
        setHistoryRefreshKey(prev => prev + 1)
        console.log('üìä Demo sell executed, P&L:', data.pnl)
        const pnlValue = parseFloat(data.pnl) || 0
        if (pnlValue >= 0) {
          showToast('success', 'Take Profit Hit', `Sold ${position.symbol || 'token'} for +$${pnlValue.toFixed(2)} profit`)
        } else {
          showToast('warning', 'Stop Loss Triggered', `Sold ${position.symbol || 'token'} for -$${Math.abs(pnlValue).toFixed(2)} loss`)
        }
      }
    } catch (err) {
      console.error('Demo sell error:', err)
      showToast('error', 'Sell Error', 'Failed to execute sell order')
    }
  }

  const handleWatch = async (token) => {
    console.log('Watching token:', token)
  }

  const updateConfig = (section, field, value) => {
    setConfig(prev => ({
      ...prev,
      [section]: {
        ...prev[section],
        [field]: value
      }
    }))
  }

  return (
    <div className={`sniper-tab sniper-bot-tab ${isViewOnly ? 'view-only' : ''}`}>
      {toasts.length > 0 && (
        <div className="toast-container">
          {toasts.map(toast => (
            <div 
              key={toast.id} 
              className={`toast toast-${toast.type} ${toast.exiting ? 'toast-exiting' : ''}`}
              style={{ position: 'relative' }}
            >
              <div className="toast-icon">
                {toast.type === 'success' && '‚úì'}
                {toast.type === 'error' && '‚úï'}
                {toast.type === 'warning' && '‚ö†'}
                {toast.type === 'info' && '‚Ñπ'}
              </div>
              <div className="toast-content">
                <p className="toast-title">{toast.title}</p>
                <p className="toast-message">{toast.message}</p>
              </div>
              <button className="toast-close" onClick={() => dismissToast(toast.id)}>√ó</button>
              <div className="toast-progress">
                <div className="toast-progress-bar" />
              </div>
            </div>
          ))}
        </div>
      )}
      {selectedGlossaryTerm && (
        <GlossaryModal 
          term={selectedGlossaryTerm} 
          onClose={() => setSelectedGlossaryTerm(null)} 
        />
      )}
      <div className="sniper-header section-box">
        <div className="sniper-header-left">
          <h1 className="sniper-title">STRIKEAGENT</h1>
          <p className="sniper-subtitle">AI-Powered Predictive Trading</p>
        </div>
        <div className="sniper-header-right">
          <div className="sniper-sol-price">
            <span className="sniper-sol-label">SOL</span>
            <span className="sniper-sol-value">${solPrice.toFixed(2)}</span>
          </div>
          {wallet.connected && (
            <div className="sniper-wallet-balance">
              <span className="sniper-wallet-label">Balance</span>
              <span className="sniper-wallet-value">
                {wallet.balanceLoading ? '...' : `${parseFloat(wallet.balance || 0).toFixed(4)} SOL`}
              </span>
            </div>
          )}
          <div className="sniper-mode-toggle">
            <button
              className={`sniper-mode-btn ${mode === 'simple' ? 'active' : ''}`}
              onClick={() => setMode('simple')}
            >
              Simple
            </button>
            <button
              className={`sniper-mode-btn ${mode === 'advanced' ? 'active' : ''}`}
              onClick={() => setMode('advanced')}
            >
              Advanced
            </button>
          </div>
        </div>
      </div>

      <QuickActionBar
        mode={quickMode}
        setMode={setQuickMode}
        amount={quickAmount}
        setAmount={setQuickAmount}
        onGo={() => {
          const currentSettings = modeSettings[quickMode] || {}
          const tradeAmount = parseFloat(quickAmount) || currentSettings.buyAmount || 0.1
          
          setConfig(prev => {
            const updated = { ...prev }
            
            if (currentSettings.slippage !== undefined) {
              updated.tradeControls = { ...updated.tradeControls, slippagePercent: currentSettings.slippage }
            }
            if (currentSettings.takeProfit !== undefined) {
              updated.tradeControls = { ...updated.tradeControls, takeProfitPercent: currentSettings.takeProfit }
            }
            if (currentSettings.stopLoss !== undefined) {
              updated.tradeControls = { ...updated.tradeControls, stopLossPercent: currentSettings.stopLoss }
            }
            updated.tradeControls = { ...updated.tradeControls, buyAmountSol: tradeAmount }
            
            if (currentSettings.maxTrades !== undefined) {
              updated.autoModeSettings = { ...updated.autoModeSettings, maxTradesPerSession: currentSettings.maxTrades }
            }
            if (currentSettings.maxSol !== undefined) {
              updated.autoModeSettings = { ...updated.autoModeSettings, maxSolPerSession: currentSettings.maxSol }
            }
            if (currentSettings.cooldown !== undefined) {
              updated.autoModeSettings = { ...updated.autoModeSettings, cooldownSeconds: currentSettings.cooldown }
            }
            if (currentSettings.maxLosses !== undefined) {
              updated.autoModeSettings = { ...updated.autoModeSettings, maxConsecutiveLosses: currentSettings.maxLosses }
            }
            if (currentSettings.autoCompound !== undefined) {
              updated.autoModeSettings = { ...updated.autoModeSettings, autoCompound: currentSettings.autoCompound }
            }
            
            if (currentSettings.minSafetyScore !== undefined) {
              updated.safetyFilters = { ...updated.safetyFilters, minSafetyScore: currentSettings.minSafetyScore }
            }
            
            if (currentSettings.riskLevel) {
              const riskMultipliers = { Conservative: 0.5, Moderate: 1, Aggressive: 2 }
              updated.riskMultiplier = riskMultipliers[currentSettings.riskLevel] || 1
            }
            
            if (currentSettings.approvalTimeout !== undefined) {
              updated.approvalTimeout = currentSettings.approvalTimeout
            }
            
            if (currentSettings.autoDetect !== undefined) {
              updated.autoDetect = currentSettings.autoDetect
            }
            
            return updated
          })
          
          if (quickMode === 'full-auto') {
            setAutoModeActive(true)
            console.log('[StrikeAgent] Full Auto started with settings:', currentSettings)
          } else if (quickMode === 'semi-auto') {
            console.log('[StrikeAgent] Semi-Auto started with settings:', currentSettings)
            if (currentSettings.autoDetect === false) {
              alert('Semi-Auto with Auto-Detect OFF requires you to select tokens from the discovery list. Tap the ‚öôÔ∏è to enable Auto-Detect, or use Manual mode to enter a specific token address.')
            } else {
              discoverTokens()
            }
          } else {
            if (currentSettings.tokenAddress && currentSettings.tokenAddress.trim()) {
              setSafetyCheckToken(currentSettings.tokenAddress.trim())
              console.log('[StrikeAgent] Manual mode - checking token:', currentSettings.tokenAddress)
            } else {
              alert('Manual mode requires a token address. Tap ‚öôÔ∏è to enter a token contract address, or switch to Semi-Auto/Full Auto mode.')
            }
          }
        }}
        disabled={!wallet.connected && !isDemoMode}
        modeSettings={modeSettings}
        onModeSettingsSave={handleModeSettingsSave}
      />

      <ActiveTradesPanel
        positions={isDemoMode ? demoPositions : activePositions}
        expanded={activeTradesPanelExpanded}
        onToggle={() => setActiveTradesPanelExpanded(!activeTradesPanelExpanded)}
        onStopAll={async () => {
          try {
            const res = await fetch(`${API_BASE}/api/sniper/pause`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' }
            })
            const data = await res.json()
            if (data.success) {
              setAutoModeActive(false)
              console.log('[StrikeAgent] All trades stopped via kill switch')
              showToast('warning', 'Session Paused', 'All trades have been stopped. StrikeAgent is now paused.')
            }
          } catch (err) {
            console.error('Failed to stop all trades:', err)
            showToast('error', 'Stop Failed', 'Failed to stop all trades. Please try again.')
          }
        }}
        livePrices={livePrices}
        modeSettings={modeSettings}
        selectedChain={selectedChain}
      />

      <div className="sniper-chain-selector section-box">
        <div className="sniper-chain-header">
          <span className="sniper-chain-label">Target Chain</span>
          <div className="sniper-chain-buttons">
            {availableChains.map(chain => (
              <button
                key={chain.id}
                className={`sniper-chain-btn ${selectedChain === chain.id ? 'active' : ''} ${chain.isEvm ? 'evm' : 'solana'}`}
                onClick={() => setSelectedChain(chain.id)}
                title={`${chain.name} (${chain.symbol})`}
              >
                <span className="chain-icon">{chain.isEvm ? '‚¨°' : '‚óé'}</span>
                <span className="chain-name">{chain.name}</span>
              </button>
            ))}
          </div>
        </div>
        {selectedChain !== 'solana' && (
          <div className="sniper-chain-notice">
            <span className="notice-icon">üîÆ</span>
            <span className="notice-text">
              {availableChains.find(c => c.id === selectedChain)?.name} support coming soon. 
              Safety analysis available, trading in development.
            </span>
          </div>
        )}
      </div>

      <TopSignalsWidget onAnalyze={(signal) => {
        console.log('Analyzing signal:', signal)
        if (signal.tokenAddress || signal.address) {
          setSafetyCheckToken(signal.tokenAddress || signal.address)
        }
      }} />

      <div className="sniper-wallet-source section-box">
        <div className="sniper-wallet-source-header">
          <span className="sniper-wallet-source-label">Wallet Source</span>
          <div className="sniper-wallet-source-toggle">
            <button
              className={`sniper-wallet-src-btn ${walletSource === 'external' ? 'active' : ''}`}
              onClick={() => setWalletSource('external')}
            >
              External (Phantom)
            </button>
            <button
              className={`sniper-wallet-src-btn ${walletSource === 'builtin' ? 'active' : ''}`}
              onClick={() => setWalletSource('builtin')}
            >
              Built-in Wallet
            </button>
          </div>
        </div>
        {walletSource === 'builtin' && builtInWallet.hasWallet && !builtInWallet.isUnlocked && (
          <BuiltInWalletUnlock onUnlock={builtInWallet.unlock} loading={builtInWallet.loading} />
        )}
        {walletSource === 'builtin' && !builtInWallet.hasWallet && (
          <div className="sniper-wallet-unlock">
            <p>No built-in wallet found. Go to Wallet tab to create one.</p>
          </div>
        )}
      </div>

      {isDemoMode && (
        <div className="sniper-demo-banner section-box" style={{
          background: 'linear-gradient(135deg, rgba(0, 212, 255, 0.15) 0%, rgba(138, 43, 226, 0.15) 100%)',
          border: '1px solid rgba(0, 212, 255, 0.4)',
          padding: '12px 16px',
          borderRadius: '8px',
          marginBottom: '16px'
        }}>
          <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', marginBottom: '12px' }}>
            <div style={{ display: 'flex', alignItems: 'center', gap: '12px' }}>
              <span style={{ fontSize: '20px' }}>üéÆ</span>
              <div>
                <strong style={{ color: '#00D4FF' }}>Demo Mode Active</strong>
                <p style={{ fontSize: '12px', color: '#888', margin: 0 }}>
                  Paper trading with ${demoBalance.toLocaleString()} virtual balance
                </p>
              </div>
            </div>
            <div style={{ textAlign: 'right' }}>
              <div style={{ fontSize: '18px', fontWeight: 'bold', color: '#00D4FF' }}>
                ${demoBalance.toLocaleString()}
              </div>
              <div style={{ fontSize: '10px', color: '#666' }}>Demo Balance</div>
            </div>
          </div>
          <a 
            href="https://darkwavepulse.com/app?tab=pricing"
            style={{
              display: 'block',
              width: '100%',
              padding: '10px 20px',
              background: 'linear-gradient(135deg, #00D4FF 0%, #8B5CF6 100%)',
              border: 'none',
              borderRadius: '8px',
              color: '#000',
              fontWeight: 700,
              fontSize: '14px',
              textAlign: 'center',
              textDecoration: 'none',
              cursor: 'pointer'
            }}
          >
            Subscribe to Trade with Real Money - $30/mo
          </a>
        </div>
      )}

      {!wallet.connected && !isDemoMode && (
        <div className="sniper-wallet-warning section-box">
          <div className="sniper-warning-icon">‚ö†Ô∏è</div>
          <div className="sniper-warning-text">
            <strong>Wallet Required</strong>
            <p>{walletSource === 'external' 
              ? 'Connect your Solana wallet (Phantom or Solflare) to start sniping tokens'
              : 'Unlock your built-in wallet to start sniping tokens'}</p>
          </div>
        </div>
      )}

      <BentoGrid columns={3} gap="md">
        <BentoItem span={2}>
          <div className="section-box activity-column">
            <div className="column-header">
              <span className="column-icon">üìä</span>
              <span className="column-title">Activity</span>
            </div>
            <SessionStatsCard stats={stats} isActive={autoModeActive} />
          </div>
        </BentoItem>

        <BentoItem span={1}>
          <div className="section-box guidance-column">
            <div className="column-header">
              <span className="column-icon">ü§ñ</span>
              <span className="column-title">AI Guidance</span>
            </div>
            <AIInsightsCard stats={stats} isActive={autoModeActive} />
          </div>
        </BentoItem>

        <BentoItem span={3}>
          <AdvancedSettingsSection expanded={showAdvanced} onToggle={() => setShowAdvanced(!showAdvanced)}>
            <div style={{ position: 'relative' }}>
              <PresetSelector
                selectedPreset={selectedPreset}
                onSelectPreset={handlePresetSelect}
                disabled={!hasControlAccess}
              />
              {!hasControlAccess && (
                <div style={{
                  position: 'absolute',
                  top: 0,
                  left: 0,
                  right: 0,
                  bottom: 0,
                  background: 'rgba(0, 0, 0, 0.4)',
                  borderRadius: 12,
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'center',
                  backdropFilter: 'blur(2px)',
                  zIndex: 10,
                }}>
                  <span style={{ 
                    fontSize: 12, 
                    color: '#888', 
                    display: 'flex', 
                    alignItems: 'center', 
                    gap: 6,
                    padding: '8px 16px',
                    background: 'rgba(0, 0, 0, 0.6)',
                    borderRadius: 20,
                  }}>
                    üîí Subscribe to customize
                  </span>
                </div>
              )}
            </div>

            <div style={{ position: 'relative', marginTop: 12 }}>
              <SmartAutoModePanel 
                isActive={autoModeActive} 
                onToggle={() => {
                  if (!hasControlAccess) {
                    return
                  }
                  if (!wallet.connected) {
                    alert('Please connect your wallet first')
                    return
                  }
                  setAutoModeActive(!autoModeActive)
                }}
                config={config}
                disabled={!hasControlAccess || !wallet.connected}
              />
              {!hasControlAccess && (
                <div style={{
                  position: 'absolute',
                  top: 0,
                  left: 0,
                  right: 0,
                  bottom: 0,
                  background: 'rgba(0, 0, 0, 0.4)',
                  borderRadius: 12,
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'center',
                  backdropFilter: 'blur(2px)',
                }}>
                  <span style={{ 
                    fontSize: 12, 
                    color: '#888', 
                    display: 'flex', 
                    alignItems: 'center', 
                    gap: 6,
                    padding: '8px 16px',
                    background: 'rgba(0, 0, 0, 0.6)',
                    borderRadius: 20,
                  }}>
                    üîí Subscribe to unlock
                  </span>
                </div>
              )}
            </div>
          </AdvancedSettingsSection>
        </BentoItem>

        {isDemoMode && (
          <BentoItem span={3} className="sniper-demo-tabs-section">
            <div className="section-box demo-section-tabs">
              <div className="demo-tabs-header">
                <button 
                  className={`demo-tab-btn ${activeSubTab === 'discovery' ? 'active' : ''}`}
                  onClick={() => setActiveSubTab('discovery')}
                >
                  üîç Discover
                </button>
                <button 
                  className={`demo-tab-btn ${activeSubTab === 'positions' ? 'active' : ''}`}
                  onClick={() => setActiveSubTab('positions')}
                >
                  üìä Positions ({demoPositions.length})
                </button>
                <button 
                  className={`demo-tab-btn ${activeSubTab === 'history' ? 'active' : ''}`}
                  onClick={() => setActiveSubTab('history')}
                >
                  üìú History
                </button>
              </div>
            </div>
          </BentoItem>
        )}

        {(!isDemoMode || activeSubTab === 'positions') && (
          <BentoItem span={3} className="sniper-positions-section">
            <div className="section-box">
              <div className="sniper-section-header">
                <h3 className="sniper-section-title">
                  {isDemoMode ? 'My Positions' : 'Active Positions'} ({isDemoMode ? demoPositions.length : activePositions.length})
                </h3>
                {isDemoMode && demoPositions.length > 0 && (
                  <span className="positions-live-indicator">‚óè Live</span>
                )}
              </div>
              <div className="sniper-positions-content">
                {isDemoMode ? (
                  demoPositions.length > 0 ? (
                    <div className="demo-positions-grid">
                      {demoPositions.map(pos => (
                        <DemoPositionCard 
                          key={pos.id} 
                          position={pos} 
                          onSell={handleDemoSell}
                          currentPrice={livePrices[pos.tokenAddress] || pos.currentPriceUsd}
                        />
                      ))}
                    </div>
                  ) : (
                    <div className="sniper-empty-state">
                      <div className="sniper-empty-icon">üíº</div>
                      <div className="sniper-empty-text">No open positions</div>
                      <div className="sniper-empty-hint">Discover tokens and buy to start trading</div>
                    </div>
                  )
                ) : (
                  activePositions.length > 0 ? (
                    activePositions.map(pos => (
                      <ActivePositionCard 
                        key={pos.id} 
                        position={pos} 
                        onClose={(id, reason) => console.log('Close position', id, reason)}
                      />
                    ))
                  ) : (
                    <div className="sniper-empty-state">
                      <div className="sniper-empty-icon">üéØ</div>
                      <div className="sniper-empty-text">No active positions</div>
                      <div className="sniper-empty-hint">Strike a token to see live tracking here</div>
                    </div>
                  )
                )}
              </div>
            </div>
          </BentoItem>
        )}

        {isDemoMode && activeSubTab === 'history' && (
          <BentoItem span={3} className="sniper-history-section">
            <div className="section-box">
              <DemoTradeHistory sessionId={demoSessionId} refreshKey={historyRefreshKey} />
            </div>
          </BentoItem>
        )}

        {isDemoMode && !leadCaptured && (
          <BentoItem span={2} className="sniper-lead-capture-section">
            <DemoLeadCapture 
              onSuccess={() => setLeadCaptured(true)}
            />
          </BentoItem>
        )}

        {isDemoMode && !showPricing && (
          <BentoItem span={1} className="sniper-upgrade-section">
            <DemoUpgradeCTA onUpgrade={() => setShowPricing(true)} />
          </BentoItem>
        )}

        {isDemoMode && showPricing && (
          <BentoItem span={3} className="sniper-pricing-section">
            <div className="section-box pricing-modal">
              <button 
                className="pricing-close-btn" 
                onClick={() => setShowPricing(false)}
              >
                &times;
              </button>
              <StrikeAgentPricing 
                onSelectPlan={handleSelectPlan} 
                isDemo={true}
              />
              {checkoutLoading && (
                <div className="checkout-loading">
                  <div className="checkout-spinner"></div>
                  <p>Preparing secure checkout...</p>
                </div>
              )}
            </div>
          </BentoItem>
        )}

        {!isDemoMode && (
          <BentoItem span={3} className="sniper-watchlist-section">
            <ManualWatchlist />
          </BentoItem>
        )}

        {(!isDemoMode || activeSubTab === 'discovery') && (
          <BentoItem span={3} className="sniper-discovery-section">
            <div className="section-box">
              <div className="sniper-section-header">
                <h3 className="sniper-section-title">
                  {isDemoMode ? 'ü§ñ AI Token Discovery' : 'Token Discovery'}
                </h3>
                <div className="discovery-btn-group">
                  {isDemoMode && (
                    <button 
                      className={`sniper-discover-btn ${isDiscovering ? 'discovering' : ''}`}
                      onClick={discoverAITokens}
                      disabled={isDiscovering}
                    >
                      {isDiscovering ? '‚è≥ Discovering...' : '‚ú® Discover Tokens'}
                    </button>
                  )}
                  {!isDemoMode && (
                    <button 
                      className={`sniper-scan-btn ${isScanning ? 'scanning' : ''}`}
                      onClick={discoverTokens}
                      disabled={isScanning}
                    >
                      {isScanning ? 'Scanning...' : 'Scan Now'}
                    </button>
                  )}
                </div>
              </div>
              <div className="sniper-discovery-content">
                {discoveredTokens.length > 0 ? (
                  <div className="sniper-token-list">
                    {discoveredTokens.map((token, i) => (
                      <DiscoveredTokenCard 
                        key={token.address || i}
                        token={token}
                        onSnipe={hasControlAccess ? handleSnipe : () => {}}
                        onWatch={hasControlAccess ? handleWatch : () => {}}
                        onSafetyCheck={(t) => setSafetyCheckToken(t.address)}
                        disabled={!hasControlAccess || !wallet.connected}
                        isDemoMode={isDemoMode}
                        onTermClick={setSelectedGlossaryTerm}
                        isLocked={!hasControlAccess}
                      />
                    ))}
                  </div>
                ) : (
                  <div className="sniper-empty-state">
                    <div className="sniper-empty-icon">üîç</div>
                    <div className="sniper-empty-text">No tokens discovered</div>
                    <div className="sniper-empty-hint">
                      {isDemoMode ? 'Click "Discover Tokens" to find trending coins' : 'Click "Scan Now" or enable Auto Mode'}
                    </div>
                  </div>
                )}
              </div>
            </div>
          </BentoItem>
        )}

        {safetyCheckToken && (
          <BentoItem span={3} className="sniper-safety-section">
            <SafetyReport 
              tokenAddress={safetyCheckToken}
              onClose={() => setSafetyCheckToken(null)}
            />
          </BentoItem>
        )}

        {mode === 'advanced' && (
          <>
            <BentoItem span={3}>
              <QuickSettingsPanel 
                config={config}
                updateConfig={updateConfig}
                expanded={expandedSettings}
                onToggle={() => setExpandedSettings(!expandedSettings)}
              />
            </BentoItem>
            <BentoItem span={3}>
              <SafetyFiltersPanel 
                config={config}
                updateConfig={updateConfig}
                expanded={expandedSafety}
                onToggle={() => setExpandedSafety(!expandedSafety)}
              />
            </BentoItem>
            <BentoItem span={3}>
              <RPCSettingsPanel 
                rpcStatus={rpcStatus}
                customRPC={customRPC}
                setCustomRPC={setCustomRPC}
                onSaveCustomRPC={saveCustomRPC}
                expanded={expandedRPC}
                onToggle={() => setExpandedRPC(!expandedRPC)}
              />
            </BentoItem>
          </>
        )}

        <BentoItem span={3} className="quant-system-section">
          <QuantSystemSection />
        </BentoItem>
      </BentoGrid>

      {isViewOnly && (
        <div 
          style={{
            position: 'fixed',
            bottom: 0,
            left: 0,
            right: 0,
            background: 'linear-gradient(to top, rgba(0,0,0,0.95) 0%, rgba(0,0,0,0.9) 70%, transparent 100%)',
            padding: '24px 16px 32px',
            zIndex: 1000,
            textAlign: 'center',
          }}
        >
          <div style={{ 
            background: 'rgba(0, 212, 255, 0.1)', 
            border: '1px solid rgba(0, 212, 255, 0.3)',
            borderRadius: '12px',
            padding: '16px 20px',
            maxWidth: '500px',
            margin: '0 auto',
          }}>
            <div style={{ fontSize: '11px', color: '#00D4FF', fontWeight: 600, marginBottom: '8px', letterSpacing: '1px' }}>
              üîí SUBSCRIPTION REQUIRED
            </div>
            <div style={{ fontSize: '14px', color: '#fff', marginBottom: '12px' }}>
              Subscribe to unlock StrikeAgent trading features
            </div>
            <button
              className="view-only-cta"
              onClick={() => onNavigate?.('pricing')}
              style={{
                padding: '12px 32px',
                background: 'linear-gradient(135deg, #00D4FF 0%, #00a8cc 100%)',
                color: '#000',
                border: 'none',
                borderRadius: '8px',
                cursor: 'pointer',
                fontWeight: 700,
                fontSize: '14px',
              }}
            >
              View Plans - Starting at $30/mo
            </button>
          </div>
        </div>
      )}

      {isViewOnly && (
        <style>{`
          .sniper-bot-tab.view-only button:not(.view-only-cta),
          .sniper-bot-tab.view-only input,
          .sniper-bot-tab.view-only select,
          .sniper-bot-tab.view-only .sniper-scan-btn,
          .sniper-bot-tab.view-only .sniper-discover-btn,
          .sniper-bot-tab.view-only .auto-mode-toggle,
          .sniper-bot-tab.view-only .mode-tabs button {
            pointer-events: none !important;
            opacity: 0.6 !important;
          }
          .sniper-bot-tab.view-only .section-box {
            position: relative;
          }
        `}</style>
      )}
    </div>
  )
}
