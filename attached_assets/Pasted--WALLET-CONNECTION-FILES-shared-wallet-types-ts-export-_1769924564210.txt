. WALLET CONNECTION FILES
shared/wallet-types.ts
export interface EthereumWallet {
  address: string;
  chainId: number;
  providerName: string;
  connectedAt: string;
}
export interface SolanaWallet {
  publicKey: string;
  cluster: 'mainnet-beta' | 'devnet' | string;
  providerName: string;
  connectedAt: string;
}
export interface TokenBalance {
  tokenAddress: string | null;
  symbol: string;
  decimals: number;
  amountRaw: string;
  amount: string;
}
export interface EthTransaction {
  to?: string;
  from?: string;
  value: string;
  data?: string;
  gasLimit?: string;
  gasPrice?: string;
  nonce?: number;
  signedRaw?: string;
  hash?: string;
  status?: 'pending' | 'confirmed' | 'failed';
}
export interface SolanaTransaction {
  instructions?: any[];
  recentBlockhash?: string;
  signature?: string;
  from?: string;
  to?: string;
  lamports?: string;
  status?: 'pending' | 'confirmed' | 'failed';
}
client/src/hooks/use-wallet.tsx (Main Hook + Context)
import { createContext, useContext, useState, useEffect, useCallback, ReactNode } from "react";
declare global {
  interface Window {
    ethereum?: {
      isMetaMask?: boolean;
      request: (args: { method: string; params?: unknown[] }) => Promise<unknown>;
      on: (event: string, handler: (...args: unknown[]) => void) => void;
      removeListener: (event: string, handler: (...args: unknown[]) => void) => void;
    };
    solana?: {
      isPhantom?: boolean;
      connect: () => Promise<{ publicKey: { toString: () => string } }>;
      disconnect: () => Promise<void>;
      on: (event: string, handler: (...args: unknown[]) => void) => void;
      publicKey?: { toString: () => string };
    };
  }
}
interface WalletState {
  evmAddress: string | null;
  solanaAddress: string | null;
  isConnecting: boolean;
  isConnected: boolean;
  chainId: string | null;
  error: string | null;
}
interface WalletContextType extends WalletState {
  connectEVM: () => Promise<void>;
  connectSolana: () => Promise<void>;
  disconnect: () => void;
  hasMetaMask: boolean;
  hasPhantom: boolean;
}
const WalletContext = createContext<WalletContextType | null>(null);
export function WalletProvider({ children }: { children: ReactNode }) {
  const [state, setState] = useState<WalletState>({
    evmAddress: null,
    solanaAddress: null,
    isConnecting: false,
    isConnected: false,
    chainId: null,
    error: null,
  });
  const [hasMetaMask, setHasMetaMask] = useState(false);
  const [hasPhantom, setHasPhantom] = useState(false);
  useEffect(() => {
    setHasMetaMask(typeof window !== "undefined" && !!window.ethereum);
    setHasPhantom(typeof window !== "undefined" && !!window.solana?.isPhantom);
    const savedEvm = localStorage.getItem("dw_evm_address");
    const savedSolana = localStorage.getItem("dw_solana_address");
    
    if (savedEvm || savedSolana) {
      setState(prev => ({
        ...prev,
        evmAddress: savedEvm,
        solanaAddress: savedSolana,
        isConnected: !!(savedEvm || savedSolana),
      }));
    }
    if (window.ethereum) {
      window.ethereum.on("accountsChanged", handleAccountsChanged);
      window.ethereum.on("chainChanged", handleChainChanged);
    }
    return () => {
      if (window.ethereum) {
        window.ethereum.removeListener("accountsChanged", handleAccountsChanged);
        window.ethereum.removeListener("chainChanged", handleChainChanged);
      }
    };
  }, []);
  const handleAccountsChanged = (accounts: unknown) => {
    const accs = accounts as string[];
    if (accs.length === 0) {
      setState(prev => ({ ...prev, evmAddress: null, isConnected: !!prev.solanaAddress }));
      localStorage.removeItem("dw_evm_address");
    } else {
      setState(prev => ({ ...prev, evmAddress: accs[0], isConnected: true }));
      localStorage.setItem("dw_evm_address", accs[0]);
    }
  };
  const handleChainChanged = (chainId: unknown) => {
    setState(prev => ({ ...prev, chainId: chainId as string }));
  };
  const connectEVM = useCallback(async () => {
    if (!window.ethereum) {
      const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
      const currentUrl = window.location.href.replace('https://', '').replace('http://', '');
      
      if (isMobile) {
        const metamaskDeepLink = `metamask://dapp/${currentUrl}`;
        const fallbackUrl = `https://metamask.app.link/dapp/${currentUrl}`;
        
        const timeout = setTimeout(() => {
          window.location.href = fallbackUrl;
        }, 2500);
        
        window.location.href = metamaskDeepLink;
        window.addEventListener('blur', () => clearTimeout(timeout), { once: true });
      } else {
        window.location.href = `https://metamask.app.link/dapp/${currentUrl}`;
      }
      return;
    }
    setState(prev => ({ ...prev, isConnecting: true, error: null }));
    try {
      const accounts = await window.ethereum.request({ method: "eth_requestAccounts" }) as string[];
      const chainId = await window.ethereum.request({ method: "eth_chainId" }) as string;
      
      if (accounts.length > 0) {
        setState(prev => ({
          ...prev,
          evmAddress: accounts[0],
          chainId,
          isConnected: true,
          isConnecting: false,
        }));
        localStorage.setItem("dw_evm_address", accounts[0]);
      }
    } catch (err: any) {
      setState(prev => ({
        ...prev,
        isConnecting: false,
        error: err.message || "Failed to connect wallet",
      }));
    }
  }, []);
  const connectSolana = useCallback(async () => {
    if (!window.solana?.isPhantom) {
      const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
      const currentUrl = window.location.href;
      const ref = encodeURIComponent(window.location.origin);
      const encodedUrl = encodeURIComponent(currentUrl);
      
      if (isMobile) {
        const phantomDeepLink = `phantom://browse/${encodedUrl}?ref=${ref}`;
        const fallbackUrl = `https://phantom.app/ul/browse/${encodedUrl}?ref=${ref}`;
        
        const timeout = setTimeout(() => {
          window.location.href = fallbackUrl;
        }, 2500);
        
        window.location.href = phantomDeepLink;
        window.addEventListener('blur', () => clearTimeout(timeout), { once: true });
      } else {
        window.location.href = `https://phantom.app/ul/browse/${encodedUrl}?ref=${ref}`;
      }
      return;
    }
    setState(prev => ({ ...prev, isConnecting: true, error: null }));
    try {
      const response = await window.solana.connect();
      const address = response.publicKey.toString();
      
      setState(prev => ({
        ...prev,
        solanaAddress: address,
        isConnected: true,
        isConnecting: false,
      }));
      localStorage.setItem("dw_solana_address", address);
    } catch (err: any) {
      setState(prev => ({
        ...prev,
        isConnecting: false,
        error: err.message || "Failed to connect wallet",
      }));
    }
  }, []);
  const disconnect = useCallback(() => {
    if (window.solana) {
      window.solana.disconnect().catch(() => {});
    }
    setState({
      evmAddress: null,
      solanaAddress: null,
      isConnecting: false,
      isConnected: false,
      chainId: null,
      error: null,
    });
    localStorage.removeItem("dw_evm_address");
    localStorage.removeItem("dw_solana_address");
  }, []);
  return (
    <WalletContext.Provider value={{ ...state, connectEVM, connectSolana, disconnect, hasMetaMask, hasPhantom }}>
      {children}
    </WalletContext.Provider>
  );
}
export function useWallet() {
  const context = useContext(WalletContext);
  if (!context) {
    throw new Error("useWallet must be used within a WalletProvider");
  }
  return context;
}
export function shortenAddress(address: string, chars = 4): string {
  return `${address.slice(0, chars + 2)}...${address.slice(-chars)}`;
}
2. CHAIN-SPECIFIC HOOKS
client/src/hooks/use-ethereum-wallet.tsx
import { useCallback, useState } from 'react';
import { useQuery, useQueryClient } from '@tanstack/react-query';
import type { EthereumWallet, TokenBalance, EthTransaction } from '@shared/wallet-types';
export function useEthereumWallet() {
  const [wallet, setWallet] = useState<EthereumWallet | null>(null);
  const queryClient = useQueryClient();
  const connectMetaMask = useCallback(async () => {
    if ((window as any).ethereum) {
      const accounts = await (window as any).ethereum.request({ method: 'eth_requestAccounts' });
      const chainId = await (window as any).ethereum.request({ method: 'eth_chainId' });
      const address = accounts[0];
      const pw: EthereumWallet = {
        address,
        chainId: parseInt(chainId, 16),
        providerName: 'MetaMask',
        connectedAt: new Date().toISOString()
      };
      setWallet(pw);
      queryClient.invalidateQueries({ queryKey: ['eth-balances', address] });
    } else {
      throw new Error('MetaMask not found');
    }
  }, [queryClient]);
  const switchNetwork = useCallback(async (chainId: number) => {
    await (window as any).ethereum.request({
      method: 'wallet_switchEthereumChain',
      params: [{ chainId: '0x' + chainId.toString(16) }]
    });
  }, []);
  const signTransaction = useCallback(async (tx: Omit<EthTransaction, 'signedRaw'>) => {
    if (!wallet) throw new Error('Wallet not connected');
    
    const txParams = {
      from: wallet.address,
      to: tx.to,
      value: tx.value ? '0x' + BigInt(tx.value).toString(16) : '0x0',
      data: tx.data || '0x',
      gas: tx.gasLimit ? '0x' + BigInt(tx.gasLimit).toString(16) : undefined,
    };
    
    const txHash = await (window as any).ethereum.request({
      method: 'eth_sendTransaction',
      params: [txParams],
    });
    
    return { ...tx, signedRaw: txHash, hash: txHash } as EthTransaction;
  }, [wallet]);
  const signMessage = useCallback(async (message: string): Promise<string> => {
    if (!wallet) throw new Error('Wallet not connected');
    return await (window as any).ethereum.request({
      method: 'personal_sign',
      params: [message, wallet.address],
    });
  }, [wallet]);
  return { wallet, connectMetaMask, switchNetwork, signTransaction, signMessage };
}
client/src/hooks/use-solana-wallet.tsx
import { useCallback, useState } from 'react';
import { useQuery, useQueryClient } from '@tanstack/react-query';
import type { SolanaWallet, TokenBalance, SolanaTransaction } from '@shared/wallet-types';
export function useSolanaWallet() {
  const [wallet, setWallet] = useState<SolanaWallet | null>(null);
  const queryClient = useQueryClient();
  const connectPhantom = useCallback(async () => {
    const provider = (window as any).solana;
    if (provider && provider.isPhantom) {
      const resp = await provider.connect();
      const w: SolanaWallet = { 
        publicKey: resp.publicKey.toString(), 
        cluster: 'devnet', 
        providerName: 'Phantom', 
        connectedAt: new Date().toISOString() 
      };
      setWallet(w);
      queryClient.invalidateQueries({ queryKey: ['sol-balances', w.publicKey] });
    } else {
      throw new Error('Phantom not available');
    }
  }, [queryClient]);
  const switchCluster = useCallback(async (cluster: 'mainnet-beta' | 'devnet') => {
    setWallet((prev) => prev ? { ...prev, cluster } : prev);
  }, []);
  const signTransaction = useCallback(async (tx: Partial<SolanaTransaction> & { rawTransaction?: any }) => {
    if (!wallet) throw new Error('Wallet not connected');
    const provider = (window as any).solana;
    
    if (tx.rawTransaction) {
      const signedTx = await provider.signTransaction(tx.rawTransaction);
      return { ...tx, signature: signedTx.signature?.toString() || 'signed', status: 'confirmed' as const };
    }
    return { ...tx, signature: 'pending', status: 'pending' as const };
  }, [wallet]);
  const signMessage = useCallback(async (message: string): Promise<string> => {
    if (!wallet) throw new Error('Wallet not connected');
    const provider = (window as any).solana;
    const encodedMessage = new TextEncoder().encode(message);
    const signedMessage = await provider.signMessage(encodedMessage, 'utf8');
    const bytes = new Uint8Array(signedMessage.signature);
    return btoa(String.fromCharCode(...bytes));
  }, [wallet]);
  return { wallet, connectPhantom, switchCluster, signTransaction, signMessage };
}
3. DEPENDENCIES (package.json)
{
  "dependencies": {
    "@noble/curves": "^2.0.1",
    "@noble/hashes": "^2.0.1",
    "@scure/bip32": "^2.0.1",
    "@scure/bip39": "^2.0.1",
    "@solana/web3.js": "^1.98.4",
    "ethers": "^6.x",
    "bs58": "^5.x",
    "buffer": "^6.x",
    "@tanstack/react-query": "^5.x"
  }
}
4. SERVER-SIDE WALLET SERVICE (Multi-Chain)
server/wallet-service.ts
import { Connection, PublicKey, LAMPORTS_PER_SOL, SystemProgram, Transaction, Keypair } from '@solana/web3.js';
import { ethers } from 'ethers';
import bs58 from 'bs58';
import crypto from 'crypto';
const HELIUS_API_KEY = process.env.HELIUS_API_KEY;
const SOLANA_RPC = HELIUS_API_KEY 
  ? `https://mainnet.helius-rpc.com/?api-key=${HELIUS_API_KEY}`
  : 'https://api.mainnet-beta.solana.com';
const SUPPORTED_CHAINS = {
  solana: { id: 'solana', name: 'Solana', symbol: 'SOL', coinType: 501, rpcUrl: SOLANA_RPC, explorer: 'https://solscan.io' },
  ethereum: { id: 'ethereum', name: 'Ethereum', symbol: 'ETH', coinType: 60, rpcUrl: 'https://eth.llamarpc.com', chainId: 1, explorer: 'https://etherscan.io' },
  base: { id: 'base', name: 'Base', symbol: 'ETH', coinType: 60, rpcUrl: 'https://mainnet.base.org', chainId: 8453, explorer: 'https://basescan.org' },
  polygon: { id: 'polygon', name: 'Polygon', symbol: 'MATIC', coinType: 60, rpcUrl: 'https://polygon-rpc.com', chainId: 137, explorer: 'https://polygonscan.com' },
  arbitrum: { id: 'arbitrum', name: 'Arbitrum', symbol: 'ETH', coinType: 60, rpcUrl: 'https://arb1.arbitrum.io/rpc', chainId: 42161, explorer: 'https://arbiscan.io' },
  bsc: { id: 'bsc', name: 'BNB Chain', symbol: 'BNB', coinType: 60, rpcUrl: 'https://bsc-dataseed.binance.org', chainId: 56, explorer: 'https://bscscan.com' },
  optimism: { id: 'optimism', name: 'Optimism', symbol: 'ETH', coinType: 60, rpcUrl: 'https://mainnet.optimism.io', chainId: 10, explorer: 'https://optimistic.etherscan.io' },
  avalanche: { id: 'avalanche', name: 'Avalanche', symbol: 'AVAX', coinType: 60, rpcUrl: 'https://api.avax.network/ext/bc/C/rpc', chainId: 43114, explorer: 'https://snowtrace.io' },
};
class MultiChainWalletService {
  private solanaConnection: Connection;
  private evmProviders: Map<string, ethers.JsonRpcProvider> = new Map();
  
  constructor() {
    this.solanaConnection = new Connection(SOLANA_RPC, 'confirmed');
    for (const [chain, config] of Object.entries(SUPPORTED_CHAINS)) {
      if (chain !== 'solana' && config.rpcUrl !== 'native') {
        this.evmProviders.set(chain, new ethers.JsonRpcProvider(config.rpcUrl));
      }
    }
  }
  async getBalance(chain: string, address: string) {
    if (chain === 'solana') {
      const lamports = await this.solanaConnection.getBalance(new PublicKey(address));
      return { balance: (lamports / LAMPORTS_PER_SOL).toFixed(6), symbol: 'SOL' };
    }
    
    const provider = this.evmProviders.get(chain);
    if (!provider) return { balance: '0', symbol: 'ETH' };
    
    const balanceWei = await provider.getBalance(address);
    return { balance: parseFloat(ethers.formatEther(balanceWei)).toFixed(6), symbol: SUPPORTED_CHAINS[chain].symbol };
  }
  async sendTransaction(chain: string, mnemonic: string, to: string, amount: string) {
    if (chain === 'solana') {
      const bip39 = require('bip39');
      const { derivePath } = require('ed25519-hd-key');
      const seed = bip39.mnemonicToSeedSync(mnemonic);
      const { key } = derivePath("m/44'/501'/0'/0'", seed.toString('hex'));
      const keypair = Keypair.fromSeed(key);
      
      const tx = new Transaction().add(
        SystemProgram.transfer({ 
          fromPubkey: keypair.publicKey, 
          toPubkey: new PublicKey(to), 
          lamports: Math.floor(parseFloat(amount) * LAMPORTS_PER_SOL) 
        })
      );
      tx.recentBlockhash = (await this.solanaConnection.getLatestBlockhash()).blockhash;
      tx.feePayer = keypair.publicKey;
      const sig = await this.solanaConnection.sendTransaction(tx, [keypair]);
      await this.solanaConnection.confirmTransaction(sig);
      return { success: true, txHash: sig, explorerUrl: `https://solscan.io/tx/${sig}` };
    }
    
    const provider = this.evmProviders.get(chain);
    const evmPath = `m/44'/60'/0'/0/0`;
    const wallet = new ethers.Wallet(ethers.HDNodeWallet.fromPhrase(mnemonic).derivePath(evmPath).privateKey, provider);
    const tx = await wallet.sendTransaction({ to, value: ethers.parseEther(amount) });
    await tx.wait();
    return { success: true, txHash: tx.hash, explorerUrl: `${SUPPORTED_CHAINS[chain].explorer}/tx/${tx.hash}` };
  }
}
export const walletService = new MultiChainWalletService();
5. ENVIRONMENT VARIABLES NEEDED
# Solana RPC (optional, uses public endpoint if not set)
HELIUS_API_KEY=your_helius_api_key
# For Jupiter swaps (Solana DEX)
JUPITER_API_KEY=optional_for_higher_limits
# Pulse API Integration
PULSE_API_KEY=your_pulse_api_key
PULSE_API_BASE_URL=https://darkwavepulse.com
PULSE_WEBHOOK_SECRET=your_webhook_secret
6. TRADE EXECUTION FLOW
The Pulse client (server/pulse-client.ts) handles the trade execution flow:

Get Quote: pulseClient.getQuote(tokenMint, solAmount, 'buy', slippage)
Get/Create Suggestions: AI generates trade suggestions stored on Pulse
Approve: pulseClient.approveSuggestion(id, userId)
Execute: pulseClient.executeSuggestion(id, userId) → Returns { txSignature, success }
Track Position: pulseClient.getPositions(userId)
Trade History: pulseClient.getTradeHistory(userId)
The actual Jupiter/DEX swap execution happens server-side on Pulse. Your frontend just connects wallets and approves trades.

This should give you everything needed to integrate wallet connections into Pulse's StrikeAgent. The flow is:

User connects wallet (MetaMask/Phantom) via frontend hooks
Wallet address sent to Pulse via /api/sniper/wallets
Trade suggestions come from Pulse AI
User approves via chat bot or UI
Pulse executes the swap and returns tx signature

Scroll to latest

Make, test, iterate…

