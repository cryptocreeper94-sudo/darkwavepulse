FILE 1: client/src/components/quick-trade-panel.tsx
import { useState, useCallback } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { 
  Wallet, ChevronDown, ExternalLink, Loader2, Check, AlertTriangle,
  Zap, ArrowRight, X, RefreshCw
} from 'lucide-react';
import { Button } from '@/components/ui/button';
import { useSolanaWallet } from '@/hooks/use-solana-wallet';
import { useEthereumWallet } from '@/hooks/use-ethereum-wallet';
import { dexSwapService, type SwapQuote } from '@/services/dex-swap-service';
interface QuickTradePanelProps {
  tokenAddress: string;
  tokenSymbol: string;
  tokenName?: string;
  recommendation: 'snipe' | 'watch' | 'avoid';
  onClose?: () => void;
}
type Chain = 'solana' | 'ethereum' | 'base' | 'polygon' | 'bsc' | 'arbitrum' | 'optimism' | 'avalanche';
const CHAINS: { id: Chain; name: string; icon: string; color: string; native: string }[] = [
  { id: 'solana', name: 'Solana', icon: 'â—Ž', color: 'from-purple-500 to-cyan-500', native: 'SOL' },
  { id: 'ethereum', name: 'Ethereum', icon: 'Îž', color: 'from-blue-500 to-purple-500', native: 'ETH' },
  { id: 'base', name: 'Base', icon: 'ðŸ”µ', color: 'from-blue-400 to-blue-600', native: 'ETH' },
  { id: 'polygon', name: 'Polygon', icon: 'â¬¡', color: 'from-purple-400 to-purple-600', native: 'MATIC' },
  { id: 'bsc', name: 'BNB Chain', icon: 'ðŸ”¶', color: 'from-yellow-400 to-yellow-600', native: 'BNB' },
  { id: 'arbitrum', name: 'Arbitrum', icon: 'ðŸ”·', color: 'from-blue-500 to-cyan-500', native: 'ETH' },
  { id: 'optimism', name: 'Optimism', icon: 'ðŸ”´', color: 'from-red-400 to-red-600', native: 'ETH' },
  { id: 'avalanche', name: 'Avalanche', icon: 'ðŸ”º', color: 'from-red-500 to-red-600', native: 'AVAX' },
];
const SOLANA_DEXES = [
  { name: 'Jupiter', url: (token: string) => `https://jup.ag/swap/SOL-${token}`, color: 'bg-gradient-to-r from-emerald-500 to-cyan-500', primary: true },
  { name: 'Raydium', url: (token: string) => `https://raydium.io/swap/?inputMint=sol&outputMint=${token}`, color: 'bg-purple-500/80' },
  { name: 'Meteora', url: (token: string) => `https://app.meteora.ag/swap/SOL-${token}`, color: 'bg-cyan-500/80' },
  { name: 'Orca', url: (token: string) => `https://www.orca.so/swap?inputMint=sol&outputMint=${token}`, color: 'bg-blue-500/80' },
];
const EVM_DEXES: Record<string, { name: string; url: (token: string) => string; color: string }[]> = {
  ethereum: [
    { name: '1inch', url: (token: string) => `https://app.1inch.io/#/1/simple/swap/ETH/${token}`, color: 'bg-gradient-to-r from-blue-500 to-purple-500' },
    { name: 'Uniswap', url: (token: string) => `https://app.uniswap.org/swap?outputCurrency=${token}`, color: 'bg-pink-500/80' },
    { name: 'SushiSwap', url: (token: string) => `https://www.sushi.com/swap?chainId=1&token1=${token}`, color: 'bg-purple-500/80' },
  ],
  base: [
    { name: '1inch', url: (token: string) => `https://app.1inch.io/#/8453/simple/swap/ETH/${token}`, color: 'bg-gradient-to-r from-blue-400 to-blue-600' },
    { name: 'Aerodrome', url: (token: string) => `https://aerodrome.finance/swap?to=${token}`, color: 'bg-blue-500/80' },
    { name: 'Uniswap', url: (token: string) => `https://app.uniswap.org/swap?chain=base&outputCurrency=${token}`, color: 'bg-pink-500/80' },
  ],
  polygon: [
    { name: '1inch', url: (token: string) => `https://app.1inch.io/#/137/simple/swap/MATIC/${token}`, color: 'bg-gradient-to-r from-purple-400 to-purple-600' },
    { name: 'QuickSwap', url: (token: string) => `https://quickswap.exchange/#/swap?outputCurrency=${token}`, color: 'bg-blue-500/80' },
  ],
  bsc: [
    { name: '1inch', url: (token: string) => `https://app.1inch.io/#/56/simple/swap/BNB/${token}`, color: 'bg-gradient-to-r from-yellow-400 to-yellow-600' },
    { name: 'PancakeSwap', url: (token: string) => `https://pancakeswap.finance/swap?outputCurrency=${token}`, color: 'bg-yellow-500/80' },
  ],
  arbitrum: [
    { name: '1inch', url: (token: string) => `https://app.1inch.io/#/42161/simple/swap/ETH/${token}`, color: 'bg-gradient-to-r from-blue-500 to-cyan-500' },
    { name: 'Camelot', url: (token: string) => `https://app.camelot.exchange/?token2=${token}`, color: 'bg-amber-500/80' },
  ],
  optimism: [
    { name: '1inch', url: (token: string) => `https://app.1inch.io/#/10/simple/swap/ETH/${token}`, color: 'bg-gradient-to-r from-red-400 to-red-600' },
    { name: 'Velodrome', url: (token: string) => `https://app.velodrome.finance/swap?to=${token}`, color: 'bg-white/20' },
  ],
  avalanche: [
    { name: '1inch', url: (token: string) => `https://app.1inch.io/#/43114/simple/swap/AVAX/${token}`, color: 'bg-gradient-to-r from-red-500 to-red-600' },
    { name: 'TraderJoe', url: (token: string) => `https://traderjoexyz.com/avalanche/trade?outputCurrency=${token}`, color: 'bg-red-500/80' },
  ],
};
const PRESET_AMOUNTS = ['0.1', '0.25', '0.5', '1'];
// Detect if an address is Solana (base58) vs EVM (0x hex)
function isSolanaAddress(address: string): boolean {
  // Solana addresses are base58 encoded, typically 32-44 chars, no 0x prefix
  return !address.startsWith('0x') && /^[1-9A-HJ-NP-Za-km-z]{32,44}$/.test(address);
}
function isEvmAddress(address: string): boolean {
  return address.startsWith('0x') && address.length === 42;
}
export function QuickTradePanel({ tokenAddress, tokenSymbol, tokenName, recommendation, onClose }: QuickTradePanelProps) {
  // Detect token chain type based on address format
  const tokenIsSolana = isSolanaAddress(tokenAddress);
  const tokenIsEvm = isEvmAddress(tokenAddress);
  
  // Only show compatible chains for this token
  const availableChains = tokenIsSolana 
    ? CHAINS.filter(c => c.id === 'solana')
    : tokenIsEvm 
      ? CHAINS.filter(c => c.id !== 'solana')
      : CHAINS; // If unclear, show all
  
  const [selectedChain, setSelectedChain] = useState<Chain>(tokenIsSolana ? 'solana' : 'ethereum');
  const [chainDropdownOpen, setChainDropdownOpen] = useState(false);
  const [amount, setAmount] = useState('0.1');
  const [customAmount, setCustomAmount] = useState('');
  const [isSwapping, setIsSwapping] = useState(false);
  const [quote, setQuote] = useState<SwapQuote | null>(null);
  const [quoteLoading, setQuoteLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [txResult, setTxResult] = useState<{ success: boolean; txHash: string; explorerUrl: string } | null>(null);
  const solanaWallet = useSolanaWallet();
  const ethereumWallet = useEthereumWallet();
  const currentChainInfo = CHAINS.find(c => c.id === selectedChain)!;
  const isSolana = selectedChain === 'solana';
  const wallet = isSolana ? solanaWallet.wallet : ethereumWallet.wallet;
  const isConnected = isSolana ? !!solanaWallet.wallet : !!ethereumWallet.wallet;
  const balance = isSolana 
    ? solanaWallet.balances?.[0]?.amount || '0'
    : ethereumWallet.balances?.[0]?.amount || '0';
  const connectWallet = useCallback(async () => {
    try {
      if (isSolana) {
        await solanaWallet.connectPhantom();
      } else {
        await ethereumWallet.connectMetaMask();
      }
    } catch (err: any) {
      setError(err.message || 'Failed to connect wallet');
    }
  }, [isSolana, solanaWallet, ethereumWallet]);
  const getQuote = useCallback(async () => {
    if (!wallet) return;
    setQuoteLoading(true);
    setError(null);
    try {
      const inputAmount = customAmount || amount;
      // Use native token symbol - the DEX swap service handles conversion
      const nativeToken = currentChainInfo.native; // SOL, ETH, MATIC, BNB, AVAX
      
      const q = await dexSwapService.getQuote({
        chain: selectedChain,
        inputToken: nativeToken,
        outputToken: tokenAddress,
        amount: inputAmount, // Human-readable amount - service handles conversion
        slippage: 1,
        userAddress: isSolana ? solanaWallet.wallet!.publicKey : ethereumWallet.wallet!.address,
      });
      setQuote(q);
    } catch (err: any) {
      setError(err.message || 'Failed to get quote');
    } finally {
      setQuoteLoading(false);
    }
  }, [wallet, amount, customAmount, selectedChain, tokenAddress, isSolana, currentChainInfo.native, solanaWallet.wallet, ethereumWallet.wallet]);
  const executeSwap = useCallback(async () => {
    if (!quote || !wallet) return;
    setIsSwapping(true);
    setError(null);
    try {
      const userAddress = isSolana ? solanaWallet.wallet!.publicKey : ethereumWallet.wallet!.address;
      const swapTx = await dexSwapService.buildSwapTransaction(quote, userAddress);
      
      let signature: string;
      if (isSolana) {
        // Solana: Sign and send via Phantom
        const signedTx = await solanaWallet.signTransaction({ rawTransaction: swapTx.transaction });
        signature = signedTx.signature || '';
      } else {
        // EVM: ethereumWallet.signTransaction sends the tx and returns the hash
        const txData = swapTx.transaction as { to: string; data: string; value: string; gasLimit?: string };
        const signedTx = await ethereumWallet.signTransaction({
          to: txData.to,
          data: txData.data,
          value: txData.value || '0',
          gasLimit: txData.gasLimit,
          // Don't set nonce - MetaMask calculates it automatically
        });
        signature = signedTx.hash || signedTx.signedRaw || '';
      }
      
      const result = await dexSwapService.trackTransaction(selectedChain, signature);
      setTxResult(result);
    } catch (err: any) {
      setError(err.message || 'Swap failed');
    } finally {
      setIsSwapping(false);
    }
  }, [quote, wallet, isSolana, selectedChain, solanaWallet, ethereumWallet]);
  const dexes = isSolana ? SOLANA_DEXES : (EVM_DEXES[selectedChain] || []);
  return (
    <div className="bg-slate-900/95 backdrop-blur-xl border border-white/10 rounded-2xl p-4 space-y-4" data-testid="quick-trade-panel">
      {/* Header */}
      <div className="flex items-center justify-between">
        <div className="flex items-center gap-2">
          <div className={`w-8 h-8 rounded-lg bg-gradient-to-r ${currentChainInfo.color} flex items-center justify-center text-white font-bold`}>
            {currentChainInfo.icon}
          </div>
          <div>
            <h3 className="text-white font-bold">Trade ${tokenSymbol}</h3>
            <p className="text-[10px] text-white/50">{tokenName || tokenAddress.slice(0, 8)}...</p>
          </div>
        </div>
        {onClose && (
          <button onClick={onClose} className="p-2 hover:bg-white/10 rounded-lg" data-testid="button-close-trade">
            <X className="w-4 h-4 text-white/50" />
          </button>
        )}
      </div>
      {/* Chain Selector */}
      <div className="relative">
        {availableChains.length === 1 ? (
          // Single chain available - show info only
          <div className="flex items-center justify-between p-3 bg-white/5 border border-white/10 rounded-xl">
            <div className="flex items-center gap-2">
              <span className="text-lg">{currentChainInfo.icon}</span>
              <span className="text-white font-medium">{currentChainInfo.name}</span>
            </div>
            <span className="text-xs text-white/50">
              {tokenIsSolana ? 'Solana token' : 'EVM token'}
            </span>
          </div>
        ) : (
          <button
            onClick={() => setChainDropdownOpen(!chainDropdownOpen)}
            className="w-full flex items-center justify-between p-3 bg-white/5 border border-white/10 rounded-xl hover:bg-white/10 transition-colors"
            data-testid="button-chain-select"
          >
            <div className="flex items-center gap-2">
              <span className="text-lg">{currentChainInfo.icon}</span>
              <span className="text-white font-medium">{currentChainInfo.name}</span>
            </div>
            <ChevronDown className={`w-4 h-4 text-white/50 transition-transform ${chainDropdownOpen ? 'rotate-180' : ''}`} />
          </button>
        )}
        
        <AnimatePresence>
          {chainDropdownOpen && (
            <motion.div
              initial={{ opacity: 0, y: -10 }}
              animate={{ opacity: 1, y: 0 }}
              exit={{ opacity: 0, y: -10 }}
              className="absolute z-50 w-full mt-2 bg-slate-800 border border-white/10 rounded-xl overflow-hidden shadow-xl"
            >
              {availableChains.map((chain) => (
                <button
                  key={chain.id}
                  onClick={() => { setSelectedChain(chain.id); setChainDropdownOpen(false); setQuote(null); }}
                  className={`w-full flex items-center gap-3 p-3 hover:bg-white/10 transition-colors ${selectedChain === chain.id ? 'bg-white/10' : ''}`}
                  data-testid={`chain-option-${chain.id}`}
                >
                  <span className="text-lg">{chain.icon}</span>
                  <span className="text-white">{chain.name}</span>
                  {selectedChain === chain.id && <Check className="w-4 h-4 text-emerald-400 ml-auto" />}
                </button>
              ))}
            </motion.div>
          )}
        </AnimatePresence>
      </div>
      {/* Wallet Connection */}
      {!isConnected ? (
        <Button
          onClick={connectWallet}
          className={`w-full bg-gradient-to-r ${currentChainInfo.color} text-white font-bold py-3`}
          data-testid="button-connect-wallet"
        >
          <Wallet className="w-4 h-4 mr-2" />
          Connect {isSolana ? 'Phantom' : 'MetaMask'}
        </Button>
      ) : (
        <>
          {/* Balance Display */}
          <div className="bg-white/5 rounded-xl p-3 flex items-center justify-between">
            <div>
              <p className="text-[10px] text-white/50 uppercase">Your Balance</p>
              <p className="text-white font-bold">{parseFloat(balance).toFixed(4)} {currentChainInfo.native}</p>
            </div>
            <div className="text-right">
              <p className="text-[10px] text-white/50">Connected</p>
              <p className="text-xs text-emerald-400 font-mono">
                {(isSolana ? solanaWallet.wallet?.publicKey : ethereumWallet.wallet?.address)?.slice(0, 6)}...
              </p>
            </div>
          </div>
          {/* Amount Selection */}
          <div>
            <p className="text-xs text-white/50 mb-2">Amount ({currentChainInfo.native})</p>
            <div className="grid grid-cols-4 gap-2 mb-2">
              {PRESET_AMOUNTS.map((preset) => (
                <button
                  key={preset}
                  onClick={() => { setAmount(preset); setCustomAmount(''); setQuote(null); }}
                  className={`py-2 rounded-lg text-sm font-medium transition-all ${
                    amount === preset && !customAmount
                      ? `bg-gradient-to-r ${currentChainInfo.color} text-white`
                      : 'bg-white/10 text-white/70 hover:bg-white/20'
                  }`}
                  data-testid={`amount-${preset}`}
                >
                  {preset}
                </button>
              ))}
            </div>
            <input
              type="number"
              placeholder="Custom amount..."
              value={customAmount}
              onChange={(e) => { setCustomAmount(e.target.value); setQuote(null); }}
              className="w-full bg-white/5 border border-white/10 rounded-lg px-3 py-2 text-white text-sm focus:outline-none focus:border-cyan-500/50"
              data-testid="input-custom-amount"
            />
          </div>
          {/* Get Quote Button */}
          <Button
            onClick={getQuote}
            disabled={quoteLoading}
            className="w-full bg-white/10 hover:bg-white/20 text-white"
            data-testid="button-get-quote"
          >
            {quoteLoading ? (
              <><Loader2 className="w-4 h-4 mr-2 animate-spin" /> Getting Quote...</>
            ) : (
              <><RefreshCw className="w-4 h-4 mr-2" /> Get Quote</>
            )}
          </Button>
          {/* Quote Display */}
          {quote && (
            <motion.div
              initial={{ opacity: 0, y: 10 }}
              animate={{ opacity: 1, y: 0 }}
              className="bg-emerald-500/10 border border-emerald-500/30 rounded-xl p-3"
            >
              <div className="flex items-center justify-between mb-2">
                <span className="text-xs text-white/50">You'll receive (est.)</span>
                <span className="text-xs text-emerald-400">{quote.priceImpact}% impact</span>
              </div>
              <div className="flex items-center gap-2">
                <span className="text-xl font-bold text-white">
                  {parseFloat(quote.outputAmount).toLocaleString(undefined, { maximumFractionDigits: 2 })}
                </span>
                <span className="text-white/70">${tokenSymbol}</span>
              </div>
              <p className="text-[10px] text-white/40 mt-1">Min: {parseFloat(quote.outputAmountMin).toLocaleString()} (with slippage)</p>
              
              <Button
                onClick={executeSwap}
                disabled={isSwapping}
                className={`w-full mt-3 bg-gradient-to-r ${
                  recommendation === 'snipe' ? 'from-emerald-500 to-cyan-500' :
                  recommendation === 'watch' ? 'from-amber-500 to-orange-500' :
                  'from-red-500 to-pink-500'
                } text-white font-bold`}
                data-testid="button-execute-swap"
              >
                {isSwapping ? (
                  <><Loader2 className="w-4 h-4 mr-2 animate-spin" /> Swapping...</>
                ) : (
                  <><Zap className="w-4 h-4 mr-2" /> Execute Swap</>
                )}
              </Button>
            </motion.div>
          )}
          {/* Transaction Result */}
          {txResult && (
            <motion.div
              initial={{ opacity: 0, scale: 0.95 }}
              animate={{ opacity: 1, scale: 1 }}
              className={`p-3 rounded-xl ${txResult.success ? 'bg-emerald-500/20 border border-emerald-500/30' : 'bg-red-500/20 border border-red-500/30'}`}
            >
              <div className="flex items-center gap-2">
                {txResult.success ? <Check className="w-5 h-5 text-emerald-400" /> : <AlertTriangle className="w-5 h-5 text-red-400" />}
                <span className={txResult.success ? 'text-emerald-400' : 'text-red-400'}>
                  {txResult.success ? 'Swap Successful!' : 'Swap Failed'}
                </span>
              </div>
              {txResult.txHash && (
                <a
                  href={txResult.explorerUrl}
                  target="_blank"
                  rel="noopener noreferrer"
                  className="text-xs text-cyan-400 hover:underline flex items-center gap-1 mt-2"
                >
                  View on Explorer <ExternalLink className="w-3 h-3" />
                </a>
              )}
            </motion.div>
          )}
        </>
      )}
      {/* Error Display */}
      {error && (
        <div className="bg-red-500/20 border border-red-500/30 rounded-lg p-2 flex items-center gap-2">
          <AlertTriangle className="w-4 h-4 text-red-400 shrink-0" />
          <p className="text-xs text-red-400">{error}</p>
        </div>
      )}
      {/* DEX Links */}
      <div>
        <p className="text-xs text-white/50 mb-2">Or trade on:</p>
        <div className="grid grid-cols-2 gap-2">
          {dexes.map((dex, i) => (
            <a
              key={dex.name}
              href={dex.url(tokenAddress)}
              target="_blank"
              rel="noopener noreferrer"
              className={`flex items-center justify-center gap-2 py-2.5 rounded-xl text-xs font-medium text-white ${dex.color} hover:opacity-90 transition-opacity ${i === 0 ? 'col-span-2' : ''}`}
              onClick={(e) => e.stopPropagation()}
              data-testid={`link-dex-${dex.name.toLowerCase()}`}
            >
              {dex.name}
              <ExternalLink className="w-3 h-3" />
            </a>
          ))}
        </div>
      </div>
    </div>
  );
}
export default QuickTradePanel;
FILE 2: client/src/services/dex-swap-service.ts
/**
 * DEX Swap Service
 * Handles building swap transactions for Jupiter (Solana) and 1inch (EVM chains)
 * Returns unsigned transactions for signing with Phantom/MetaMask
 */
import { Connection, PublicKey, VersionedTransaction, Transaction } from '@solana/web3.js';
// Jupiter API endpoints
const JUPITER_QUOTE_API = 'https://quote-api.jup.ag/v6/quote';
const JUPITER_SWAP_API = 'https://quote-api.jup.ag/v6/swap';
// 1inch API endpoints (v5.2)
const ONEINCH_BASE_URL = 'https://api.1inch.dev/swap/v6.0';
// Chain IDs for EVM
const CHAIN_IDS: Record<string, number> = {
  ethereum: 1,
  base: 8453,
  arbitrum: 42161,
  polygon: 137,
  optimism: 10,
  bsc: 56,
  avalanche: 43114,
};
// Native token addresses
const NATIVE_TOKENS: Record<string, string> = {
  solana: 'So11111111111111111111111111111111111111112', // Wrapped SOL
  ethereum: '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE',
  base: '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE',
  arbitrum: '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE',
  polygon: '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE',
  optimism: '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE',
  bsc: '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE',
  avalanche: '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE',
};
// RPC endpoints
const RPC_ENDPOINTS: Record<string, string> = {
  solana: 'https://api.mainnet-beta.solana.com',
  ethereum: 'https://eth.llamarpc.com',
  base: 'https://mainnet.base.org',
  arbitrum: 'https://arb1.arbitrum.io/rpc',
  polygon: 'https://polygon-rpc.com',
  optimism: 'https://mainnet.optimism.io',
  bsc: 'https://bsc-dataseed.binance.org',
  avalanche: 'https://api.avax.network/ext/bc/C/rpc',
};
export interface SwapQuoteRequest {
  chain: string;
  inputToken: string;
  outputToken: string;
  amount: string;
  slippage: number;
  userAddress: string;
}
export interface SwapQuote {
  chain: string;
  inputToken: string;
  outputToken: string;
  inputAmount: string;
  outputAmount: string;
  outputAmountMin: string;
  priceImpact: string;
  route: string;
  fee: string;
  estimatedGas?: string;
  rawQuote: any;
}
export interface SwapTransaction {
  chain: string;
  transaction: any;
  type: 'solana' | 'evm';
  explorerBaseUrl: string;
}
export interface TransactionResult {
  success: boolean;
  txHash: string;
  explorerUrl: string;
  status: 'pending' | 'confirmed' | 'failed';
  error?: string;
}
class DexSwapService {
  private solanaConnection: Connection;
  private oneInchApiKey: string;
  constructor() {
    this.solanaConnection = new Connection(RPC_ENDPOINTS.solana, 'confirmed');
    this.oneInchApiKey = ''; // Will be set if available
  }
  setOneInchApiKey(apiKey: string) {
    this.oneInchApiKey = apiKey;
  }
  /**
   * Get a swap quote from the appropriate DEX
   */
  async getQuote(request: SwapQuoteRequest): Promise<SwapQuote> {
    const { chain, inputToken, outputToken, amount, slippage, userAddress } = request;
    if (chain === 'solana') {
      return this.getJupiterQuote(inputToken, outputToken, amount, slippage);
    } else {
      return this.get1inchQuote(chain, inputToken, outputToken, amount, slippage, userAddress);
    }
  }
  /**
   * Build a swap transaction ready for signing
   */
  async buildSwapTransaction(quote: SwapQuote, userAddress: string): Promise<SwapTransaction> {
    if (quote.chain === 'solana') {
      return this.buildJupiterSwapTransaction(quote, userAddress);
    } else {
      return this.build1inchSwapTransaction(quote, userAddress);
    }
  }
  /**
   * Track transaction status until confirmation
   */
  async trackTransaction(
    chain: string,
    txHash: string,
    onStatusUpdate?: (status: 'pending' | 'confirmed' | 'failed') => void
  ): Promise<TransactionResult> {
    if (chain === 'solana') {
      return this.trackSolanaTransaction(txHash, onStatusUpdate);
    } else {
      return this.trackEvmTransaction(chain, txHash, onStatusUpdate);
    }
  }
  // ==================== JUPITER (SOLANA) ====================
  private async getJupiterQuote(
    inputMint: string,
    outputMint: string,
    amount: string,
    slippageBps: number
  ): Promise<SwapQuote> {
    // Convert SOL to lamports (or token amount to smallest unit)
    const inputMintAddress = inputMint === 'SOL' ? NATIVE_TOKENS.solana : inputMint;
    const amountInLamports = inputMint === 'SOL' 
      ? Math.floor(parseFloat(amount) * 1e9).toString()
      : amount;
    const params = new URLSearchParams({
      inputMint: inputMintAddress,
      outputMint: outputMint,
      amount: amountInLamports,
      slippageBps: (slippageBps * 100).toString(), // Convert % to bps
      swapMode: 'ExactIn',
    });
    const response = await fetch(`${JUPITER_QUOTE_API}?${params}`);
    
    if (!response.ok) {
      const error = await response.text();
      throw new Error(`Jupiter quote failed: ${error}`);
    }
    const data = await response.json();
    return {
      chain: 'solana',
      inputToken: inputMintAddress,
      outputToken: outputMint,
      inputAmount: data.inAmount,
      outputAmount: data.outAmount,
      outputAmountMin: data.otherAmountThreshold,
      priceImpact: data.priceImpactPct || '0',
      route: data.routePlan?.map((r: any) => r.swapInfo?.label).join(' â†’ ') || 'Jupiter',
      fee: '0.0025', // Jupiter fee
      rawQuote: data,
    };
  }
  private async buildJupiterSwapTransaction(
    quote: SwapQuote,
    userAddress: string
  ): Promise<SwapTransaction> {
    const response = await fetch(JUPITER_SWAP_API, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        quoteResponse: quote.rawQuote,
        userPublicKey: userAddress,
        wrapAndUnwrapSol: true,
        dynamicComputeUnitLimit: true,
        prioritizationFeeLamports: 'auto',
      }),
    });
    if (!response.ok) {
      const error = await response.text();
      throw new Error(`Jupiter swap build failed: ${error}`);
    }
    const { swapTransaction } = await response.json();
    
    // Deserialize the transaction
    const transactionBuf = Buffer.from(swapTransaction, 'base64');
    const transaction = VersionedTransaction.deserialize(transactionBuf);
    return {
      chain: 'solana',
      transaction: transaction,
      type: 'solana',
      explorerBaseUrl: 'https://solscan.io/tx/',
    };
  }
  private async trackSolanaTransaction(
    signature: string,
    onStatusUpdate?: (status: 'pending' | 'confirmed' | 'failed') => void
  ): Promise<TransactionResult> {
    onStatusUpdate?.('pending');
    
    const maxRetries = 30;
    let retries = 0;
    while (retries < maxRetries) {
      try {
        const status = await this.solanaConnection.getSignatureStatus(signature);
        
        if (status.value?.confirmationStatus === 'confirmed' || 
            status.value?.confirmationStatus === 'finalized') {
          if (status.value.err) {
            onStatusUpdate?.('failed');
            return {
              success: false,
              txHash: signature,
              explorerUrl: `https://solscan.io/tx/${signature}`,
              status: 'failed',
              error: JSON.stringify(status.value.err),
            };
          }
          
          onStatusUpdate?.('confirmed');
          return {
            success: true,
            txHash: signature,
            explorerUrl: `https://solscan.io/tx/${signature}`,
            status: 'confirmed',
          };
        }
      } catch (err) {
        console.warn('Solana tx status check error:', err);
      }
      await new Promise(resolve => setTimeout(resolve, 2000));
      retries++;
    }
    return {
      success: false,
      txHash: signature,
      explorerUrl: `https://solscan.io/tx/${signature}`,
      status: 'pending',
      error: 'Transaction confirmation timeout',
    };
  }
  // ==================== 1INCH (EVM CHAINS) ====================
  private async get1inchQuote(
    chain: string,
    inputToken: string,
    outputToken: string,
    amount: string,
    slippage: number,
    userAddress: string
  ): Promise<SwapQuote> {
    const chainId = CHAIN_IDS[chain];
    if (!chainId) throw new Error(`Unsupported chain: ${chain}`);
    // Convert to wei (18 decimals for native tokens)
    const inputTokenAddress = this.isNativeToken(inputToken) 
      ? NATIVE_TOKENS[chain] 
      : inputToken;
    const amountInWei = this.isNativeToken(inputToken)
      ? BigInt(Math.floor(parseFloat(amount) * 1e18)).toString()
      : amount;
    const params = new URLSearchParams({
      src: inputTokenAddress,
      dst: outputToken,
      amount: amountInWei,
      from: userAddress,
      slippage: slippage.toString(),
      disableEstimate: 'true',
    });
    const headers: Record<string, string> = {
      'Accept': 'application/json',
    };
    if (this.oneInchApiKey) {
      headers['Authorization'] = `Bearer ${this.oneInchApiKey}`;
    }
    const response = await fetch(
      `${ONEINCH_BASE_URL}/${chainId}/swap?${params}`,
      { headers }
    );
    if (!response.ok) {
      // Fallback to quote-only endpoint if swap fails
      const quoteParams = new URLSearchParams({
        src: inputTokenAddress,
        dst: outputToken,
        amount: amountInWei,
      });
      const quoteResponse = await fetch(
        `${ONEINCH_BASE_URL}/${chainId}/quote?${quoteParams}`,
        { headers }
      );
      if (!quoteResponse.ok) {
        throw new Error(`1inch quote failed: ${await quoteResponse.text()}`);
      }
      const quoteData = await quoteResponse.json();
      
      return {
        chain,
        inputToken: inputTokenAddress,
        outputToken,
        inputAmount: amountInWei,
        outputAmount: quoteData.dstAmount,
        outputAmountMin: this.calculateMinOutput(quoteData.dstAmount, slippage),
        priceImpact: '0',
        route: '1inch',
        fee: quoteData.gas ? (parseInt(quoteData.gas) * 0.00000001).toFixed(6) : '0',
        estimatedGas: quoteData.gas,
        rawQuote: { ...quoteData, needsSwapBuild: true, userAddress, slippage },
      };
    }
    const data = await response.json();
    return {
      chain,
      inputToken: inputTokenAddress,
      outputToken,
      inputAmount: amountInWei,
      outputAmount: data.dstAmount,
      outputAmountMin: this.calculateMinOutput(data.dstAmount, slippage),
      priceImpact: '0',
      route: data.protocols?.flat()?.map((p: any) => p.name).join(' â†’ ') || '1inch',
      fee: data.tx?.gas ? (parseInt(data.tx.gas) * 0.00000001).toFixed(6) : '0',
      estimatedGas: data.tx?.gas,
      rawQuote: data,
    };
  }
  private async build1inchSwapTransaction(
    quote: SwapQuote,
    userAddress: string
  ): Promise<SwapTransaction> {
    const chainId = CHAIN_IDS[quote.chain];
    const explorerUrls: Record<string, string> = {
      ethereum: 'https://etherscan.io/tx/',
      base: 'https://basescan.org/tx/',
      arbitrum: 'https://arbiscan.io/tx/',
      polygon: 'https://polygonscan.com/tx/',
      optimism: 'https://optimistic.etherscan.io/tx/',
      bsc: 'https://bscscan.com/tx/',
      avalanche: 'https://snowtrace.io/tx/',
    };
    // If we already have the swap data from the quote
    if (quote.rawQuote.tx) {
      return {
        chain: quote.chain,
        transaction: {
          to: quote.rawQuote.tx.to,
          data: quote.rawQuote.tx.data,
          value: quote.rawQuote.tx.value,
          gasLimit: quote.rawQuote.tx.gas,
          from: userAddress,
        },
        type: 'evm',
        explorerBaseUrl: explorerUrls[quote.chain] || 'https://etherscan.io/tx/',
      };
    }
    // Need to fetch swap data
    if (quote.rawQuote.needsSwapBuild) {
      const params = new URLSearchParams({
        src: quote.inputToken,
        dst: quote.outputToken,
        amount: quote.inputAmount,
        from: quote.rawQuote.userAddress,
        slippage: quote.rawQuote.slippage.toString(),
        disableEstimate: 'true',
      });
      const headers: Record<string, string> = { 'Accept': 'application/json' };
      if (this.oneInchApiKey) {
        headers['Authorization'] = `Bearer ${this.oneInchApiKey}`;
      }
      const response = await fetch(
        `${ONEINCH_BASE_URL}/${chainId}/swap?${params}`,
        { headers }
      );
      if (!response.ok) {
        throw new Error(`1inch swap build failed: ${await response.text()}`);
      }
      const data = await response.json();
      return {
        chain: quote.chain,
        transaction: {
          to: data.tx.to,
          data: data.tx.data,
          value: data.tx.value,
          gasLimit: data.tx.gas,
          from: userAddress,
        },
        type: 'evm',
        explorerBaseUrl: explorerUrls[quote.chain] || 'https://etherscan.io/tx/',
      };
    }
    throw new Error('Unable to build swap transaction');
  }
  private async trackEvmTransaction(
    chain: string,
    txHash: string,
    onStatusUpdate?: (status: 'pending' | 'confirmed' | 'failed') => void
  ): Promise<TransactionResult> {
    onStatusUpdate?.('pending');
    const rpcUrl = RPC_ENDPOINTS[chain];
    if (!rpcUrl) throw new Error(`No RPC for chain: ${chain}`);
    const explorerUrls: Record<string, string> = {
      ethereum: 'https://etherscan.io/tx/',
      base: 'https://basescan.org/tx/',
      arbitrum: 'https://arbiscan.io/tx/',
      polygon: 'https://polygonscan.com/tx/',
      optimism: 'https://optimistic.etherscan.io/tx/',
      bsc: 'https://bscscan.com/tx/',
      avalanche: 'https://snowtrace.io/tx/',
    };
    const maxRetries = 60;
    let retries = 0;
    while (retries < maxRetries) {
      try {
        const response = await fetch(rpcUrl, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            jsonrpc: '2.0',
            id: 1,
            method: 'eth_getTransactionReceipt',
            params: [txHash],
          }),
        });
        const { result } = await response.json();
        if (result) {
          const success = result.status === '0x1';
          onStatusUpdate?.(success ? 'confirmed' : 'failed');
          
          return {
            success,
            txHash,
            explorerUrl: `${explorerUrls[chain] || 'https://etherscan.io/tx/'}${txHash}`,
            status: success ? 'confirmed' : 'failed',
            error: success ? undefined : 'Transaction reverted',
          };
        }
      } catch (err) {
        console.warn('EVM tx status check error:', err);
      }
      await new Promise(resolve => setTimeout(resolve, 2000));
      retries++;
    }
    return {
      success: false,
      txHash,
      explorerUrl: `${explorerUrls[chain] || 'https://etherscan.io/tx/'}${txHash}`,
      status: 'pending',
      error: 'Transaction confirmation timeout',
    };
  }
  // ==================== UTILITIES ====================
  private isNativeToken(token: string): boolean {
    const natives = ['SOL', 'ETH', 'MATIC', 'BNB', 'AVAX', 'NATIVE'];
    return natives.includes(token.toUpperCase()) || 
           token === '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE';
  }
  private calculateMinOutput(amount: string, slippage: number): string {
    const amountBig = BigInt(amount);
    const slippageFactor = BigInt(Math.floor((100 - slippage) * 100));
    return ((amountBig * slippageFactor) / 10000n).toString();
  }
  /**
   * Format token amount for display
   */
  formatAmount(amount: string, decimals: number = 18): string {
    const num = parseFloat(amount) / Math.pow(10, decimals);
    return num.toFixed(6);
  }
  /**
   * Get supported chains
   */
  getSupportedChains(): string[] {
    return ['solana', 'ethereum', 'base', 'arbitrum', 'polygon', 'optimism', 'bsc', 'avalanche'];
  }
}
export const dexSwapService = new DexSwapService();