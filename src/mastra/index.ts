import { Mastra } from "@mastra/core";
import { MastraError } from "@mastra/core/error";
import { PinoLogger } from "@mastra/loggers";
import { LogLevel, MastraLogger } from "@mastra/core/logger";
import pino from "pino";
import { MCPServer } from "@mastra/mcp";
import { Memory } from "@mastra/memory";
import { PostgresStore } from "@mastra/pg";
import { NonRetriableError } from "inngest";
import { z } from "zod";
import { desc } from "drizzle-orm";

import { coinGeckoClient } from "../lib/coinGeckoClient";
import { apiCache, CACHE_TTL } from "../lib/cache";

import { sharedPostgresStorage } from "./storage";
import { inngest, inngestServe } from "./inngest";
import { darkwaveWorkflow } from "./workflows/darkwaveWorkflow";
import { darkwaveAgent } from "./agents/darkwaveAgent";
import { registerTelegramTrigger } from "../triggers/telegramTriggers";

// Import trading tools
import { walletConnectionTool } from "./tools/walletConnectionTool";
import { userSettingsTool } from "./tools/userSettingsTool";
import { balanceCheckerTool } from "./tools/balanceCheckerTool";
import { jupiterLimitOrderTool } from "./tools/jupiterLimitOrderTool";
import { tokenSnipingTool } from "./tools/tokenSnipingTool";

// Import existing tools
import { marketDataTool } from "./tools/marketDataTool";
import { technicalAnalysisTool } from "./tools/technicalAnalysisTool";
import { holdingsTool } from "./tools/holdingsTool";
import { scannerTool } from "./tools/scannerTool";
import { chartGeneratorTool } from "./tools/chartGeneratorTool";
import { dexscreenerTool } from "./tools/dexscreenerTool";
import { dexAnalysisTool } from "./tools/dexAnalysisTool";
import { priceAlertTool } from "./tools/priceAlertTool";
import { nftTool } from "./tools/nftTool";
import { subscriptionTool } from "./tools/subscriptionTool";
import { botDetectionTool } from "./tools/botDetectionTool";
import { sentimentTool } from "./tools/sentimentTool";
import { predictionTrackingService } from "../services/predictionTrackingService.js";
import { predictionLearningService } from "../services/predictionLearningService.js";
import { ecosystemService } from "../services/ecosystemService.js";
import { inngest as inngestClient } from "./inngest/client";
import { sniperBotRoutes } from "./routes/sniperBotRoutes";
import { limitOrderRoutes } from "./routes/limitOrderRoutes";
import { walletRoutes } from "./routes/walletRoutes";
import { paymentRoutes } from "./routes/paymentRoutes";
import { demoRoutes } from "./routes/demoRoutes";
import { mlRoutes } from "./routes/mlRoutes";
import { dustBusterRoutes } from "./routes/dustBusterRoutes";
import { autoTradeRoutes } from "./routes/autoTradeRoutes";
import { tradeExecutionRoutes } from "./routes/tradeExecutionRoutes";
import { quantRoutes } from "./routes/quantRoutes";
import { cryptoOnrampRoutes } from "./routes/cryptoOnrampRoutes";
import { swapRoutes } from "./routes/swapRoutes";
import { vaultRoutes } from "./routes/vaultRoutes";
import { analyticsRoutes } from "./routes/analyticsRoutes";
import { apiBillingRoutes } from "./routes/apiBillingRoutes";
import { socialTradingRoutes } from "./routes/socialTradingRoutes";
import { exchangeRoutes } from "./routes/exchangeRoutes";
import { autonomousTradingRoutes } from "./routes/autonomousTradingRoutes";
import { moonpayRoutes } from "./routes/moonpayRoutes";
import { transakRoutes } from "./routes/transakRoutes";
import { webauthnRoutes } from "./routes/webauthnRoutes";
import { ecosystemRoutes } from "./routes/ecosystemRoutes";
import { darkwaveChainRoutes } from "./routes/darkwaveChainRoutes";

class ProductionPinoLogger extends MastraLogger {
  protected logger: pino.Logger;

  constructor(
    options: {
      name?: string;
      level?: LogLevel;
    } = {},
  ) {
    super(options);

    this.logger = pino({
      name: options.name || "app",
      level: options.level || LogLevel.INFO,
      base: {},
      formatters: {
        level: (label: string, _number: number) => ({
          level: label,
        }),
      },
      timestamp: () => `,"time":"${new Date(Date.now()).toISOString()}"`,
    });
  }

  debug(message: string, args: Record<string, any> = {}): void {
    this.logger.debug(args, message);
  }

  info(message: string, args: Record<string, any> = {}): void {
    this.logger.info(args, message);
  }

  warn(message: string, args: Record<string, any> = {}): void {
    this.logger.warn(args, message);
  }

  error(message: string, args: Record<string, any> = {}): void {
    this.logger.error(args, message);
  }
}

export const mastra = new Mastra({
  storage: sharedPostgresStorage,
  // Register your workflows here
  workflows: { darkwaveWorkflow },
  // Agent enabled with Replit AI Integrations (free OpenAI access, no charges)
  agents: { darkwaveAgent },
  mcpServers: {
    allTools: new MCPServer({
      name: "allTools",
      version: "1.0.0",
      tools: {
        // Wallet & Trading Tools
        'wallet-connection': walletConnectionTool,
        'user-settings': userSettingsTool,
        'balance-checker': balanceCheckerTool,
        'jupiter-limit-order': jupiterLimitOrderTool,
        'token-sniping': tokenSnipingTool,
        
        // Market Analysis Tools
        'market-data-tool': marketDataTool,
        'technical-analysis-tool': technicalAnalysisTool,
        'holdings-tool': holdingsTool,
        'scanner-tool': scannerTool,
        'chart-generator-tool': chartGeneratorTool,
        'dexscreener-tool': dexscreenerTool,
        'dex-analysis-tool': dexAnalysisTool,
        'price-alert-tool': priceAlertTool,
        'nft-tool': nftTool,
        'subscription-tool': subscriptionTool,
        'bot-detection-tool': botDetectionTool,
        'sentiment-tool': sentimentTool,
      },
    }),
  },
  bundler: {
    // A few dependencies are not properly picked up by
    // the bundler if they are not added directly to the
    // entrypoint.
    externals: [
      "@slack/web-api",
      "inngest",
      "inngest/hono",
      "hono",
      "hono/streaming",
      "uuid",
      "uuid/*",
      "rpc-websockets",
    ],
    // sourcemaps are good for debugging.
    sourcemap: true,
  },
  server: {
    host: "0.0.0.0",
    port: parseInt(process.env.PORT || "5000"),
    middleware: [
      async (c, next) => {
        const mastra = c.get("mastra");
        const logger = mastra?.getLogger();
        logger?.debug("[Request]", { method: c.req.method, url: c.req.url });
        try {
          await next();
        } catch (error) {
          logger?.error("[Response]", {
            method: c.req.method,
            url: c.req.url,
            error,
          });
          if (error instanceof MastraError) {
            if (error.id === "AGENT_MEMORY_MISSING_RESOURCE_ID") {
              // This is typically a non-retirable error. It means that the request was not
              // setup correctly to pass in the necessary parameters.
              throw new NonRetriableError(error.message, { cause: error });
            }
          } else if (error instanceof z.ZodError) {
            // Validation errors are never retriable.
            throw new NonRetriableError(error.message, { cause: error });
          }

          throw error;
        }
      },
    ],
    apiRoutes: [
      // Health check endpoint for deployment health checks (must be at / for Replit health checks)
      {
        path: "/",
        method: "GET",
        createHandler: async () => async (c: any) => {
          return c.json({ status: "ok", timestamp: Date.now() });
        }
      },
      // Alternate health check path
      {
        path: "/healthz",
        method: "GET",
        createHandler: async () => async (c: any) => {
          return c.json({ status: "ok", timestamp: Date.now() });
        }
      },
      // This API route is used to register the Mastra workflow (inngest function) on the inngest server
      {
        path: "/api/inngest",
        method: "ALL",
        createHandler: async ({ mastra }) => inngestServe({ mastra, inngest }),
        // The inngestServe function integrates Mastra workflows with Inngest by:
        // 1. Creating Inngest functions for each workflow with unique IDs (workflow.${workflowId})
        // 2. Setting up event handlers that:
        //    - Generate unique run IDs for each workflow execution
        //    - Create an InngestExecutionEngine to manage step execution
        //    - Handle workflow state persistence and real-time updates
        // 3. Establishing a publish-subscribe system for real-time monitoring
        //    through the workflow:${workflowId}:${runId} channel
      },
      // Register Telegram webhook routes
      ...registerTelegramTrigger({
        triggerType: "telegram/message",
        handler: async (mastra, triggerInfo) => {
          const logger = mastra.getLogger();
          logger?.info("‚úÖ [Telegram] Handler called", { 
            userName: triggerInfo.params.userName,
            message: triggerInfo.params.message.substring(0, 50)
          });
        },
      }),
      // Market Overview API - Unified endpoint for stocks and crypto
      {
        path: "/api/market-overview",
        method: "GET",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          logger?.info('üîß [MarketOverviewAPI] Request received');
          
          const assetClass = c.req.query('assetClass') || 'crypto';
          const category = c.req.query('category') || 'top';
          
          logger?.info('üìù [MarketOverviewAPI] Parameters', { assetClass, category });
          
          // Validate parameters
          const validAssetClasses = ['crypto', 'stocks'];
          const validCategories = ['top', 'trending', 'gainers', 'losers', 'new', 'defi', 'nft'];
          
          if (!validAssetClasses.includes(assetClass)) {
            logger?.warn('‚ö†Ô∏è [MarketOverviewAPI] Invalid asset class', { assetClass });
            return c.json({ error: 'Invalid asset class. Must be crypto or stocks' }, 400);
          }
          
          if (!validCategories.includes(category)) {
            logger?.warn('‚ö†Ô∏è [MarketOverviewAPI] Invalid category', { category });
            return c.json({ error: 'Invalid category' }, 400);
          }
          
          try {
            const { fetchStocksOverview, fetchCryptoOverview } = await import('./tools/helpers/marketOverview.js');
            
            let data;
            if (assetClass === 'stocks') {
              data = await fetchStocksOverview(category, logger);
            } else {
              data = await fetchCryptoOverview(category, logger);
            }
            
            logger?.info('‚úÖ [MarketOverviewAPI] Data fetched successfully', { 
              assetClass, 
              category, 
              count: data.length 
            });
            
            return c.json(data);
          } catch (error: any) {
            logger?.error('‚ùå [MarketOverviewAPI] Error fetching data', { 
              error: error.message,
              assetClass,
              category
            });
            return c.json({ error: 'Failed to fetch market data' }, 500);
          }
        }
      },
      // News endpoint
      {
        path: "/api/news",
        method: "GET",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          logger?.info('üì∞ [News] Request received');
          
          const articles = [
            { title: "Bitcoin Surges Past $95K", source: "CoinDesk", url: "https://www.coindesk.com", publishedAt: new Date().toISOString() },
            { title: "Ethereum 2.0 Update Released", source: "CoinTelegraph", url: "https://cointelegraph.com", publishedAt: new Date().toISOString() },
            { title: "Tech Stocks Rally on AI News", source: "Bloomberg", url: "https://www.bloomberg.com", publishedAt: new Date().toISOString() },
            { title: "Fed Holds Rates Steady", source: "CNBC", url: "https://www.cnbc.com", publishedAt: new Date().toISOString() },
            { title: "NFT Market Shows Recovery", source: "Decrypt", url: "https://decrypt.co", publishedAt: new Date().toISOString() },
            { title: "Altcoin Season Approaching", source: "CryptoSlate", url: "https://cryptoslate.com", publishedAt: new Date().toISOString() }
          ];
          
          return c.json({ success: true, articles });
        }
      },
      // Multi-Model Streaming Analysis endpoint
      {
        path: "/api/stream-analysis",
        method: "POST",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          
          try {
            const { ticker, provider, analysisType } = await c.req.json();
            logger?.info('üß† [StreamAnalysis] Request received', { ticker, provider, analysisType });
            
            if (!ticker) {
              return c.json({ error: 'Ticker is required' }, 400);
            }
            
            const { streamAnalysis } = await import('./ai/streamingAnalysis.js');
            
            c.header('Content-Type', 'text/event-stream');
            c.header('Cache-Control', 'no-cache');
            c.header('Connection', 'keep-alive');
            
            const stream = new ReadableStream({
              async start(controller) {
                try {
                  for await (const chunk of streamAnalysis({
                    ticker,
                    analysisType: analysisType || 'technical',
                    provider: provider || 'openai'
                  })) {
                    controller.enqueue(new TextEncoder().encode(`data: ${JSON.stringify({ text: chunk })}\n\n`));
                  }
                  controller.enqueue(new TextEncoder().encode('data: [DONE]\n\n'));
                  controller.close();
                } catch (error: any) {
                  controller.enqueue(new TextEncoder().encode(`data: ${JSON.stringify({ error: error.message })}\n\n`));
                  controller.close();
                }
              }
            });
            
            return new Response(stream, {
              headers: {
                'Content-Type': 'text/event-stream',
                'Cache-Control': 'no-cache',
                'Connection': 'keep-alive'
              }
            });
          } catch (error: any) {
            logger?.error('‚ùå [StreamAnalysis] Error', { error: error.message });
            return c.json({ error: error.message || 'Streaming failed' }, 500);
          }
        }
      },
      // Multi-Model Ensemble Analysis endpoint
      {
        path: "/api/ensemble-analysis",
        method: "POST",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          
          try {
            const { ticker } = await c.req.json();
            logger?.info('üß† [EnsembleAnalysis] Request received', { ticker });
            
            if (!ticker) {
              return c.json({ error: 'Ticker is required' }, 400);
            }
            
            const { streamMultiModelAnalysis } = await import('./ai/streamingAnalysis.js');
            
            const results = await streamMultiModelAnalysis(ticker, (chunk, source) => {
              logger?.debug(`[${source}] ${chunk.substring(0, 50)}...`);
            });
            
            logger?.info('‚úÖ [EnsembleAnalysis] Completed', { ticker });
            return c.json({
              ticker,
              openaiAnalysis: results.openai,
              claudeAnalysis: results.claude,
              consensusAnalysis: results.consensus,
              providers: ['openai', 'claude'],
              timestamp: new Date().toISOString()
            });
          } catch (error: any) {
            logger?.error('‚ùå [EnsembleAnalysis] Error', { error: error.message });
            return c.json({ error: error.message || 'Ensemble analysis failed' }, 500);
          }
        }
      },
      // Agent Personas endpoint
      {
        path: "/api/agent-personas",
        method: "GET",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          logger?.info('ü§ñ [AgentPersonas] Request received');
          
          try {
            const { agentPersonas } = await import('./ai/agentPersonas.js');
            
            const personas = Object.values(agentPersonas).map(p => ({
              id: p.id,
              name: p.name,
              displayName: p.displayName,
              age: p.age,
              gender: p.gender,
              tradingStyle: p.tradingStyle,
              specialization: p.specialization,
              riskTolerance: p.riskTolerance,
              catchphrase: p.catchphrase
            }));
            
            return c.json({ personas, count: personas.length });
          } catch (error: any) {
            logger?.error('‚ùå [AgentPersonas] Error', { error: error.message });
            return c.json({ error: error.message }, 500);
          }
        }
      },
      // Unified Market Data endpoint
      {
        path: "/api/unified-data",
        method: "POST",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          
          try {
            const { ticker } = await c.req.json();
            logger?.info('üìä [UnifiedData] Request received', { ticker });
            
            if (!ticker) {
              return c.json({ error: 'Ticker is required' }, 400);
            }
            
            const { dataIntegration } = await import('./ai/dataIntegration.js');
            const data = await dataIntegration.fetchUnifiedData(ticker);
            
            logger?.info('‚úÖ [UnifiedData] Data fetched', { 
              ticker, 
              sources: data.market?.sources?.length || 0 
            });
            
            return c.json({
              ticker,
              ...data,
              timestamp: new Date().toISOString()
            });
          } catch (error: any) {
            logger?.error('‚ùå [UnifiedData] Error', { error: error.message });
            return c.json({ error: error.message || 'Data fetch failed' }, 500);
          }
        }
      },
      // AI Chat endpoint - Compatible with AI SDK v4
      {
        path: "/api/chat",
        method: "POST",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          
          try {
            const { prompt, userId } = await c.req.json();
            logger?.info('üí¨ [AIChat] Request received', { userId, promptLength: prompt?.length });
            
            if (!prompt) {
              return c.json({ error: 'Prompt is required' }, 400);
            }
            
            const agent = mastra.getAgent('darkwaveAgent');
            if (!agent) {
              logger?.error('‚ùå [AIChat] Agent not found');
              return c.json({ error: 'Agent not found' }, 404);
            }
            
            // Use generateLegacy for AI SDK v4 compatibility
            const response = await agent.generateLegacy(prompt, {
              maxSteps: 3
            });
            
            logger?.info('‚úÖ [AIChat] Response generated', { responseLength: response.text?.length });
            
            return c.json({ 
              text: response.text,
              toolCalls: response.toolCalls || []
            });
          } catch (error: any) {
            logger?.error('‚ùå [AIChat] Error', { error: error.message, stack: error.stack });
            return c.json({ error: error.message || 'Failed to generate response' }, 500);
          }
        }
      },
      // Analyze endpoint - Technical analysis for any ticker with prediction tracking
      {
        path: "/api/analyze",
        method: "POST",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          
          try {
            const { ticker, userId } = await c.req.json();
            logger?.info('üìä [Analyze] Request received', { ticker, userId });
            
            if (!ticker) {
              return c.json({ error: 'Ticker is required' }, 400);
            }
            
            // Step 1: Get market data
            const marketData = await marketDataTool.execute({
              context: { ticker, days: 90 },
              mastra,
              runtimeContext: null as any
            });
            
            if (!marketData || !marketData.prices) {
              return c.json({ error: 'Failed to fetch market data' }, 404);
            }
            
            // Step 2: Run technical analysis with proper context
            const analysis = await technicalAnalysisTool.execute({
              context: { 
                ticker: ticker.toUpperCase(),
                prices: marketData.prices,
                currentPrice: marketData.currentPrice,
                priceChange24h: marketData.priceChange24h,
                priceChangePercent24h: marketData.priceChangePercent24h
              },
              mastra,
              runtimeContext: { resourceId: userId || 'anonymous' } as any
            });
            
            if (!analysis) {
              return c.json({ error: 'Technical analysis failed' }, 500);
            }
            
            // Step 3: Log prediction for ML tracking (async, non-blocking)
            try {
              const predictionResult = await predictionTrackingService.logPrediction({
                ticker: ticker.toUpperCase(),
                assetType: marketData.type === 'crypto' ? 'crypto' : 'stock',
                priceAtPrediction: analysis.currentPrice || marketData.currentPrice,
                signal: analysis.recommendation || 'HOLD',
                indicators: {
                  rsi: analysis.rsi || 50,
                  macd: analysis.macd || { value: 0, signal: 0, histogram: 0 },
                  ema9: analysis.ema9 || 0,
                  ema21: analysis.ema21 || 0,
                  ema50: analysis.ema50 || 0,
                  ema200: analysis.ema200 || 0,
                  sma50: analysis.sma50 || 0,
                  sma200: analysis.sma200 || 0,
                  bollingerBands: analysis.bollingerBands || { upper: 0, middle: 0, lower: 0, bandwidth: 0 },
                  support: analysis.support || 0,
                  resistance: analysis.resistance || 0,
                  volumeDelta: analysis.volumeDelta || { buyVolume: 0, sellVolume: 0, delta: 0, buySellRatio: 1 },
                  spikeScore: analysis.spikeScore || { score: 0, signal: 'NO_SIGNAL', prediction: '' },
                  volatility: analysis.volatility || 0,
                },
                bullishSignals: analysis.signalCount?.bullish || 0,
                bearishSignals: analysis.signalCount?.bearish || 0,
                signalsList: analysis.signals || [],
                userId: userId || undefined,
              });
              
              if (predictionResult.success) {
                logger?.info('üìä [Prediction] Logged prediction', { 
                  predictionId: predictionResult.id,
                  ticker: ticker.toUpperCase(),
                  signal: analysis.recommendation
                });
                
                // Trigger Inngest workflow for outcome tracking
                inngestClient.send({
                  name: 'prediction/created',
                  data: { predictionId: predictionResult.id },
                }).catch(err => {
                  logger?.warn('‚ö†Ô∏è [Prediction] Failed to trigger outcome workflow', { error: err.message });
                });
              }
            } catch (predictionError: any) {
              logger?.warn('‚ö†Ô∏è [Prediction] Failed to log prediction (non-critical)', { error: predictionError.message });
            }
            
            logger?.info('‚úÖ [Analyze] Analysis completed', { ticker, recommendation: analysis.recommendation });
            return c.json(analysis);
          } catch (error: any) {
            logger?.error('‚ùå [Analyze] Error', { error: error.message });
            return c.json({ error: error.message || 'Analysis failed' }, 500);
          }
        }
      },
      // Stripe Checkout Session endpoint
      {
        path: "/api/create-checkout-session",
        method: "POST",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          
          try {
            const { plan, userId } = await c.req.json();
            logger?.info('üí≥ [Stripe] Creating checkout session', { plan, userId });
            
            if (!plan || !['basic', 'premium'].includes(plan)) {
              return c.json({ error: 'Invalid plan. Must be basic or premium' }, 400);
            }
            
            // Check for Stripe secret key
            if (!process.env.STRIPE_SECRET_KEY) {
              logger?.error('‚ùå [Stripe] STRIPE_SECRET_KEY not configured');
              return c.json({ error: 'Payment system not configured' }, 500);
            }
            
            // Dynamically import Stripe
            const Stripe = (await import('stripe')).default;
            const stripe = new Stripe(process.env.STRIPE_SECRET_KEY, {
              apiVersion: '2025-10-29.clover'
            });
            
            // Get current domain for success/cancel URLs
            const baseUrl = process.env.REPL_SLUG 
              ? `https://${process.env.REPL_SLUG}.${process.env.REPL_OWNER}.repl.co`
              : 'http://localhost:5000';
            
            // Plan pricing
            const planPrices: Record<string, { amount: number, name: string }> = {
              basic: { amount: 200, name: 'DarkWave PULSE - Basic Plan' },
              premium: { amount: 600, name: 'DarkWave PULSE - Premium Plan' }
            };
            
            const selectedPlan = planPrices[plan];
            
            // Create Stripe Checkout Session
            const session = await stripe.checkout.sessions.create({
              mode: 'subscription',
              payment_method_types: ['card'],
              line_items: [
                {
                  price_data: {
                    currency: 'usd',
                    product_data: {
                      name: selectedPlan.name,
                      description: `${plan === 'premium' ? 'Advanced' : 'Essential'} market analysis features`
                    },
                    unit_amount: selectedPlan.amount,
                    recurring: {
                      interval: 'month'
                    }
                  },
                  quantity: 1
                }
              ],
              success_url: `${baseUrl}?session_id={CHECKOUT_SESSION_ID}&payment=success`,
              cancel_url: `${baseUrl}?payment=cancelled`,
              metadata: {
                userId: userId || 'unknown',
                plan: plan
              }
            });
            
            logger?.info('‚úÖ [Stripe] Checkout session created', { 
              sessionId: session.id,
              url: session.url 
            });
            
            return c.json({ url: session.url, sessionId: session.id });
          } catch (error: any) {
            logger?.error('‚ùå [Stripe] Error creating checkout session', { 
              error: error.message,
              stack: error.stack 
            });
            return c.json({ error: 'Failed to create checkout session' }, 500);
          }
        }
      },
      // Authentication - Login endpoint
      {
        path: "/api/auth/login",
        method: "POST",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          
          try {
            const { credential, rememberMe } = await c.req.json();
            logger?.info('üîê [Auth] Login attempt', { credential: credential?.substring(0, 3) + '***' });
            
            if (!credential) {
              return c.json({ success: false, error: 'Credential is required' }, 400);
            }
            
            // Check access codes
            const userAccessCode = process.env.USER_ACCESS_CODE || '777';
            const adminAccessCode = process.env.ADMIN_ACCESS_CODE || '888';
            const ownerAccessCode = process.env.OWNER_ACCESS_CODE || '999';
            
            let accessLevel = '';
            let userId = '';
            
            if (credential === userAccessCode) {
              accessLevel = 'user';
              userId = 'trial-user-' + Date.now();
            } else if (credential === adminAccessCode) {
              accessLevel = 'admin';
              userId = 'admin-' + Date.now();
            } else if (credential === ownerAccessCode) {
              accessLevel = 'owner';
              userId = 'owner-' + Date.now();
            } else if (credential.includes('@')) {
              // Email-based login - check whitelist
              // For now, allow any email as a user
              accessLevel = 'user';
              userId = credential.replace(/[^a-zA-Z0-9]/g, '-');
            } else {
              logger?.warn('‚ùå [Auth] Invalid credentials');
              return c.json({ success: false, error: 'Invalid access code or email' }, 401);
            }
            
            const user = {
              id: userId,
              email: credential.includes('@') ? credential : null,
              accessLevel,
              uniqueCode: 'PULSE-' + Math.random().toString(36).substring(2, 6).toUpperCase() + '-' + new Date().getFullYear(),
              createdAt: new Date().toISOString()
            };
            
            logger?.info('‚úÖ [Auth] Login successful', { userId, accessLevel });
            
            return c.json({ success: true, user });
          } catch (error: any) {
            logger?.error('‚ùå [Auth] Login error', { error: error.message });
            return c.json({ success: false, error: 'Login failed' }, 500);
          }
        }
      },
      // Authentication - Session validation endpoint
      {
        path: "/api/auth/validate",
        method: "GET",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          logger?.info('üîç [Auth] Session validation request');
          
          // For now, return invalid since we don't have server-side sessions
          // The frontend uses localStorage for session persistence
          return c.json({ valid: false, message: 'No server session' });
        }
      },
      // Session check endpoint (called by frontend App.jsx)
      {
        path: "/api/session",
        method: "GET",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          logger?.info('üîç [Session] Session check request');
          
          const sessionToken = c.req.header('X-Session-Token');
          
          if (sessionToken) {
            try {
              const { verifyAndRotateSession } = await import('./middleware/accessControl.js');
              const result = await verifyAndRotateSession(sessionToken);
              
              if (result.valid && result.session) {
                logger?.info('‚úÖ [Session] Valid session found', { 
                  email: result.session.email,
                  rotated: result.rotated 
                });
                
                const headers: Record<string, string> = {};
                if (result.rotated) {
                  headers['X-Session-Token-Rotated'] = 'true';
                }
                
                return c.json({ 
                  user: { 
                    email: result.session.email || result.session.userId,
                    userId: result.session.userId,
                    accessLevel: result.session.accessLevel 
                  },
                  sessionToken: result.session.token
                }, 200, headers);
              }
            } catch (err) {
              logger?.error('‚ùå [Session] Session lookup error', { error: (err as Error).message });
            }
          }
          
          // Return empty session - frontend will check localStorage as fallback
          return c.json({ user: null, message: 'No active session' });
        }
      },
      // Serve frontend HTML at root
      {
        path: "/",
        method: "GET",
        createHandler: async ({ mastra }) => async (c: any) => {
          const fs = await import('fs/promises');
          const path = await import('path');
          const url = await import('url');
          
          // Check if request is for StrikeAgent domain
          const host = c.req.header('host') || '';
          const isStrikeAgent = host.includes('strikeagent.io') || host.includes('strikeagent');
          const htmlFile = isStrikeAgent ? 'strikeagent.html' : 'index.html';
          
          // Try multiple paths for dev vs deployment
          const __dirname = path.dirname(url.fileURLToPath(import.meta.url));
          const possiblePaths = [
            path.join(process.cwd(), 'public', htmlFile),
            path.join(__dirname, '..', '..', 'public', htmlFile),
            path.join(__dirname, '..', '..', '..', 'public', htmlFile),
          ];
          
          for (const filePath of possiblePaths) {
            try {
              const html = await fs.readFile(filePath, 'utf-8');
              c.header('Cache-Control', 'no-cache, no-store, must-revalidate');
              c.header('Pragma', 'no-cache');
              c.header('Expires', '0');
              return c.html(html);
            } catch (err) {
              continue;
            }
          }
          
          return c.text('Frontend not found. Tried paths: ' + possiblePaths.join(', '), 404);
        }
      },
      // Serve Telegram Mini App HTML
      {
        path: "/telegram",
        method: "GET",
        createHandler: async ({ mastra }) => async (c: any) => {
          const fs = await import('fs/promises');
          const path = await import('path');
          const url = await import('url');
          
          const __dirname = path.dirname(url.fileURLToPath(import.meta.url));
          const possiblePaths = [
            path.join(process.cwd(), 'public', 'telegram.html'),
            path.join(__dirname, '..', '..', 'public', 'telegram.html'),
            path.join(__dirname, '..', '..', '..', 'public', 'telegram.html'),
          ];
          
          for (const filePath of possiblePaths) {
            try {
              const html = await fs.readFile(filePath, 'utf-8');
              c.header('Cache-Control', 'no-cache, no-store, must-revalidate');
              c.header('Pragma', 'no-cache');
              c.header('Expires', '0');
              return c.html(html);
            } catch (err) {
              continue;
            }
          }
          
          return c.text('Telegram Mini App not found', 404);
        }
      },
      // Serve static assets
      {
        path: "/app.js",
        method: "GET",
        createHandler: async ({ mastra }) => async (c: any) => {
          const fs = await import('fs/promises');
          const path = await import('path');
          const url = await import('url');
          
          const __dirname = path.dirname(url.fileURLToPath(import.meta.url));
          const possiblePaths = [
            path.join(process.cwd(), 'public', 'app.js'),
            path.join(__dirname, '..', '..', 'public', 'app.js'),
            path.join(__dirname, '..', '..', '..', 'public', 'app.js'),
          ];
          
          for (const filePath of possiblePaths) {
            try {
              const js = await fs.readFile(filePath, 'utf-8');
              c.header('Content-Type', 'application/javascript');
              return c.body(js);
            } catch (err) {
              continue;
            }
          }
          
          return c.text('app.js not found', 404);
        }
      },
      {
        path: "/styles.css",
        method: "GET",
        createHandler: async ({ mastra }) => async (c: any) => {
          const fs = await import('fs/promises');
          const path = await import('path');
          const url = await import('url');
          
          const __dirname = path.dirname(url.fileURLToPath(import.meta.url));
          const possiblePaths = [
            path.join(process.cwd(), 'public', 'styles.css'),
            path.join(__dirname, '..', '..', 'public', 'styles.css'),
            path.join(__dirname, '..', '..', '..', 'public', 'styles.css'),
          ];
          
          for (const filePath of possiblePaths) {
            try {
              const css = await fs.readFile(filePath, 'utf-8');
              c.header('Content-Type', 'text/css');
              return c.body(css);
            } catch (err) {
              continue;
            }
          }
          
          return c.text('styles.css not found', 404);
        }
      },
      {
        path: "/darkwave-logo.jpg",
        method: "GET",
        createHandler: async ({ mastra }) => async (c: any) => {
          const fs = await import('fs/promises');
          const path = await import('path');
          const url = await import('url');
          
          const __dirname = path.dirname(url.fileURLToPath(import.meta.url));
          const possiblePaths = [
            path.join(process.cwd(), 'public', 'darkwave-logo.jpg'),
            path.join(__dirname, '..', '..', 'public', 'darkwave-logo.jpg'),
            path.join(__dirname, '..', '..', '..', 'public', 'darkwave-logo.jpg'),
          ];
          
          for (const filePath of possiblePaths) {
            try {
              const image = await fs.readFile(filePath);
              c.header('Content-Type', 'image/jpeg');
              return c.body(image);
            } catch (err) {
              continue;
            }
          }
          
          return c.text('Logo not found', 404);
        }
      },
      // ALIAS: /api/crypto/coin-prices -> /api/market-overview
      {
        path: "/api/crypto/coin-prices",
        method: "GET",
        createHandler: async ({ mastra }) => async (c: any) => {
          try {
            const response = await fetch('http://localhost:3001/api/market-overview');
            const data = await response.json();
            return c.json(data);
          } catch (error) {
            return c.json({ error: 'Failed to fetch coin prices' }, 500);
          }
        }
      },
      // Global Market Overview - totalMarketCap, volume, btcDominance, fearGreed, altcoinSeason
      {
        path: "/api/crypto/market-overview",
        method: "GET",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          
          const cached = apiCache.get<any>('global-market-overview');
          if (cached) {
            return c.json(cached);
          }
          
          try {
            const globalData = await coinGeckoClient.getGlobal();
            const data = globalData?.data || {};
            
            const result = {
              totalMarketCap: data.total_market_cap?.usd || 0,
              totalMarketCapChange: data.market_cap_change_percentage_24h_usd || 0,
              totalVolume: data.total_volume?.usd || 0,
              totalVolumeChange: 0,
              btcDominance: data.market_cap_percentage?.btc || 0,
              ethDominance: data.market_cap_percentage?.eth || 0,
              fearGreed: 65,
              altcoinSeason: 75,
              activeCryptocurrencies: data.active_cryptocurrencies || 0,
              markets: data.markets || 0,
              timestamp: Date.now()
            };
            
            apiCache.set('global-market-overview', result, 300);
            
            logger?.info('‚úÖ [GlobalMarketOverview] Data fetched', { btcDominance: result.btcDominance });
            return c.json(result);
          } catch (error: any) {
            logger?.error('‚ùå [GlobalMarketOverview] Error', { error: error.message });
            return c.json({
              totalMarketCap: 3.2e12,
              totalMarketCapChange: 2.1,
              totalVolume: 98e9,
              totalVolumeChange: -1.8,
              btcDominance: 54.5,
              ethDominance: 12.3,
              fearGreed: 65,
              altcoinSeason: 75,
              error: 'Using defaults'
            });
          }
        }
      },
      // Live BTC Price - 1 second ticker updates
      {
        path: "/api/crypto/btc-price",
        method: "GET",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          
          // Check cache (1 second TTL for live price - allows frequent updates)
          const cached = apiCache.get<any>('btc-live-price');
          if (cached) {
            return c.json(cached);
          }
          
          try {
            const data = await coinGeckoClient.getSimplePrice('bitcoin', 'usd');
            const price = data?.bitcoin?.usd || 0;
            const change24h = data?.bitcoin?.usd_24h_change || 0;
            
            const result = {
              price,
              change24h,
              timestamp: Date.now()
            };
            
            // Cache for 1 second to allow frequent updates
            apiCache.set('btc-live-price', result, 1);
            
            return c.json(result);
          } catch (error: any) {
            logger?.error('‚ùå [BTCPrice] Error', { error: error.message });
            return c.json({ price: 0, change24h: 0, error: 'Failed to fetch price' }, 500);
          }
        }
      },
      // Live Coin Price - for any coin by symbol (for live charts)
      {
        path: "/api/crypto/coin-price",
        method: "GET",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          const rawSymbol = c.req.query('symbol');
          
          // Validate symbol parameter
          if (!rawSymbol || typeof rawSymbol !== 'string' || rawSymbol.trim().length === 0) {
            return c.json({ error: 'Missing required symbol parameter', example: '/api/crypto/coin-price?symbol=BTC' }, 400);
          }
          
          const symbol = rawSymbol.trim().toUpperCase();
          
          // Common symbol to CoinGecko ID mapping
          const symbolToId: Record<string, string> = {
            'BTC': 'bitcoin', 'ETH': 'ethereum', 'USDT': 'tether', 'BNB': 'binancecoin',
            'XRP': 'ripple', 'USDC': 'usd-coin', 'ADA': 'cardano', 'DOGE': 'dogecoin',
            'SOL': 'solana', 'TRX': 'tron', 'DOT': 'polkadot', 'MATIC': 'matic-network',
            'LTC': 'litecoin', 'SHIB': 'shiba-inu', 'AVAX': 'avalanche-2', 'LINK': 'chainlink',
            'ATOM': 'cosmos', 'UNI': 'uniswap', 'XMR': 'monero', 'ETC': 'ethereum-classic',
            'XLM': 'stellar', 'BCH': 'bitcoin-cash', 'FIL': 'filecoin', 'NEAR': 'near',
            'APT': 'aptos', 'ARB': 'arbitrum', 'OP': 'optimism', 'INJ': 'injective-protocol',
            'PEPE': 'pepe', 'WIF': 'dogwifcoin', 'BONK': 'bonk', 'FLOKI': 'floki',
            'TRUMP': 'official-trump', 'PENGU': 'pudgy-penguins', 'HASH': 'provenance-blockchain'
          };
          
          const coinId = symbolToId[symbol] || symbol.toLowerCase();
          const cacheKey = `live-price:${coinId}`;
          
          // Check cache (5 second TTL for live price)
          const cached = apiCache.get<any>(cacheKey);
          if (cached) {
            return c.json(cached);
          }
          
          try {
            const data = await coinGeckoClient.getSimplePrice(coinId, 'usd');
            const coinData = data?.[coinId];
            
            if (!coinData) {
              // Fallback: try searching for the coin
              logger?.warn(`‚ö†Ô∏è [CoinPrice] Coin not found: ${symbol} (${coinId})`);
              return c.json({ error: 'Coin not found', symbol, coinId }, 404);
            }
            
            const price = coinData?.usd || 0;
            const change24h = coinData?.usd_24h_change || 0;
            
            const result = {
              price,
              change24h,
              symbol,
              coinId,
              timestamp: Date.now()
            };
            
            // Cache for 5 seconds
            apiCache.set(cacheKey, result, 5);
            
            return c.json(result);
          } catch (error: any) {
            logger?.error('‚ùå [CoinPrice] Error', { error: error.message, symbol });
            return c.json({ price: 0, change24h: 0, error: 'Failed to fetch price' }, 500);
          }
        }
      },
      // BTC History - OHLC data for chart
      {
        path: "/api/crypto/btc-history",
        method: "GET",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          const days = c.req.query('days') || '7';
          
          logger?.info('üìä [BTCHistory] Request', { days });
          
          // Check cache
          const cacheKey = `btc-ohlc:${days}`;
          const cached = apiCache.get<any[]>(cacheKey);
          if (cached) {
            logger?.info('üì¶ [BTCHistory] Returning cached data', { days });
            return c.json(cached);
          }
          
          try {
            // Convert 'max' to actual max supported by CoinGecko (365 days for daily candles)
            // CoinGecko free API limits daily OHLC to ~300 data points
            const daysNum = days === 'max' ? 365 : parseInt(days);
            
            const ohlcData = await coinGeckoClient.getOHLC('bitcoin', daysNum);
            
            if (!ohlcData || !Array.isArray(ohlcData) || ohlcData.length === 0) {
              logger?.warn('‚ö†Ô∏è [BTCHistory] No data from CoinGecko');
              return c.json([]);
            }
            
            // Transform to chart format
            const chartData = ohlcData.map((candle: number[]) => ({
              time: Math.floor(candle[0] / 1000),
              open: candle[1],
              high: candle[2],
              low: candle[3],
              close: candle[4]
            }));
            
            // Cache based on timeframe
            const cacheTTL = daysNum <= 1 ? 60 : daysNum <= 7 ? 300 : 600;
            apiCache.set(cacheKey, chartData, cacheTTL);
            
            logger?.info('‚úÖ [BTCHistory] Data fetched', { days, points: chartData.length });
            return c.json(chartData);
          } catch (error: any) {
            logger?.error('‚ùå [BTCHistory] Error', { error: error.message });
            return c.json({ error: 'Failed to fetch history' }, 500);
          }
        }
      },
      // Coin History - OHLC data for any coin (by symbol)
      {
        path: "/api/crypto/coin-history",
        method: "GET",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          const symbol = c.req.query('symbol')?.toUpperCase() || 'BTC';
          const days = c.req.query('days') || '7';
          
          logger?.info('üìä [CoinHistory] Request', { symbol, days });
          
          // Common symbol to CoinGecko ID mapping
          const symbolToIdMap: Record<string, string> = {
            'BTC': 'bitcoin',
            'ETH': 'ethereum',
            'DOGE': 'dogecoin',
            'SOL': 'solana',
            'XRP': 'ripple',
            'ADA': 'cardano',
            'DOT': 'polkadot',
            'AVAX': 'avalanche-2',
            'LINK': 'chainlink',
            'MATIC': 'polygon-ecosystem-token',
            'POL': 'polygon-ecosystem-token',
            'SHIB': 'shiba-inu',
            'PEPE': 'pepe',
            'LTC': 'litecoin',
            'UNI': 'uniswap',
            'ATOM': 'cosmos',
            'FIL': 'filecoin',
            'APT': 'aptos',
            'ARB': 'arbitrum',
            'OP': 'optimism',
            'SUI': 'sui',
            'SEI': 'sei-network',
            'TIA': 'celestia',
            'INJ': 'injective-protocol',
            'WIF': 'dogwifcoin',
            'BONK': 'bonk',
            'FLOKI': 'floki',
            'NEAR': 'near',
            'ICP': 'internet-computer',
            'AAVE': 'aave',
            'MKR': 'maker',
            'CRV': 'curve-dao-token',
            'LDO': 'lido-dao',
            'RENDER': 'render-token',
            'FET': 'fetch-ai',
            'GRT': 'the-graph',
            'JUP': 'jupiter-exchange-solana',
            'RAY': 'raydium',
            'BNB': 'binancecoin',
            'TRX': 'tron',
            'TON': 'the-open-network',
            'XLM': 'stellar',
            'HBAR': 'hedera-hashgraph',
            'VET': 'vechain',
            'ALGO': 'algorand',
            'EOS': 'eos',
            'XTZ': 'tezos',
            'EGLD': 'elrond-erd-2',
            'SAND': 'the-sandbox',
            'MANA': 'decentraland',
            'AXS': 'axie-infinity',
            'ENJ': 'enjincoin',
            'GALA': 'gala',
            'IMX': 'immutable-x',
            'CAKE': 'pancakeswap-token',
            'SUSHI': 'sushi',
            '1INCH': '1inch',
            'COMP': 'compound-governance-token',
            'SNX': 'havven',
            'YFI': 'yearn-finance',
            'BAL': 'balancer',
          };
          
          // Check cache
          const cacheKey = `coin-ohlc:${symbol}:${days}`;
          const cached = apiCache.get<any[]>(cacheKey);
          if (cached) {
            logger?.info('üì¶ [CoinHistory] Returning cached data', { symbol, days });
            return c.json(cached);
          }
          
          try {
            const daysNum = days === 'max' ? 1825 : parseInt(days);
            
            // Get coin ID from symbol
            let coinId = symbolToIdMap[symbol];
            
            // If not in mapping, try searching
            if (!coinId) {
              logger?.info('üîç [CoinHistory] Symbol not in map, searching', { symbol });
              try {
                const searchResult = await coinGeckoClient.get('/search', {
                  params: { query: symbol }
                });
                if (searchResult?.coins && searchResult.coins.length > 0) {
                  // Find exact symbol match
                  const exactMatch = searchResult.coins.find(
                    (coin: any) => coin.symbol?.toUpperCase() === symbol
                  );
                  coinId = exactMatch?.id || searchResult.coins[0].id;
                  logger?.info('‚úÖ [CoinHistory] Found coin ID via search', { symbol, coinId });
                }
              } catch (searchErr) {
                logger?.warn('‚ö†Ô∏è [CoinHistory] Search failed, using lowercase symbol', { symbol });
                coinId = symbol.toLowerCase();
              }
            }
            
            if (!coinId) {
              coinId = symbol.toLowerCase();
            }
            
            const ohlcData = await coinGeckoClient.getOHLC(coinId, daysNum);
            
            if (!ohlcData || !Array.isArray(ohlcData) || ohlcData.length === 0) {
              logger?.warn('‚ö†Ô∏è [CoinHistory] No data from CoinGecko', { symbol, coinId });
              return c.json([]);
            }
            
            // Transform to chart format
            const chartData = ohlcData.map((candle: number[]) => ({
              time: Math.floor(candle[0] / 1000),
              open: candle[1],
              high: candle[2],
              low: candle[3],
              close: candle[4]
            }));
            
            // Cache based on timeframe
            const cacheTTL = daysNum <= 1 ? 60 : daysNum <= 7 ? 300 : 600;
            apiCache.set(cacheKey, chartData, cacheTTL);
            
            logger?.info('‚úÖ [CoinHistory] Data fetched', { symbol, coinId, days, points: chartData.length });
            return c.json(chartData);
          } catch (error: any) {
            logger?.error('‚ùå [CoinHistory] Error', { symbol, error: error.message });
            return c.json({ error: 'Failed to fetch history' }, 500);
          }
        }
      },
      // Crypto Category Filter Routes - Used by coin table filter buttons
      {
        path: "/api/crypto/category/:category",
        method: "GET",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          const category = c.req.param('category');
          const timeframe = c.req.query('timeframe') || '24h';
          
          logger?.info('üìä [CryptoCategory] Request', { category, timeframe });
          
          // Check cache first
          const cacheKey = `category:${category}:${timeframe}`;
          const cached = apiCache.get<any[]>(cacheKey);
          if (cached) {
            logger?.info('üì¶ [CryptoCategory] Returning cached data', { category });
            return c.json({ coins: cached });
          }
          
          try {
            // Map frontend categories to CoinGecko API calls using centralized client
            let coins: any[] = [];
            let rawData: any[];
            
            const mapCoins = (data: any[]) => data.map((coin: any) => ({
              symbol: coin.symbol.toUpperCase(),
              name: coin.name,
              price: coin.current_price,
              change24h: coin.price_change_percentage_24h || 0,
              volume: coin.total_volume,
              image: coin.image
            }));
            
            const priceChangeKey = timeframe === '1h' ? 'price_change_percentage_1h_in_currency' : 'price_change_percentage_24h';
            const priceChangeParam = timeframe === '1h' ? '1h,24h' : '24h';
            
            switch (category) {
              case 'top':
                rawData = await coinGeckoClient.getMarkets({ per_page: 20, price_change_percentage: priceChangeParam });
                coins = rawData.map((coin: any) => ({
                  symbol: coin.symbol.toUpperCase(),
                  name: coin.name,
                  price: coin.current_price,
                  change: coin[priceChangeKey] || coin.price_change_percentage_24h || 0,
                  volume: coin.total_volume,
                  image: coin.image
                }));
                break;
                
              case 'meme':
                rawData = await coinGeckoClient.getMarkets({ category: 'meme-token', per_page: 20, price_change_percentage: priceChangeParam });
                coins = rawData.map((coin: any) => ({
                  symbol: coin.symbol.toUpperCase(),
                  name: coin.name,
                  price: coin.current_price,
                  change: coin[priceChangeKey] || coin.price_change_percentage_24h || 0,
                  volume: coin.total_volume,
                  image: coin.image
                }));
                break;
                
              case 'defi':
                rawData = await coinGeckoClient.getMarkets({ category: 'decentralized-finance-defi', per_page: 20, price_change_percentage: priceChangeParam });
                coins = rawData.map((coin: any) => ({
                  symbol: coin.symbol.toUpperCase(),
                  name: coin.name,
                  price: coin.current_price,
                  change: coin[priceChangeKey] || coin.price_change_percentage_24h || 0,
                  volume: coin.total_volume,
                  image: coin.image
                }));
                break;
                
              case 'dex':
                rawData = await coinGeckoClient.getMarkets({ category: 'decentralized-exchange', per_page: 20, price_change_percentage: priceChangeParam });
                coins = rawData.map((coin: any) => ({
                  symbol: coin.symbol.toUpperCase(),
                  name: coin.name,
                  price: coin.current_price,
                  change: coin[priceChangeKey] || coin.price_change_percentage_24h || 0,
                  volume: coin.total_volume,
                  image: coin.image
                }));
                break;
                
              case 'gainers':
                const gainersData = await coinGeckoClient.getMarkets({
                  order: 'market_cap_desc',
                  per_page: 100,
                  price_change_percentage: priceChangeParam
                });
                coins = gainersData
                  .filter((coin: any) => (coin[priceChangeKey] || coin.price_change_percentage_24h || 0) > 0)
                  .sort((a: any, b: any) => (b[priceChangeKey] || b.price_change_percentage_24h || 0) - (a[priceChangeKey] || a.price_change_percentage_24h || 0))
                  .slice(0, 20)
                  .map((coin: any) => ({
                    symbol: coin.symbol.toUpperCase(),
                    name: coin.name,
                    price: coin.current_price,
                    change: coin[priceChangeKey] || coin.price_change_percentage_24h || 0,
                    volume: coin.total_volume,
                    image: coin.image
                  }));
                break;
                
              case 'losers':
                const losersData = await coinGeckoClient.getMarkets({
                  order: 'market_cap_desc',
                  per_page: 100,
                  price_change_percentage: priceChangeParam
                });
                coins = losersData
                  .filter((coin: any) => (coin[priceChangeKey] || coin.price_change_percentage_24h || 0) < 0)
                  .sort((a: any, b: any) => (a[priceChangeKey] || a.price_change_percentage_24h || 0) - (b[priceChangeKey] || b.price_change_percentage_24h || 0))
                  .slice(0, 20)
                  .map((coin: any) => ({
                    symbol: coin.symbol.toUpperCase(),
                    name: coin.name,
                    price: coin.current_price,
                    change: coin[priceChangeKey] || coin.price_change_percentage_24h || 0,
                    volume: coin.total_volume,
                    image: coin.image
                  }));
                break;
                
              default:
                return c.json({ error: 'Invalid category' }, 400);
            }
            
            // Cache the result for 2 minutes
            apiCache.set(cacheKey, coins, CACHE_TTL.MARKET_DATA);
            
            logger?.info('‚úÖ [CryptoCategory] Success', { category, count: coins.length });
            return c.json({ coins });
            
          } catch (error: any) {
            logger?.error('‚ùå [CryptoCategory] Error', { category, error: error.message });
            return c.json({ error: 'Failed to fetch category data' }, 500);
          }
        }
      },
      // ALIAS: /api/sentiment/fear-greed
      {
        path: "/api/sentiment/fear-greed",
        method: "GET",
        createHandler: async ({ mastra }) => async (c: any) => {
          try {
            return c.json({
              data: [{
                value: 65,
                valueClassification: 'Greed',
                timestamp: Math.floor(Date.now() / 1000)
              }]
            });
          } catch (error) {
            return c.json({ error: 'Failed to fetch fear & greed' }, 500);
          }
        }
      },
      // ALIAS: /api/crypto/market-chart (with 60-second cache using CoinGecko API)
      {
        path: "/api/crypto/market-chart",
        method: "GET",
        createHandler: async ({ mastra }) => {
          // In-memory cache for market chart data (60 second TTL) - keyed by interval
          const chartCacheMap: Map<string, { data: any; timestamp: number }> = new Map();
          const CACHE_TTL_MS = 60000; // 60 seconds
          
          return async (c: any) => {
            try {
              const { interval } = c.req.query();
              const logger = mastra.getLogger();
              const currentInterval = interval || '60';
              
              // Return cached data if still valid for this specific interval
              const cachedEntry = chartCacheMap.get(currentInterval);
              if (cachedEntry && (Date.now() - cachedEntry.timestamp) < CACHE_TTL_MS) {
                logger?.info('üì¶ [MarketChart] Returning cached data for interval', { interval: currentInterval });
                return c.json(cachedEntry.data);
              }
              
              logger?.info('üìä [MarketChart] Fetching fresh data from CoinGecko', { interval: currentInterval });
              
              const intervalMinutes = parseInt(currentInterval) || 60;
              let days: number | string = 1;
              if (intervalMinutes <= 1) days = 1;        // 1hr view: 1 day of minute data
              else if (intervalMinutes <= 60) days = 1;  // 24hr view: 1 day of hourly data
              else if (intervalMinutes <= 240) days = 7; // 7d view
              else if (intervalMinutes <= 720) days = 14;
              else if (intervalMinutes <= 1440) days = 30; // 1 month view
              else if (intervalMinutes <= 10080) days = 365; // 1 year / all time view - get full year of data
              
              // Use centralized CoinGecko client with API key support
              const [ohlcData, marketData] = await Promise.all([
                coinGeckoClient.getOHLC('bitcoin', days as number),
                coinGeckoClient.getMarketChart('bitcoin', days)
              ]);
              
              if (!ohlcData || !Array.isArray(ohlcData) || ohlcData.length === 0) {
                logger?.warn('‚ö†Ô∏è [MarketChart] No OHLC data from CoinGecko');
                if (cachedEntry && cachedEntry.data) {
                  return c.json(cachedEntry.data);
                }
                return c.json({ candleData: [], sparklineData: [] });
              }
              
              // Build volume lookup map from market_chart data
              const volumeMap: Map<number, number> = new Map();
              if (marketData?.total_volumes && Array.isArray(marketData.total_volumes)) {
                marketData.total_volumes.forEach((v: number[]) => {
                  // Round timestamp to nearest hour for matching
                  const roundedTs = Math.floor(v[0] / 3600000) * 3600000;
                  volumeMap.set(roundedTs, v[1]);
                });
              }
              
              // CoinGecko OHLC format: [timestamp, open, high, low, close]
              const candleData = ohlcData.map((candle: number[]) => {
                const ts = candle[0];
                const roundedTs = Math.floor(ts / 3600000) * 3600000;
                // Find closest volume data point
                let volume = volumeMap.get(roundedTs) || 0;
                if (volume === 0) {
                  // Try finding nearby volume
                  for (let offset = 3600000; offset <= 7200000; offset += 3600000) {
                    volume = volumeMap.get(roundedTs - offset) || volumeMap.get(roundedTs + offset) || 0;
                    if (volume > 0) break;
                  }
                }
                return {
                  timestamp: ts,
                  open: candle[1],
                  high: candle[2],
                  low: candle[3],
                  close: candle[4],
                  volume: volume
                };
              });
              
              // Extract sparkline (just closing prices)
              const sparklineData = candleData.map((c: any) => c.close);
              
              const responseData = { candleData, sparklineData, interval: currentInterval };
              
              // Update cache for this interval
              chartCacheMap.set(currentInterval, {
                data: responseData,
                timestamp: Date.now()
              });
              
              // Clean old cache entries (keep last 5 intervals)
              if (chartCacheMap.size > 5) {
                const oldestKey = chartCacheMap.keys().next().value;
                if (oldestKey) chartCacheMap.delete(oldestKey);
              }
              
              logger?.info('‚úÖ [MarketChart] Data cached from CoinGecko', { 
                interval: currentInterval,
                candleCount: candleData.length, 
                sparklineCount: sparklineData.length,
                hasVolume: candleData.some((c: any) => c.volume > 0)
              });
              
              return c.json(responseData);
            } catch (error: any) {
              const logger = mastra.getLogger();
              logger?.error('‚ùå [MarketChart] Error fetching data', { error: error.message });
              // Return any cached data if available
              const cachedEntry = chartCacheMap.values().next().value;
              if (cachedEntry && cachedEntry.data) {
                return c.json(cachedEntry.data);
              }
              return c.json({ candleData: [], sparklineData: [] });
            }
          };
        }
      },
      // Trading API: Buy Limit Order (V2 Feature - Locked)
      {
        path: "/api/trading/buy-limit",
        method: "POST",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          try {
            const { tokenSymbol, targetPrice, amount, walletAddress } = await c.req.json();
            logger?.info('üìà [BuyLimit] Order received', { tokenSymbol, targetPrice, amount });
            
            // V2 Locked Feature - Return locked response
            return c.json({
              success: false,
              locked: true,
              message: 'üîí Buy Limit Orders are a V2 Predictive Trading feature. Coming Dec 25, 2025!',
              features: {
                description: 'Set automatic buy orders when your target price is reached',
                predictiveEdge: 'AI-powered entry points based on technical signals',
                autoExecution: 'Executes instantly when conditions are met'
              }
            }, 423);
          } catch (error: any) {
            return c.json({ error: error.message }, 400);
          }
        }
      },
      // Trading API: Sell Limit Order (V2 Feature - Locked)
      {
        path: "/api/trading/sell-limit",
        method: "POST",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          try {
            const { tokenSymbol, targetPrice, amount, walletAddress } = await c.req.json();
            logger?.info('üìâ [SellLimit] Order received', { tokenSymbol, targetPrice, amount });
            
            // V2 Locked Feature - Return locked response
            return c.json({
              success: false,
              locked: true,
              message: 'üîí Sell Limit Orders are a V2 Predictive Trading feature. Coming Dec 25, 2025!',
              features: {
                description: 'Set automatic sell orders at your target price',
                riskManagement: 'Built-in stop-loss and take-profit levels',
                prediction: 'AI-powered exit signals for optimal profits'
              }
            }, 423);
          } catch (error: any) {
            return c.json({ error: error.message }, 400);
          }
        }
      },
      // Trading API: List Active Orders (V2 Feature - Locked)
      {
        path: "/api/trading/orders",
        method: "GET",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          try {
            logger?.info('üìã [Orders] List request');
            
            // V2 Locked Feature - Return locked response
            return c.json({
              success: false,
              locked: true,
              message: 'üîí Order Management is a V2 Predictive Trading feature. Coming Dec 25, 2025!',
              orders: [],
              upgradeUrl: '/pricing'
            }, 423);
          } catch (error: any) {
            return c.json({ error: error.message }, 400);
          }
        }
      },
      // ALIAS: /api/payments/plans
      {
        path: "/api/payments/plans",
        method: "GET",
        createHandler: async ({ mastra }) => async (c: any) => {
          try {
            return c.json([
              { id: 'free', name: 'Free Trial', price: 0 },
              { id: 'basic', name: 'Basic', price: 9.99 },
              { id: 'premium', name: 'Premium', price: 29.99 }
            ]);
          } catch (error) {
            return c.json({ error: 'Failed to fetch payment plans' }, 500);
          }
        }
      },
      // Serve coins directory (JSON and images)
      {
        path: "/coins/*",
        method: "GET",
        createHandler: async ({ mastra }) => async (c: any) => {
          const fs = await import('fs/promises');
          const path = await import('path');
          const url = await import('url');
          
          const requestedFile = c.req.path.replace('/coins/', '');
          const __dirname = path.dirname(url.fileURLToPath(import.meta.url));
          const possiblePaths = [
            path.join(process.cwd(), 'public', 'coins', requestedFile),
            path.join(__dirname, '..', '..', 'public', 'coins', requestedFile),
            path.join(__dirname, '..', '..', '..', 'public', 'coins', requestedFile),
          ];
          
          for (const filePath of possiblePaths) {
            try {
              const fileBuffer = await fs.readFile(filePath);
              
              // Set content type based on file extension
              if (requestedFile.endsWith('.json')) {
                c.header('Content-Type', 'application/json');
              } else if (requestedFile.endsWith('.jpg') || requestedFile.endsWith('.jpeg')) {
                c.header('Content-Type', 'image/jpeg');
              } else if (requestedFile.endsWith('.png')) {
                c.header('Content-Type', 'image/png');
              }
              
              return c.body(fileBuffer);
            } catch (err) {
              continue;
            }
          }
          
          return c.text('File not found: ' + requestedFile, 404);
        }
      },
      // Admin Dashboard - View subscribers and manage whitelist
      {
        path: "/admin",
        method: "GET",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          
          // Simple admin authentication - check if access code matches
          const adminCode = c.req.query('code');
          const expectedCode = process.env.ADMIN_ACCESS_CODE;
          
          if (!expectedCode) {
            logger?.error('‚ùå [Admin] ADMIN_ACCESS_CODE not configured');
            return c.text('Admin dashboard not configured', 500);
          }
          
          if (adminCode !== expectedCode) {
            return c.html(`
              <html>
                <head>
                  <title>Admin Access</title>
                  <style>
                    body { font-family: Arial, sans-serif; max-width: 400px; margin: 100px auto; padding: 20px; background: #1a1a1a; color: #fff; }
                    input { width: 100%; padding: 12px; margin: 10px 0; background: #2a2a2a; border: 1px solid #4ADE80; color: #fff; border-radius: 4px; }
                    button { width: 100%; padding: 12px; background: #4ADE80; color: #000; border: none; border-radius: 4px; font-weight: bold; cursor: pointer; }
                    button:hover { background: #3BC970; }
                  </style>
                </head>
                <body>
                  <h2>üîê Admin Access</h2>
                  <form action="/admin" method="GET">
                    <input type="password" name="code" placeholder="Enter admin code" required>
                    <button type="submit">Access Dashboard</button>
                  </form>
                </body>
              </html>
            `);
          }
          
          // Fetch all subscribers, whitelisted users, and token submissions
          const { db } = await import('../db/client.js');
          const { subscriptions, whitelistedUsers, tokenSubmissions } = await import('../db/schema.js');
          
          const allSubscribers = await db.select().from(subscriptions);
          const allWhitelisted = await db.select().from(whitelistedUsers);
          const allTokenSubmissions = await db.select().from(tokenSubmissions).orderBy(desc(tokenSubmissions.submittedAt));
          
          const premiumCount = allSubscribers.filter(s => s.plan === 'premium' && s.status === 'active').length;
          const basicCount = allSubscribers.filter(s => s.plan === 'basic' && s.status === 'active').length;
          const monthlyRevenue = (premiumCount * 6) + (basicCount * 2);
          
          const html = `
            <!DOCTYPE html>
            <html>
              <head>
                <title>DarkWave Admin Dashboard</title>
                <style>
                  * { margin: 0; padding: 0; box-sizing: border-box; }
                  body { font-family: Arial, sans-serif; background: linear-gradient(135deg, #8B0000 0%, #4B0082 50%, #000000 100%); color: #fff; padding: 20px; }
                  .container { max-width: 1200px; margin: 0 auto; }
                  h1 { margin-bottom: 30px; text-align: center; }
                  .stats { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin-bottom: 30px; }
                  .stat-card { background: rgba(0,0,0,0.5); padding: 20px; border-radius: 8px; border: 1px solid #4ADE80; }
                  .stat-value { font-size: 32px; font-weight: bold; color: #4ADE80; }
                  .stat-label { color: #aaa; margin-top: 5px; }
                  .section { background: rgba(0,0,0,0.5); padding: 20px; border-radius: 8px; margin-bottom: 20px; border: 1px solid #666; }
                  .section h2 { margin-bottom: 15px; color: #4ADE80; }
                  table { width: 100%; border-collapse: collapse; }
                  th { background: rgba(74,222,128,0.2); padding: 12px; text-align: left; border-bottom: 2px solid #4ADE80; }
                  td { padding: 12px; border-bottom: 1px solid #333; }
                  tr:hover { background: rgba(74,222,128,0.1); }
                  .status-active { color: #4ADE80; font-weight: bold; }
                  .status-inactive { color: #999; }
                  .add-whitelist { background: #4ADE80; color: #000; padding: 10px 20px; border: none; border-radius: 4px; cursor: pointer; font-weight: bold; }
                  .add-whitelist:hover { background: #3BC970; }
                  input { padding: 8px; background: #2a2a2a; border: 1px solid #666; color: #fff; border-radius: 4px; margin-right: 10px; }
                </style>
              </head>
              <body>
                <div class="container">
                  <h1>üåä DarkWave Admin Dashboard</h1>
                  
                  <div class="stats">
                    <div class="stat-card">
                      <div class="stat-value">${allSubscribers.length}</div>
                      <div class="stat-label">Total Users</div>
                    </div>
                    <div class="stat-card">
                      <div class="stat-value">${basicCount}</div>
                      <div class="stat-label">Basic ($2/mo)</div>
                    </div>
                    <div class="stat-card">
                      <div class="stat-value">${premiumCount}</div>
                      <div class="stat-label">Premium ($6/mo)</div>
                    </div>
                    <div class="stat-card">
                      <div class="stat-value">$${monthlyRevenue}</div>
                      <div class="stat-label">Monthly Revenue (MRR)</div>
                    </div>
                    <div class="stat-card">
                      <div class="stat-value">${allWhitelisted.length}</div>
                      <div class="stat-label">Whitelisted Users</div>
                    </div>
                  </div>
                  
                  <div class="section">
                    <h2>üí≥ Active Subscribers (Basic + Premium)</h2>
                    <table>
                      <thead>
                        <tr>
                          <th>User ID</th>
                          <th>Plan</th>
                          <th>Status</th>
                          <th>Provider</th>
                          <th>Expiry Date</th>
                          <th>Auto-Renew</th>
                        </tr>
                      </thead>
                      <tbody>
                        ${allSubscribers.filter(s => (s.plan === 'premium' || s.plan === 'basic') && s.status === 'active').map(sub => `
                          <tr>
                            <td>${sub.userId}</td>
                            <td>${sub.plan.toUpperCase()}</td>
                            <td class="status-${sub.status}">${sub.status}</td>
                            <td>${sub.provider || 'N/A'}</td>
                            <td>${sub.expiryDate ? new Date(sub.expiryDate).toLocaleDateString() : 'N/A'}</td>
                            <td>${sub.autoRenew ? '‚úÖ Yes' : '‚ùå No'}</td>
                          </tr>
                        `).join('')}
                      </tbody>
                    </table>
                  </div>
                  
                  <div class="section">
                    <h2>‚≠ê Whitelisted Users</h2>
                    <form action="/admin/whitelist/add" method="POST" style="margin-bottom: 20px;">
                      <input type="hidden" name="code" value="${adminCode}">
                      <input type="text" name="userId" placeholder="User ID or Email" required>
                      <input type="text" name="reason" placeholder="Reason (optional)">
                      <button type="submit" class="add-whitelist">Add to Whitelist</button>
                    </form>
                    <p style="color: #aaa; margin-bottom: 20px; font-size: 14px;">
                      üí° Tip: Add Telegram IDs for bot users, or emails for website/app subscribers. Stripe subscriptions are auto-whitelisted.
                    </p>
                    <table>
                      <thead>
                        <tr>
                          <th>User ID / Email</th>
                          <th>Email</th>
                          <th>Reason</th>
                          <th>Expires At</th>
                          <th>Created</th>
                          <th>Actions</th>
                        </tr>
                      </thead>
                      <tbody>
                        ${allWhitelisted.map(user => `
                          <tr>
                            <td>${user.userId}</td>
                            <td>${user.email || 'N/A'}</td>
                            <td>${user.reason || 'N/A'}</td>
                            <td>${user.expiresAt ? new Date(user.expiresAt).toLocaleDateString() : 'Never'}</td>
                            <td>${new Date(user.createdAt).toLocaleDateString()}</td>
                            <td>
                              <form action="/admin/whitelist/remove" method="POST" style="display: inline;">
                                <input type="hidden" name="code" value="${adminCode}">
                                <input type="hidden" name="userId" value="${user.userId}">
                                <button type="submit" style="background: #ff4444; color: white; border: none; padding: 5px 10px; border-radius: 4px; cursor: pointer;">Remove</button>
                              </form>
                            </td>
                          </tr>
                        `).join('')}
                      </tbody>
                    </table>
                  </div>
                  
                  <div class="section">
                    <h2>üöÄ Token Submissions</h2>
                    <p style="color: #aaa; margin-bottom: 20px; font-size: 14px;">
                      Review and approve/reject user-submitted tokens. Approved tokens appear in the Projects section.
                    </p>
                    <table>
                      <thead>
                        <tr>
                          <th>Logo</th>
                          <th>Name / Symbol</th>
                          <th>Contract</th>
                          <th>Chain</th>
                          <th>Submitted By</th>
                          <th>Status</th>
                          <th>Submitted</th>
                          <th>Actions</th>
                        </tr>
                      </thead>
                      <tbody>
                        ${allTokenSubmissions.length === 0 ? `
                          <tr>
                            <td colspan="8" style="text-align: center; color: #aaa;">No token submissions yet</td>
                          </tr>
                        ` : allTokenSubmissions.map(submission => {
                          const statusColors = {
                            pending: '#FFA500',
                            approved: '#4ADE80',
                            rejected: '#ff4444'
                          };
                          const statusColor = statusColors[submission.status as keyof typeof statusColors] || '#aaa';
                          
                          return `
                          <tr>
                            <td>
                              ${submission.tokenLogo ? `
                                <img src="${submission.tokenLogo}" 
                                     style="width: 40px; height: 40px; border-radius: 50%; object-fit: cover;" 
                                     alt="${submission.tokenSymbol}">
                              ` : 'ü™ô'}
                            </td>
                            <td>
                              <strong>${submission.tokenName}</strong><br>
                              <span style="color: #aaa;">${submission.tokenSymbol}</span>
                            </td>
                            <td>
                              <code style="font-size: 11px; word-break: break-all;">${submission.tokenContract}</code>
                            </td>
                            <td>${submission.tokenChain}</td>
                            <td>${submission.submittedBy}</td>
                            <td style="color: ${statusColor}; font-weight: bold;">
                              ${submission.status.toUpperCase()}
                            </td>
                            <td>${new Date(submission.submittedAt).toLocaleDateString()}</td>
                            <td>
                              ${submission.status === 'pending' ? `
                                <button 
                                  onclick="approveToken('${submission.id}')" 
                                  style="background: #4ADE80; color: #000; border: none; padding: 5px 10px; border-radius: 4px; cursor: pointer; margin-right: 5px;">
                                  ‚úÖ Approve
                                </button>
                                <button 
                                  onclick="rejectToken('${submission.id}')" 
                                  style="background: #ff4444; color: white; border: none; padding: 5px 10px; border-radius: 4px; cursor: pointer;">
                                  ‚ùå Reject
                                </button>
                              ` : `
                                <span style="color: #aaa;">‚Äî</span>
                              `}
                            </td>
                          </tr>
                        `;
                        }).join('')}
                      </tbody>
                    </table>
                  </div>
                </div>
                
                <script>
                  const adminCode = '${adminCode}';
                  
                  async function approveToken(submissionId) {
                    if (!confirm('Approve this token? It will be published to the Projects section.')) return;
                    
                    try {
                      const response = await fetch('/api/admin/approve-token', {
                        method: 'POST',
                        headers: {
                          'Content-Type': 'application/json',
                          'X-Admin-Code': adminCode
                        },
                        body: JSON.stringify({ submissionId })
                      });
                      
                      const result = await response.json();
                      if (response.ok) {
                        alert('‚úÖ Token approved and published!');
                        window.location.reload();
                      } else {
                        alert('‚ùå Error: ' + result.error);
                      }
                    } catch (error) {
                      alert('‚ùå Error approving token');
                      console.error(error);
                    }
                  }
                  
                  async function rejectToken(submissionId) {
                    const reason = prompt('Why are you rejecting this token? (optional)');
                    if (reason === null) return; // User cancelled
                    
                    try {
                      const response = await fetch('/api/admin/reject-token', {
                        method: 'POST',
                        headers: {
                          'Content-Type': 'application/json',
                          'X-Admin-Code': adminCode
                        },
                        body: JSON.stringify({ submissionId, reason })
                      });
                      
                      const result = await response.json();
                      if (response.ok) {
                        alert('‚úÖ Token rejected');
                        window.location.reload();
                      } else {
                        alert('‚ùå Error: ' + result.error);
                      }
                    } catch (error) {
                      alert('‚ùå Error rejecting token');
                      console.error(error);
                    }
                  }
                </script>
              </body>
            </html>
          `;
          
          return c.html(html);
        }
      },
      // Admin: Add user to whitelist
      {
        path: "/admin/whitelist/add",
        method: "POST",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          const expectedCode = process.env.ADMIN_ACCESS_CODE;
          
          if (!expectedCode) {
            logger?.error('‚ùå [Admin] ADMIN_ACCESS_CODE not configured');
            return c.text('Admin dashboard not configured', 500);
          }
          
          const formData = await c.req.parseBody();
          const adminCode = formData.code || c.req.header('X-Admin-Code');
          
          // SECURITY: Validate admin code from form data or header
          if (adminCode !== expectedCode) {
            logger?.warn('‚ö†Ô∏è [Admin] Unauthorized whitelist add attempt');
            return c.text('Unauthorized', 401);
          }
          
          // SECURITY: Validate userId/email input
          const userIdOrEmail = formData.userId as string;
          if (!userIdOrEmail || typeof userIdOrEmail !== 'string' || userIdOrEmail.trim().length === 0) {
            logger?.warn('‚ö†Ô∏è [Admin] Invalid userId/email provided for whitelist');
            return c.text('Invalid userId/email', 400);
          }
          
          const { db } = await import('../db/client.js');
          const { whitelistedUsers } = await import('../db/schema.js');
          
          // Detect if input is an email address
          const isEmail = /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(userIdOrEmail.trim());
          
          if (isEmail) {
            // Store email in both userId AND email field for backwards compatibility
            await db.insert(whitelistedUsers).values({
              userId: userIdOrEmail.trim(),
              email: userIdOrEmail.trim(),
              reason: (formData.reason as string) || 'Email subscription',
              expiresAt: null,
            }).onConflictDoNothing();
            
            logger?.info('‚úÖ [Admin] Email added to whitelist', { email: userIdOrEmail.trim(), reason: formData.reason });
          } else {
            // Store as Telegram ID (userId)
            await db.insert(whitelistedUsers).values({
              userId: userIdOrEmail.trim(),
              email: null,
              reason: (formData.reason as string) || null,
              expiresAt: null,
            }).onConflictDoNothing();
            
            logger?.info('‚úÖ [Admin] Telegram ID added to whitelist', { userId: userIdOrEmail.trim(), reason: formData.reason });
          }
          
          return c.redirect(`/admin?code=${adminCode}`);
        }
      },
      // Admin: Remove user from whitelist
      {
        path: "/admin/whitelist/remove",
        method: "POST",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          const expectedCode = process.env.ADMIN_ACCESS_CODE;
          
          if (!expectedCode) {
            logger?.error('‚ùå [Admin] ADMIN_ACCESS_CODE not configured');
            return c.text('Admin dashboard not configured', 500);
          }
          
          const formData = await c.req.parseBody();
          const adminCode = formData.code || c.req.header('X-Admin-Code');
          
          // SECURITY: Validate admin code from form data or header
          if (adminCode !== expectedCode) {
            logger?.warn('‚ö†Ô∏è [Admin] Unauthorized whitelist remove attempt');
            return c.text('Unauthorized', 401);
          }
          
          // SECURITY: Validate userId input
          const userId = formData.userId as string;
          if (!userId || typeof userId !== 'string' || userId.trim().length === 0) {
            logger?.warn('‚ö†Ô∏è [Admin] Invalid userId provided for removal');
            return c.text('Invalid userId', 400);
          }
          
          const { db } = await import('../db/client.js');
          const { whitelistedUsers } = await import('../db/schema.js');
          const { eq } = await import('drizzle-orm');
          
          await db.delete(whitelistedUsers).where(eq(whitelistedUsers.userId, userId.trim()));
          
          logger?.info('‚úÖ [Admin] User removed from whitelist', { userId: userId.trim() });
          
          return c.redirect(`/admin?code=${adminCode}`);
        }
      },
      // Admin API: Get all token submissions
      {
        path: "/api/admin/token-submissions",
        method: "GET",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          const expectedCode = process.env.ADMIN_ACCESS_CODE;
          
          if (!expectedCode) {
            logger?.error('‚ùå [Admin] ADMIN_ACCESS_CODE not configured');
            return c.json({ error: 'Admin dashboard not configured' }, 500);
          }
          
          const adminCode = c.req.query('code') || c.req.header('X-Admin-Code');
          
          if (adminCode !== expectedCode) {
            logger?.warn('‚ö†Ô∏è [Admin] Unauthorized token submissions request');
            return c.json({ error: 'Unauthorized' }, 401);
          }
          
          const { db } = await import('../db/client.js');
          const { tokenSubmissions } = await import('../db/schema.js');
          
          const submissions = await db.select().from(tokenSubmissions).orderBy(desc(tokenSubmissions.submittedAt));
          
          logger?.info('‚úÖ [Admin] Token submissions retrieved', { count: submissions.length });
          return c.json({ submissions });
        }
      },
      // Admin API: Approve token submission
      {
        path: "/api/admin/approve-token",
        method: "POST",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          const expectedCode = process.env.ADMIN_ACCESS_CODE;
          
          if (!expectedCode) {
            logger?.error('‚ùå [Admin] ADMIN_ACCESS_CODE not configured');
            return c.json({ error: 'Admin dashboard not configured' }, 500);
          }
          
          const adminCode = c.req.header('X-Admin-Code');
          
          if (adminCode !== expectedCode) {
            logger?.warn('‚ö†Ô∏è [Admin] Unauthorized token approval attempt');
            return c.json({ error: 'Unauthorized' }, 401);
          }
          
          const { submissionId } = await c.req.json();
          
          const { db } = await import('../db/client.js');
          const { tokenSubmissions, approvedTokens } = await import('../db/schema.js');
          const { eq } = await import('drizzle-orm');
          
          // Get the submission
          const [submission] = await db.select().from(tokenSubmissions).where(eq(tokenSubmissions.id, submissionId)).limit(1);
          
          if (!submission) {
            return c.json({ error: 'Submission not found' }, 404);
          }
          
          // Create approved token with all comprehensive fields
          const tokenId = `tok_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
          await db.insert(approvedTokens).values({
            id: tokenId,
            address: submission.tokenContract,
            name: submission.tokenName,
            symbol: submission.tokenSymbol,
            description: submission.tokenDescription,
            chain: submission.tokenChain.toLowerCase(),
            platform: 'pumpfun', // Default, can be updated later
            logo: submission.tokenLogo,
            
            // Social Links
            website: submission.website,
            twitter: submission.twitter,
            telegram: submission.telegram,
            discord: submission.discord,
            
            // Documentation
            whitepaper: submission.whitepaper,
            tokenomics: submission.tokenomics,
            auditReport: submission.auditReport,
            
            // Project Qualifiers
            hasWhitepaper: submission.hasWhitepaper,
            hasAudit: submission.hasAudit,
            isDoxxedTeam: submission.isDoxxedTeam,
            hasLockedLiquidity: submission.hasLockedLiquidity,
            
            featured: true,
            displayOrder: 0,
          }).onConflictDoNothing();
          
          // Update submission status
          await db.update(tokenSubmissions)
            .set({ 
              status: 'approved',
              reviewedBy: 'admin',
              reviewedAt: new Date()
            })
            .where(eq(tokenSubmissions.id, submissionId));
          
          logger?.info('‚úÖ [Admin] Token approved', { submissionId, tokenContract: submission.tokenContract });
          return c.json({ success: true, message: 'Token approved and published' });
        }
      },
      // Admin API: Reject token submission
      {
        path: "/api/admin/reject-token",
        method: "POST",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          const expectedCode = process.env.ADMIN_ACCESS_CODE;
          
          if (!expectedCode) {
            logger?.error('‚ùå [Admin] ADMIN_ACCESS_CODE not configured');
            return c.json({ error: 'Admin dashboard not configured' }, 500);
          }
          
          const adminCode = c.req.header('X-Admin-Code');
          
          if (adminCode !== expectedCode) {
            logger?.warn('‚ö†Ô∏è [Admin] Unauthorized token rejection attempt');
            return c.json({ error: 'Unauthorized' }, 401);
          }
          
          const { submissionId, reason } = await c.req.json();
          
          const { db } = await import('../db/client.js');
          const { tokenSubmissions } = await import('../db/schema.js');
          const { eq } = await import('drizzle-orm');
          
          await db.update(tokenSubmissions)
            .set({ 
              status: 'rejected',
              reviewedBy: 'admin',
              reviewedAt: new Date(),
              rejectionReason: reason || 'Does not meet listing criteria'
            })
            .where(eq(tokenSubmissions.id, submissionId));
          
          logger?.info('‚úÖ [Admin] Token rejected', { submissionId, reason });
          return c.json({ success: true, message: 'Token rejected' });
        }
      },
      // Mini App Backend API Routes
      // Access Code Verification
      {
        path: "/api/verify-access",
        method: "POST",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          try {
            const { code, userId } = await c.req.json();
            logger?.info('üîê [Access Code] Verification attempt', { userId });
            
            if (!userId || typeof userId !== 'string' || userId.trim() === '') {
              return c.json({ 
                success: false, 
                message: 'User ID is required' 
              }, 400);
            }
            
            const correctCode = process.env.ACCESS_CODE;
            
            if (!correctCode) {
              logger?.error('üö® [Access Code] ACCESS_CODE not configured');
              return c.json({ error: 'Access code system not configured' }, 500);
            }
            
            // METHOD 1: Check if code matches "lucky 777"
            if (code === correctCode) {
              // Generate session token with user ID (7-day free tier)
              const { generateSessionToken } = await import('./middleware/accessControl.js');
              const sessionToken = await generateSessionToken(userId.trim(), undefined, false);
              
              logger?.info('‚úÖ [Access Code] Valid code entered, 7-day session created', { userId: userId.trim() });
              return c.json({ 
                success: true, 
                message: 'Access granted (7-day trial)',
                sessionToken 
              });
            }
            
            // METHOD 2: Check if input is an email and if it's whitelisted
            const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
            if (emailRegex.test(code)) {
              const cleanEmail = code.trim().toLowerCase();
              const { db } = await import('../db/client.js');
              const { whitelistedUsers } = await import('../db/schema.js');
              const { eq, or } = await import('drizzle-orm');
              
              // Check if email is in whitelist
              const whitelist = await db.select()
                .from(whitelistedUsers)
                .where(eq(whitelistedUsers.email, cleanEmail))
                .limit(1);
              
              if (whitelist.length > 0) {
                const whitelistEntry = whitelist[0];
                
                // Check if whitelist has expired
                if (whitelistEntry.expiresAt && new Date(whitelistEntry.expiresAt) < new Date()) {
                  logger?.warn('‚ùå [Email Access] Whitelist expired', { email: cleanEmail });
                  return c.json({ success: false, message: 'Email whitelist has expired' }, 401);
                }
                
                // Generate session token with email attached (permanent access for whitelisted)
                const { generateSessionToken } = await import('./middleware/accessControl.js');
                const sessionToken = await generateSessionToken(userId.trim(), cleanEmail, true, true);
                
                logger?.info('‚úÖ [Email Access] Whitelisted email granted permanent access', { 
                  email: cleanEmail, 
                  userId: userId.trim(),
                  reason: whitelistEntry.reason || 'Whitelisted'
                });
                
                return c.json({ 
                  success: true, 
                  message: 'Whitelisted email - permanent premium access granted',
                  sessionToken,
                  isPremium: true // Whitelisted users get premium
                });
              } else {
                logger?.warn('‚ùå [Email Access] Email not whitelisted', { email: cleanEmail });
                return c.json({ success: false, message: 'Email not found on whitelist' }, 401);
              }
            }
            
            // Neither access code nor whitelisted email
            logger?.warn('‚ùå [Access] Invalid input (not code or whitelisted email)', { userId: userId.trim() });
            return c.json({ success: false, message: 'Invalid access code or email' }, 401);
          } catch (error: any) {
            logger?.error('üö® [Access Code] Verification error', error);
            return c.json({ error: 'Verification failed' }, 500);
          }
        }
      },
      // Email Registration - Auto-whitelist + admin notifications
      {
        path: "/api/register-email",
        method: "POST",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          
          try {
            const { email, sessionToken } = await c.req.json();
            logger?.info('üìß [Email Registration] New registration attempt', { email: email?.substring(0, 10) + '...' });
            
            // Validate email format
            const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
            if (!email || !emailRegex.test(email)) {
              logger?.warn('‚ö†Ô∏è [Email Registration] Invalid email format');
              return c.json({ 
                success: false, 
                message: 'Invalid email address' 
              }, 400);
            }
            
            const cleanEmail = email.trim().toLowerCase();
            
            // Update session with email
            if (sessionToken) {
              const { db } = await import('../db/client.js');
              const { sessions } = await import('../db/schema.js');
              const { eq } = await import('drizzle-orm');
              
              await db.update(sessions)
                .set({ 
                  email: cleanEmail,
                  verifiedAt: new Date() // Auto-verify for simplicity
                })
                .where(eq(sessions.token, sessionToken));
              
              logger?.info('‚úÖ [Email Registration] Session updated with email', { email: cleanEmail });
            }
            
            // Auto-whitelist the email
            const { db } = await import('../db/client.js');
            const { whitelistedUsers } = await import('../db/schema.js');
            
            await db.insert(whitelistedUsers).values({
              userId: cleanEmail,
              email: cleanEmail,
              reason: 'Email registration',
              expiresAt: null,
            }).onConflictDoNothing();
            
            logger?.info('‚úÖ [Email Registration] Email auto-whitelisted', { email: cleanEmail });
            
            // Send Telegram notification to admin
            try {
              const telegramToken = process.env.TELEGRAM_BOT_TOKEN;
              const adminChatId = process.env.TELEGRAM_ADMIN_CHAT_ID;
              
              if (telegramToken && adminChatId) {
                const axios = await import('axios');
                const message = `üìß *New Email Registration!*\n\n` +
                  `‚úâÔ∏è Email: ${cleanEmail}\n` +
                  `üìÖ Registered: ${new Date().toLocaleString()}\n` +
                  `‚úÖ Auto-whitelisted for unlimited access\n\n` +
                  `üéØ Platform: ${sessionToken ? 'Mini App/Website' : 'Unknown'}`;
                
                await axios.default.post(`https://api.telegram.org/bot${telegramToken}/sendMessage`, {
                  chat_id: adminChatId,
                  text: message,
                  parse_mode: 'Markdown'
                });
                
                logger?.info('üì± [Telegram] Admin notification sent for new registration', { email: cleanEmail });
              }
            } catch (telegramError: any) {
              logger?.error('‚ùå [Telegram] Failed to send admin notification', { error: telegramError.message });
            }
            
            // Send Email notification to admin
            try {
              const adminEmail = process.env.ADMIN_EMAIL;
              
              if (adminEmail) {
                const { sendEmail } = await import('../utils/replitmail.js');
                const htmlContent = `
                  <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
                    <h2 style="color: #4ADE80;">üìß New Email Registration!</h2>
                    <div style="background: #f5f5f5; padding: 20px; border-radius: 8px; margin: 20px 0;">
                      <p><strong>‚úâÔ∏è Email:</strong> ${cleanEmail}</p>
                      <p><strong>üìÖ Registered:</strong> ${new Date().toLocaleString()}</p>
                      <p><strong>‚úÖ Status:</strong> Auto-whitelisted for unlimited access</p>
                    </div>
                    <p style="color: #666; font-size: 14px;">User can now access all premium features without subscription.</p>
                  </div>
                `;
                
                await sendEmail({
                  to: adminEmail,
                  subject: 'üìß New DarkWave Email Registration',
                  html: htmlContent,
                  text: `New Email Registration!\n\nEmail: ${cleanEmail}\nRegistered: ${new Date().toLocaleString()}\nStatus: Auto-whitelisted`
                });
                
                logger?.info('üìß [Email] Admin notification sent for new registration', { email: cleanEmail });
              }
            } catch (emailError: any) {
              logger?.error('‚ùå [Email] Failed to send admin notification', { error: emailError.message });
            }
            
            return c.json({ 
              success: true, 
              message: 'Email registered successfully! You now have unlimited access.',
              isWhitelisted: true
            });
            
          } catch (error: any) {
            logger?.error('üö® [Email Registration] Registration error', error);
            return c.json({ error: 'Registration failed' }, 500);
          }
        }
      },
      {
        path: "/api/analyze",
        method: "POST",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          
          try {
            const { ticker, userId } = await c.req.json();
            logger?.info('üìä [Mini App] Analysis request', { ticker, userId });
            
            // Step 1: Get market data
            const marketData = await marketDataTool.execute({
              context: { ticker, days: 90 },
              mastra,
              runtimeContext: null as any
            });
            
            if (!marketData || !marketData.prices) {
              return c.json({ error: 'Failed to fetch market data' }, 404);
            }
            
            // Step 2: Run technical analysis
            const analysis = await technicalAnalysisTool.execute({
              context: { 
                ticker,
                prices: marketData.prices,
                currentPrice: marketData.currentPrice,
                priceChange24h: marketData.priceChange24h,
                priceChangePercent24h: marketData.priceChangePercent24h
              },
              mastra,
              runtimeContext: null as any
            });
            
            if (!analysis) {
              return c.json({ error: 'Technical analysis failed' }, 500);
            }
            
            // Log prediction for tracking system (async, don't block response)
            try {
              const predictionResult = await predictionTrackingService.logPrediction({
                ticker: ticker.toUpperCase(),
                assetType: marketData.type === 'crypto' ? 'crypto' : 'stock',
                priceAtPrediction: analysis.currentPrice || marketData.currentPrice,
                signal: analysis.recommendation || 'HOLD',
                indicators: {
                  rsi: analysis.rsi || 50,
                  macd: analysis.macd || { value: 0, signal: 0, histogram: 0 },
                  ema9: analysis.ema9 || 0,
                  ema21: analysis.ema21 || 0,
                  ema50: analysis.ema50 || 0,
                  ema200: analysis.ema200 || 0,
                  sma50: analysis.sma50 || 0,
                  sma200: analysis.sma200 || 0,
                  bollingerBands: analysis.bollingerBands || { upper: 0, middle: 0, lower: 0, bandwidth: 0 },
                  support: analysis.support || 0,
                  resistance: analysis.resistance || 0,
                  volumeDelta: analysis.volumeDelta || { buyVolume: 0, sellVolume: 0, delta: 0, buySellRatio: 1 },
                  spikeScore: analysis.spikeScore || { score: 0, signal: 'NO_SIGNAL', prediction: '' },
                  volatility: analysis.volatility || 0,
                },
                bullishSignals: analysis.signalCount?.bullish || 0,
                bearishSignals: analysis.signalCount?.bearish || 0,
                signalsList: analysis.signals || [],
                userId: userId || undefined,
              });
              
              if (predictionResult.success) {
                logger?.info('üìä [Prediction] Logged prediction', { 
                  predictionId: predictionResult.id,
                  ticker: ticker.toUpperCase(),
                  signal: analysis.recommendation
                });
                
                // Trigger Inngest workflow for outcome tracking (fire and forget)
                inngestClient.send({
                  name: 'prediction/created',
                  data: { predictionId: predictionResult.id },
                }).catch(err => {
                  logger?.warn('‚ö†Ô∏è [Prediction] Failed to trigger outcome workflow', { error: err.message });
                });
              }
            } catch (predictionError: any) {
              logger?.warn('‚ö†Ô∏è [Prediction] Failed to log prediction (non-critical)', { error: predictionError.message });
            }
            
            // Calculate high/low from recent price data
            const recentPrices = marketData.prices.slice(-24); // Last 24 data points
            const high24h = Math.max(...recentPrices.map((p: any) => p.high));
            const low24h = Math.min(...recentPrices.map((p: any) => p.low));
            
            // Step 3: Get social sentiment (crypto only, graceful fallback)
            let sentimentData = null;
            if (marketData.type === 'crypto') {
              try {
                logger?.info('üì± [Mini App] Fetching social sentiment', { ticker });
                const sentiment = await sentimentTool.execute({
                  context: { ticker },
                  mastra,
                  runtimeContext: { resourceId: userId || 'demo-user' } as any
                });
                sentimentData = sentiment;
                logger?.info('‚úÖ [Mini App] Social sentiment retrieved', { ticker, score: sentiment.sentimentScore });
              } catch (error: any) {
                logger?.warn('‚ö†Ô∏è [Mini App] Sentiment fetch failed (non-critical)', { ticker, error: error.message });
                // Graceful fallback - continue without sentiment
              }
            }
            
            // Return ALL structured data for Mini App including advanced predictive metrics
            return c.json({
              ticker: ticker.toUpperCase(),
              price: analysis.currentPrice || marketData.currentPrice,
              priceChange: analysis.priceChangePercent24h || marketData.priceChangePercent24h || 0, // PERCENTAGE
              priceChangeDollar: analysis.priceChange24h || marketData.priceChange24h || 0, // DOLLAR AMOUNT
              recommendation: analysis.recommendation || 'HOLD',
              
              // Social sentiment (optional, crypto only)
              sentiment: sentimentData,
              
              // Core indicators
              rsi: analysis.rsi || 50,
              macd: {
                value: analysis.macd?.value || 0,
                signal: analysis.macd?.signal || 0,
                histogram: analysis.macd?.histogram || 0
              },
              
              // Moving averages
              sma50: analysis.sma50 || 0,
              sma200: analysis.sma200 || 0,
              ema9: analysis.ema9 || 0,
              ema21: analysis.ema21 || 0,
              ema50: analysis.ema50 || 0,
              ema200: analysis.ema200 || 0,
              
              // Support/Resistance
              support: analysis.support || 0,
              resistance: analysis.resistance || 0,
              
              // Bollinger Bands
              bollingerBands: {
                upper: analysis.bollingerBands?.upper || 0,
                middle: analysis.bollingerBands?.middle || 0,
                lower: analysis.bollingerBands?.lower || 0,
                bandwidth: analysis.bollingerBands?.bandwidth || 0
              },
              
              // Volume analysis
              volume: {
                current: analysis.volume?.current || 0,
                average: analysis.volume?.average || 0,
                changePercent: analysis.volume?.changePercent || 0
              },
              
              // ADVANCED PREDICTIVE METRICS
              volumeDelta: {
                buyVolume: analysis.volumeDelta?.buyVolume || 0,
                sellVolume: analysis.volumeDelta?.sellVolume || 0,
                delta: analysis.volumeDelta?.delta || 0,
                buySellRatio: analysis.volumeDelta?.buySellRatio || 1
              },
              
              spikeScore: {
                score: analysis.spikeScore?.score || 0,
                signal: analysis.spikeScore?.signal || 'NO_SIGNAL',
                prediction: analysis.spikeScore?.prediction || 'No prediction available'
              },
              
              volatility: analysis.volatility || 0,
              
              patternDuration: {
                estimate: analysis.patternDuration?.estimate || 'Unknown',
                confidence: analysis.patternDuration?.confidence || 'Low',
                type: analysis.patternDuration?.type || 'Unknown'
              },
              
              // Price extremes
              high24h: high24h || 0,
              low24h: low24h || 0,
              
              // Signals
              signals: analysis.signals || [],
              signalCount: {
                bullish: analysis.signalCount?.bullish || 0,
                bearish: analysis.signalCount?.bearish || 0
              }
            });
          } catch (error: any) {
            logger?.error('‚ùå [Mini App] Analysis error', { error: error.message });
            return c.json({ error: 'Analysis failed: ' + error.message }, 500);
          }
        },
      },
      // Prediction Accuracy API
      {
        path: "/api/prediction-accuracy",
        method: "GET",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          
          try {
            const ticker = c.req.query('ticker');
            const signal = c.req.query('signal');
            const horizon = c.req.query('horizon');
            
            logger?.info('üìä [Accuracy] Stats request', { ticker, signal, horizon });
            
            // Get global accuracy first
            const globalStats = await predictionTrackingService.getGlobalAccuracy();
            
            // Get filtered stats if parameters provided
            let filteredStats = null;
            if (ticker || signal || horizon) {
              filteredStats = await predictionTrackingService.getAccuracyStats({
                ticker: ticker || undefined,
                signal: signal || undefined,
                horizon: horizon || undefined,
              });
            }
            
            return c.json({
              success: true,
              global: {
                totalPredictions: globalStats.totalPredictions,
                winRate: globalStats.winRate,
                avgReturn: globalStats.avgReturn,
                lastUpdated: globalStats.lastUpdated,
              },
              filtered: filteredStats,
              message: globalStats.totalPredictions === 0 
                ? 'Prediction tracking just started. Check back soon for accuracy data!'
                : `Based on ${globalStats.totalPredictions} tracked predictions`,
            });
          } catch (error: any) {
            logger?.error('‚ùå [Accuracy] Stats error', { error: error.message });
            return c.json({ 
              success: false, 
              error: 'Failed to retrieve accuracy stats',
              global: { totalPredictions: 0, winRate: '0', avgReturn: '0', lastUpdated: null },
            }, 500);
          }
        },
      },
      // ML Model Status API
      {
        path: "/api/model-status",
        method: "GET",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          
          try {
            logger?.info('üß† [ModelStatus] Status request');
            
            const status = await predictionLearningService.getModelStatus();
            
            return c.json({
              success: true,
              ...status,
              message: status.totalFeatures < 50 
                ? `Collecting training data (${status.totalFeatures}/50 samples needed)`
                : 'ML models ready for training',
            });
          } catch (error: any) {
            logger?.error('‚ùå [ModelStatus] Status error', { error: error.message });
            return c.json({ 
              success: false, 
              error: 'Failed to retrieve model status',
            }, 500);
          }
        },
      },
      // ML Model Training Trigger API (Admin only)
      {
        path: "/api/train-models",
        method: "POST",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          
          try {
            // Check admin access
            const { checkAccessSession } = await import('./middleware/accessControl.js');
            const sessionCheck = await checkAccessSession(c) as any;
            if (!sessionCheck.valid || !['admin', 'owner'].includes(sessionCheck.accessLevel || '')) {
              logger?.warn('üö´ [TrainModels] Unauthorized request');
              return c.json({ error: 'Admin access required' }, 403);
            }
            
            logger?.info('üß† [TrainModels] Training trigger received');
            
            // Trigger training via Inngest event
            await inngestClient.send({
              name: 'model/train',
              data: { triggeredBy: 'api', timestamp: new Date().toISOString() }
            });
            
            return c.json({
              success: true,
              message: 'Model training triggered. Check logs for progress.',
            });
          } catch (error: any) {
            logger?.error('‚ùå [TrainModels] Training error', { error: error.message });
            return c.json({ 
              success: false, 
              error: 'Failed to trigger model training',
            }, 500);
          }
        },
      },
      // ORBIT Ecosystem Status API
      {
        path: "/api/ecosystem/status",
        method: "GET",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          
          try {
            logger?.info('üåê [Ecosystem] Status request');
            const status = await ecosystemService.getHubStatus();
            return c.json({ success: true, ...status });
          } catch (error: any) {
            logger?.error('‚ùå [Ecosystem] Status error', { error: error.message });
            return c.json({ success: false, error: error.message }, 500);
          }
        },
      },
      // ORBIT Ecosystem Activity Logs
      {
        path: "/api/ecosystem/logs",
        method: "GET",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          
          try {
            const limit = parseInt(c.req.query('limit') || '50');
            const offset = parseInt(c.req.query('offset') || '0');
            
            logger?.info('üåê [Ecosystem] Logs request', { limit, offset });
            const logs = await ecosystemService.getActivityLogs(limit, offset);
            return c.json({ success: true, ...logs });
          } catch (error: any) {
            logger?.error('‚ùå [Ecosystem] Logs error', { error: error.message });
            return c.json({ success: false, error: error.message }, 500);
          }
        },
      },
      // ORBIT Ecosystem Log Activity (for internal use)
      {
        path: "/api/ecosystem/log",
        method: "POST",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          
          try {
            // Check admin access
            const { checkAccessSession } = await import('./middleware/accessControl.js');
            const sessionCheck = await checkAccessSession(c) as any;
            if (!sessionCheck.valid || !['admin', 'owner'].includes(sessionCheck.accessLevel || '')) {
              return c.json({ error: 'Admin access required' }, 403);
            }
            
            const { action, details } = await c.req.json();
            logger?.info('üåê [Ecosystem] Log activity', { action });
            
            const success = await ecosystemService.logAppActivity(action, details);
            return c.json({ success });
          } catch (error: any) {
            logger?.error('‚ùå [Ecosystem] Log error', { error: error.message });
            return c.json({ success: false, error: error.message }, 500);
          }
        },
      },
      // ORBIT Ecosystem Push Snippet (for code sharing)
      {
        path: "/api/ecosystem/snippets",
        method: "POST",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          
          try {
            // Check admin access
            const { checkAccessSession } = await import('./middleware/accessControl.js');
            const sessionCheck = await checkAccessSession(c) as any;
            if (!sessionCheck.valid || !['admin', 'owner'].includes(sessionCheck.accessLevel || '')) {
              return c.json({ error: 'Admin access required' }, 403);
            }
            
            const { name, code, language, category, tags } = await c.req.json();
            logger?.info('üåê [Ecosystem] Push snippet', { name, language, category });
            
            const result = await ecosystemService.pushCodeSnippet(name, code, language, category, tags);
            return c.json({ success: true, snippet: result });
          } catch (error: any) {
            logger?.error('‚ùå [Ecosystem] Snippet error', { error: error.message });
            return c.json({ success: false, error: error.message }, 500);
          }
        },
      },
      // ORBIT Ecosystem Get Snippet
      {
        path: "/api/ecosystem/snippets/:snippetId",
        method: "GET",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          
          try {
            const snippetId = c.req.param('snippetId');
            logger?.info('üåê [Ecosystem] Get snippet', { snippetId });
            
            const snippet = await ecosystemService.getCodeSnippet(snippetId);
            return c.json({ success: true, snippet });
          } catch (error: any) {
            logger?.error('‚ùå [Ecosystem] Snippet error', { error: error.message });
            return c.json({ success: false, error: error.message }, 500);
          }
        },
      },
      // ORBIT Ecosystem Report Metrics (for dashboard integration)
      {
        path: "/api/ecosystem/metrics",
        method: "POST",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          
          try {
            // Check admin access
            const { checkAccessSession } = await import('./middleware/accessControl.js');
            const sessionCheck = await checkAccessSession(c) as any;
            if (!sessionCheck.valid || !['admin', 'owner'].includes(sessionCheck.accessLevel || '')) {
              return c.json({ error: 'Admin access required' }, 403);
            }
            
            const metrics = await c.req.json();
            logger?.info('üåê [Ecosystem] Report metrics', metrics);
            
            const success = await ecosystemService.reportMetrics(metrics);
            return c.json({ success });
          } catch (error: any) {
            logger?.error('‚ùå [Ecosystem] Metrics error', { error: error.message });
            return c.json({ success: false, error: error.message }, 500);
          }
        },
      },
      // Bot Detection API
      {
        path: "/api/bot-detection",
        method: "POST",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          
          // Check access session
          const { checkAccessSession } = await import('./middleware/accessControl.js');
          const sessionCheck = await checkAccessSession(c);
          if (!sessionCheck.valid) {
            logger?.warn('üö´ [Bot Detection] Unauthorized request');
            return sessionCheck.error;
          }
          
          try {
            const { tokenAddress, chain } = await c.req.json();
            logger?.info('ü§ñ [Bot Detection] Analysis request', { tokenAddress, chain });
            
            // Run bot detection
            const botAnalysis = await botDetectionTool.execute({
              context: { tokenAddress, chain },
              mastra,
              runtimeContext: null as any
            });
            
            logger?.info('‚úÖ [Bot Detection] Analysis complete', { 
              tokenAddress, 
              riskLevel: botAnalysis.riskLevel,
              botPercentage: botAnalysis.botPercentage
            });
            
            return c.json({ 
              success: true, 
              data: botAnalysis
            });
          } catch (error: any) {
            logger?.error('‚ùå [Bot Detection] Analysis error', error);
            return c.json({ 
              success: false,
              error: 'Bot detection failed',
              data: {
                botPercentage: 100,
                riskLevel: 'Extreme',
                riskColor: 'red',
                holderCount: 0,
                topHolderConcentration: 0,
                rugRiskIndicators: ['‚ö†Ô∏è ANALYSIS FAILED - Cannot verify safety', 'Assume extreme risk until verified'],
                confidence: 0,
                details: 'Analysis unavailable. DO NOT TRADE until you can verify token safety independently.'
              }
            }, 200); // Return 200 with EXTREME risk on error for safety
          }
        }
      },
      {
        path: "/api/chat",
        method: "POST",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          logger?.info('ü§ñ [AI Chat] Chat request received');
          
          // Check access session
          const { checkAccessSession } = await import('./middleware/accessControl.js');
          const sessionCheck = await checkAccessSession(c);
          if (!sessionCheck.valid) {
            logger?.warn('üö´ [Access Control] Unauthorized chat request');
            return sessionCheck.error;
          }
          
          try {
            const { message, history, userId } = await c.req.json();
            logger?.info('ü§ñ [AI Chat] Processing message', { 
              userId,
              messageLength: message?.length,
              historyLength: history?.length || 0
            });
            
            if (!message || message.trim().length === 0) {
              return c.json({ error: 'Message is required' }, 400);
            }
            
            // Get the DarkWave agent
            const darkwaveAgent = mastra.getAgent('darkwave');
            if (!darkwaveAgent) {
              logger?.error('üö® [AI Chat] DarkWave agent not found');
              return c.json({ error: 'AI agent not available' }, 500);
            }
            
            // Build conversation history for context
            const messages = [
              {
                role: 'system' as const,
                content: 'You are a helpful AI trading assistant. Answer questions about trading, technical indicators, market analysis, and investment strategies. Be concise but informative. Use emojis sparingly for clarity.'
              },
              ...(history || []).map((msg: any) => ({
                role: msg.role as 'user' | 'assistant',
                content: msg.content
              })),
              {
                role: 'user' as const,
                content: message
              }
            ];
            
            logger?.info('ü§ñ [AI Chat] Generating response');
            
            // Use generateLegacy for compatibility with AI SDK v4
            const response = await darkwaveAgent.generateLegacy(messages, {
              maxTokens: 500
            });
            
            const reply = response.text || 'I apologize, but I couldn\'t generate a response. Please try again.';
            
            logger?.info('‚úÖ [AI Chat] Response generated', { 
              replyLength: reply.length 
            });
            
            return c.json({ reply });
            
          } catch (error: any) {
            logger?.error('‚ùå [AI Chat] Error', { error: error.message, stack: error.stack });
            return c.json({ 
              error: 'Chat error occurred',
              reply: 'Sorry, I encountered an error. Please try again in a moment.' 
            }, 500);
          }
        },
      },
      {
        path: "/api/holdings",
        method: "GET",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          
          // Check access session
          const { checkAccessSession } = await import('./middleware/accessControl.js');
          const sessionCheck = await checkAccessSession(c);
          if (!sessionCheck.valid) {
            logger?.warn('üö´ [Access Control] Unauthorized holdings GET request');
            return sessionCheck.error;
          }
          
          const userId = c.req.query('userId') || 'demo-user';
          logger?.info('üìä [Mini App] Holdings request', { userId });
          
          try {
            const result = await holdingsTool.execute({
              context: { action: 'list', userId },
              mastra,
              runtimeContext: null as any
            });
            
            if (!result.success || !result.holdings || result.holdings.length === 0) {
              return c.json([]);
            }
            
            // Get real price data for each holding
            const holdingsWithData = await Promise.all(
              result.holdings.map(async (ticker: string) => {
                try {
                  const marketData = await marketDataTool.execute({
                    context: { ticker, days: 1 },
                    mastra,
                    runtimeContext: null as any
                  });
                  
                  if (marketData && marketData.currentPrice) {
                    return {
                      ticker,
                      price: marketData.currentPrice || 0,
                      change: marketData.priceChange24h || 0,
                      volume: marketData.volume24h || 0
                    };
                  }
                } catch (err) {
                  logger?.warn(`Failed to get data for ${ticker}`);
                }
                
                return {
                  ticker,
                  price: 0,
                  change: 0,
                  volume: 0
                };
              })
            );
            
            return c.json(holdingsWithData);
          } catch (error: any) {
            logger?.error('‚ùå [Mini App] Holdings error', { error: error.message });
            return c.json([]);
          }
        },
      },
      {
        path: "/api/holdings",
        method: "POST",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          
          // Check access session
          const { checkAccessSession } = await import('./middleware/accessControl.js');
          const sessionCheck = await checkAccessSession(c);
          if (!sessionCheck.valid) {
            logger?.warn('üö´ [Access Control] Unauthorized holdings POST request');
            return sessionCheck.error;
          }
          
          try {
            const { ticker, userId } = await c.req.json();
            logger?.info('‚≠ê [Mini App] Add holding', { ticker, userId });
            
            await holdingsTool.execute({
              context: { action: 'add', ticker, userId: userId || 'demo-user' },
              mastra,
              runtimeContext: null as any
            });
            
            return c.json({ success: true });
          } catch (error: any) {
            logger?.error('‚ùå [Mini App] Add holding error', { error: error.message });
            return c.json({ success: false }, 500);
          }
        },
      },
      // Top Movers endpoint
      {
        path: "/api/movers",
        method: "GET",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          
          // Check access session
          const { checkAccessSession } = await import('./middleware/accessControl.js');
          const sessionCheck = await checkAccessSession(c);
          if (!sessionCheck.valid) {
            return c.json({ error: 'Unauthorized - Invalid or expired session' }, 401);
          }
          
          const category = c.req.query('category') || 'gainers';
          const userId = c.req.query('userId') || 'demo-user';
          logger?.info('üî• [Mini App] Top movers request', { category, userId });
          
          try {
            // Use scanner tool to get top assets, then filter by category
            const scanResult = await scannerTool.execute({
              context: { type: 'crypto', limit: 20 },
              mastra,
              runtimeContext: null as any
            });
            
            if (!scanResult || !scanResult.strongBuys || scanResult.strongBuys.length === 0) {
              // Fallback: return hardcoded popular assets
              const fallbackMovers = [
                { ticker: 'BTC', price: 60000, change: 5.2 },
                { ticker: 'ETH', price: 3000, change: 4.8 },
                { ticker: 'SOL', price: 150, change: 8.5 },
                { ticker: 'BNB', price: 450, change: 3.2 },
                { ticker: 'XRP', price: 0.65, change: 2.1 },
                { ticker: 'ADA', price: 0.45, change: 6.3 },
                { ticker: 'AVAX', price: 35, change: 7.1 },
                { ticker: 'DOT', price: 8.5, change: 4.5 },
                { ticker: 'MATIC', price: 0.85, change: 5.9 },
                { ticker: 'LINK', price: 14.5, change: 3.7 }
              ];
              
              let movers = fallbackMovers;
              if (category === 'losers') {
                movers = fallbackMovers.map(m => ({ ...m, change: -Math.abs(m.change) }));
              } else if (category === 'volume') {
                movers = fallbackMovers; // Same list, different context
              }
              
              // Sort appropriately
              movers.sort((a, b) => category === 'losers' ? a.change - b.change : b.change - a.change);
              
              return c.json({ movers: movers.slice(0, 10) });
            }
            
            // Convert scanner strongBuys to movers format
            let movers = scanResult.strongBuys.map((buy: any) => ({
              ticker: buy.ticker,
              price: buy.currentPrice || 0,
              change: buy.priceChangePercent24h || 0
            }));
            
            // Filter and sort based on category
            if (category === 'gainers') {
              movers = movers.filter((m: any) => m.change > 0);
              movers.sort((a: any, b: any) => b.change - a.change);
            } else if (category === 'losers') {
              movers = movers.filter((m: any) => m.change < 0);
              movers.sort((a: any, b: any) => a.change - b.change);
            } else if (category === 'volume') {
              // For volume, we just return top movers regardless of direction
              movers.sort((a: any, b: any) => Math.abs(b.change) - Math.abs(a.change));
            }
            
            return c.json({ movers: movers.slice(0, 10) });
          } catch (error: any) {
            logger?.error('‚ùå [Mini App] Movers error', { error: error.message });
            // Return fallback data on error
            const fallbackMovers = [
              { ticker: 'BTC', price: 60000, change: 5.2 },
              { ticker: 'ETH', price: 3000, change: 4.8 },
              { ticker: 'SOL', price: 150, change: 8.5 }
            ];
            return c.json({ movers: fallbackMovers });
          }
        },
      },
      // Price Alerts endpoints
      {
        path: "/api/alerts",
        method: "GET",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          
          // Check access session
          const { checkAccessSession } = await import('./middleware/accessControl.js');
          const sessionCheck = await checkAccessSession(c);
          if (!sessionCheck.valid) {
            return c.json({ error: 'Unauthorized - Invalid or expired session' }, 401);
          }
          
          const userId = c.req.query('userId') || 'demo-user';
          logger?.info('üîî [Mini App] Get alerts request', { userId });
          
          try {
            const result = await priceAlertTool.execute({
              context: { action: 'list', userId },
              mastra,
              runtimeContext: null as any
            });
            
            return c.json({
              success: result.success,
              alerts: result.alerts || []
            });
          } catch (error: any) {
            logger?.error('‚ùå [Mini App] Get alerts error', { error: error.message });
            return c.json({ success: false, alerts: [], error: error.message }, 500);
          }
        },
      },
      {
        path: "/api/alerts",
        method: "POST",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          try {
            // Check access session
            const { checkAccessSession } = await import('./middleware/accessControl.js');
            const sessionCheck = await checkAccessSession(c);
            if (!sessionCheck.valid) {
              return c.json({ error: 'Unauthorized - Invalid or expired session' }, 401);
            }
            
            const { ticker, targetPrice, condition, userId } = await c.req.json();
            logger?.info('‚ûï [Mini App] Create alert request', { ticker, targetPrice, condition, userId });
            
            // Check subscription limits (pass session token for email whitelist check)
            const sessionToken = c.req.header('X-Session-Token');
            const { checkSubscriptionLimit } = await import('./middleware/subscriptionCheck.js');
            const limitCheck = await checkSubscriptionLimit(userId || 'demo-user', 'alert', sessionToken);
            
            if (!limitCheck.allowed) {
              logger?.warn('üö´ [Mini App] Alert limit exceeded', { userId });
              return c.json({ 
                success: false,
                message: limitCheck.message,
                upgradeRequired: true
              }, 402); // 402 Payment Required
            }
            
            const result = await priceAlertTool.execute({
              context: {
                action: 'create',
                ticker,
                targetPrice,
                condition,
                userId: userId || 'demo-user'
              },
              mastra,
              runtimeContext: null as any
            });
            
            return c.json(result);
          } catch (error: any) {
            logger?.error('‚ùå [Mini App] Create alert error', { error: error.message });
            return c.json({ success: false, message: error.message }, 500);
          }
        },
      },
      {
        path: "/api/alerts/:id",
        method: "DELETE",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          try {
            // Check access session
            const { checkAccessSession } = await import('./middleware/accessControl.js');
            const sessionCheck = await checkAccessSession(c);
            if (!sessionCheck.valid) {
              return c.json({ error: 'Unauthorized - Invalid or expired session' }, 401);
            }
            
            const alertId = c.req.param('id');
            const userId = c.req.query('userId') || 'demo-user';
            logger?.info('üóëÔ∏è [Mini App] Delete alert request', { alertId, userId });
            
            const result = await priceAlertTool.execute({
              context: {
                action: 'delete',
                alertId,
                userId
              },
              mastra,
              runtimeContext: null as any
            });
            
            return c.json(result);
          } catch (error: any) {
            logger?.error('‚ùå [Mini App] Delete alert error', { error: error.message });
            return c.json({ success: false, message: error.message }, 500);
          }
        },
      },
      {
        path: "/api/wallet",
        method: "GET",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          
          // Check access session
          const { checkAccessSession } = await import('./middleware/accessControl.js');
          const sessionCheck = await checkAccessSession(c);
          if (!sessionCheck.valid) {
            return c.json({ error: 'Unauthorized - Invalid or expired session' }, 401);
          }
          
          const userId = c.req.query('userId') || 'demo-user';
          logger?.info('üí∞ [Mini App] Wallet request', { userId });
          
          try {
            const result = await walletConnectionTool.execute({
              context: { action: 'view', userId },
              mastra,
              runtimeContext: null as any
            });
            
            const connected = result.success && !!result.walletAddress;
            let balance = 0;
            
            // If wallet is connected, get real balance
            if (connected && result.walletAddress) {
              try {
                const balanceResult = await balanceCheckerTool.execute({
                  context: { userId },
                  mastra,
                  runtimeContext: null as any
                });
                
                if (balanceResult && typeof balanceResult.balance === 'number') {
                  balance = balanceResult.balance;
                }
              } catch (balanceErr) {
                logger?.warn('Failed to fetch balance, returning 0');
              }
            }
            
            return c.json({
              connected,
              address: result.walletAddress || '',
              balance
            });
          } catch (error: any) {
            logger?.error('‚ùå [Mini App] Wallet error', { error: error.message });
            return c.json({ connected: false, address: '', balance: 0 });
          }
        },
      },
      // Tracked Wallets API (Read-Only, Up to 5 Wallets)
      {
        path: "/api/tracked-wallets",
        method: "GET",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          
          const { checkAccessSession } = await import('./middleware/accessControl.js');
          const sessionCheck = await checkAccessSession(c);
          if (!sessionCheck.valid) {
            return c.json({ error: 'Unauthorized' }, 401);
          }
          
          const userId = sessionCheck.userId || 'demo-user';
          logger?.info('üìã [Tracked Wallets] GET request', { userId });
          
          try {
            const { db } = await import('../db/client.js');
            const { trackedWallets } = await import('../db/schema.js');
            const { eq } = await import('drizzle-orm');
            
            const wallets = await db
              .select()
              .from(trackedWallets)
              .where(eq(trackedWallets.userId, userId));
            
            return c.json({ 
              wallets: wallets.map(w => ({
                id: w.id,
                address: w.address,
                chain: w.chain || 'solana',
                nickname: w.nickname,
                balance: w.balance ? JSON.parse(w.balance) : null,
                lastUpdated: w.lastUpdated
              }))
            });
          } catch (error: any) {
            logger?.error('‚ùå [Tracked Wallets] GET error', { error: error.message });
            return c.json({ error: 'Failed to fetch wallets' }, 500);
          }
        }
      },
      {
        path: "/api/tracked-wallets",
        method: "POST",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          
          const { checkAccessSession } = await import('./middleware/accessControl.js');
          const sessionCheck = await checkAccessSession(c);
          if (!sessionCheck.valid) {
            return c.json({ error: 'Unauthorized' }, 401);
          }
          
          const userId = sessionCheck.userId || 'demo-user';
          const { address, nickname, chain } = await c.req.json();
          const selectedChain = chain || 'solana'; // Default to Solana
          logger?.info('‚ûï [Tracked Wallets] POST request', { userId, address, chain: selectedChain });
          
          try {
            const { db } = await import('../db/client.js');
            const { trackedWallets } = await import('../db/schema.js');
            const { eq } = await import('drizzle-orm');
            const { randomBytes } = await import('crypto');
            
            // Check limit (max 5 wallets)
            const existing = await db
              .select()
              .from(trackedWallets)
              .where(eq(trackedWallets.userId, userId));
            
            if (existing.length >= 5) {
              return c.json({ 
                success: false, 
                message: 'Maximum 5 wallets allowed' 
              }, 400);
            }
            
            // Check for duplicate address
            const duplicate = existing.find(w => w.address === address);
            if (duplicate) {
              return c.json({ 
                success: false, 
                message: 'Wallet already tracked' 
              }, 400);
            }
            
            // Fetch balance based on chain
            let balance = null;
            try {
              if (selectedChain === 'solana') {
                // Solana via Helius
                const response = await fetch(
                  `https://api.helius.xyz/v0/addresses/${address}/balances?api-key=demo`,
                  { method: 'GET' }
                );
                const data = await response.json();
                balance = JSON.stringify(data);
              } else {
                // EVM chains (Ethereum, Polygon, Arbitrum, Base, BSC) via Alchemy free API
                // PRODUCTION NOTE: Replace 'demo' with your own Alchemy API key or use environment variable
                // Get your API key at: https://dashboard.alchemy.com/
                const alchemyApiKey = process.env.ALCHEMY_API_KEY || 'demo';
                const rpcUrls: Record<string, string> = {
                  ethereum: `https://eth-mainnet.g.alchemy.com/v2/${alchemyApiKey}`,
                  polygon: `https://polygon-mainnet.g.alchemy.com/v2/${alchemyApiKey}`,
                  arbitrum: `https://arb-mainnet.g.alchemy.com/v2/${alchemyApiKey}`,
                  base: `https://base-mainnet.g.alchemy.com/v2/${alchemyApiKey}`,
                  bsc: 'https://bsc-dataseed1.binance.org' // Public BSC RPC (consider paid alternative for production)
                };
                
                const rpcUrl = rpcUrls[selectedChain];
                if (!rpcUrl) {
                  return c.json({ 
                    success: false, 
                    message: `Unsupported chain: ${selectedChain}` 
                  }, 400);
                }
                
                // Get native balance via eth_getBalance
                const response = await fetch(rpcUrl, {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({
                    jsonrpc: '2.0',
                    method: 'eth_getBalance',
                    params: [address, 'latest'],
                    id: 1
                  })
                });
                
                const data = await response.json();
                
                // Check for RPC errors
                if (data.error) {
                  logger?.error('üö® [Tracked Wallets] RPC error', { error: data.error, address, chain: selectedChain });
                  return c.json({ 
                    success: false, 
                    message: `Failed to fetch balance: ${data.error.message || 'RPC error'}` 
                  }, 500);
                }
                
                if (!data.result) {
                  logger?.error('üö® [Tracked Wallets] No result from RPC', { address, chain: selectedChain });
                  return c.json({ 
                    success: false, 
                    message: 'Failed to fetch balance from RPC provider' 
                  }, 500);
                }
                
                // Use BigInt for safe handling of large balances
                const balanceWei = BigInt(data.result);
                const balanceEthBigInt = balanceWei / BigInt(1e15); // Convert to milliETH first
                const balanceEth = Number(balanceEthBigInt) / 1000; // Then to ETH
                
                balance = JSON.stringify({
                  nativeBalance: balanceWei.toString(), // Store as string to preserve precision
                  nativeBalanceFormatted: balanceEth,
                  chain: selectedChain
                });
              }
            } catch (err: any) {
              logger?.warn('Failed to fetch balance, saving wallet anyway', { error: err.message });
            }
            
            // Insert wallet
            const id = randomBytes(16).toString('hex');
            await db.insert(trackedWallets).values({
              id,
              userId,
              address,
              chain: selectedChain,
              nickname: nickname || null,
              balance,
              lastUpdated: new Date(),
              createdAt: new Date()
            });
            
            return c.json({ 
              success: true, 
              message: 'Wallet added',
              wallet: { id, address, chain: selectedChain, nickname, balance: balance ? JSON.parse(balance) : null }
            });
          } catch (error: any) {
            logger?.error('‚ùå [Tracked Wallets] POST error', { error: error.message });
            return c.json({ success: false, message: 'Failed to add wallet' }, 500);
          }
        }
      },
      {
        path: "/api/tracked-wallets/:id",
        method: "DELETE",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          
          const { checkAccessSession } = await import('./middleware/accessControl.js');
          const sessionCheck = await checkAccessSession(c);
          if (!sessionCheck.valid) {
            return c.json({ error: 'Unauthorized' }, 401);
          }
          
          const userId = sessionCheck.userId || 'demo-user';
          const walletId = c.req.param('id');
          logger?.info('üóëÔ∏è [Tracked Wallets] DELETE request', { userId, walletId });
          
          try {
            const { db } = await import('../db/client.js');
            const { trackedWallets } = await import('../db/schema.js');
            const { eq, and } = await import('drizzle-orm');
            
            await db
              .delete(trackedWallets)
              .where(and(
                eq(trackedWallets.id, walletId),
                eq(trackedWallets.userId, userId)
              ));
            
            return c.json({ success: true, message: 'Wallet removed' });
          } catch (error: any) {
            logger?.error('‚ùå [Tracked Wallets] DELETE error', { error: error.message });
            return c.json({ success: false, message: 'Failed to remove wallet' }, 500);
          }
        }
      },
      {
        path: "/api/tracked-wallets/clear",
        method: "DELETE",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          
          const { checkAccessSession } = await import('./middleware/accessControl.js');
          const sessionCheck = await checkAccessSession(c);
          if (!sessionCheck.valid) {
            return c.json({ error: 'Unauthorized' }, 401);
          }
          
          const userId = sessionCheck.userId || 'demo-user';
          logger?.info('üßπ [Tracked Wallets] CLEAR request', { userId });
          
          try {
            const { db } = await import('../db/client.js');
            const { trackedWallets } = await import('../db/schema.js');
            const { eq } = await import('drizzle-orm');
            
            await db
              .delete(trackedWallets)
              .where(eq(trackedWallets.userId, userId));
            
            return c.json({ success: true, message: 'All wallets cleared' });
          } catch (error: any) {
            logger?.error('‚ùå [Tracked Wallets] CLEAR error', { error: error.message });
            return c.json({ success: false, message: 'Failed to clear wallets' }, 500);
          }
        }
      },
      {
        path: "/api/wallet/connect",
        method: "POST",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          try {
            const { address, userId } = await c.req.json();
            logger?.info('üîó [Mini App] Connect wallet', { address, userId });
            
            await walletConnectionTool.execute({
              context: { action: 'connect', walletAddress: address, userId: userId || 'demo-user' },
              mastra,
              runtimeContext: null as any
            });
            
            return c.json({ success: true });
          } catch (error: any) {
            logger?.error('‚ùå [Mini App] Wallet connect error', { error: error.message });
            return c.json({ success: false }, 500);
          }
        },
      },
      {
        path: "/api/wallet/disconnect",
        method: "POST",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          try {
            const { userId } = await c.req.json();
            logger?.info('üîå [Mini App] Disconnect wallet', { userId });
            
            await walletConnectionTool.execute({
              context: { action: 'disconnect', userId: userId || 'demo-user' },
              mastra,
              runtimeContext: null as any
            });
            
            return c.json({ success: true });
          } catch (error: any) {
            logger?.error('‚ùå [Mini App] Wallet disconnect error', { error: error.message });
            return c.json({ success: false }, 500);
          }
        },
      },
      {
        path: "/api/limit-orders",
        method: "GET",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          const userId = c.req.query('userId') || 'demo-user';
          logger?.info('üìã [Mini App] Limit orders request', { userId });
          
          try {
            const result = await jupiterLimitOrderTool.execute({
              context: { action: 'list', userId },
              mastra,
              runtimeContext: null as any
            });
            
            return c.json({
              success: result.success,
              orders: result.orders || []
            });
          } catch (error: any) {
            logger?.error('‚ùå [Mini App] Limit orders error', { error: error.message });
            return c.json({ success: false, orders: [] });
          }
        },
      },
      {
        path: "/api/limit-orders",
        method: "POST",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          try {
            const body = await c.req.json();
            const userId = body.userId || 'demo-user';
            logger?.info('üìù [Mini App] Create limit order', { userId, body });
            
            const result = await jupiterLimitOrderTool.execute({
              context: {
                action: 'create',
                userId,
                orderType: body.orderType,
                ticker: body.ticker,
                targetPrice: body.targetPrice,
                amount: body.amount
              },
              mastra,
              runtimeContext: null as any
            });
            
            return c.json(result);
          } catch (error: any) {
            logger?.error('‚ùå [Mini App] Create limit order error', { error: error.message });
            return c.json({ success: false, message: 'Error creating order' }, 500);
          }
        },
      },
      {
        path: "/api/sniping",
        method: "GET",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          const userId = c.req.query('userId') || 'demo-user';
          logger?.info('üéØ [Mini App] Sniping status request', { userId });
          
          try {
            const result = await tokenSnipingTool.execute({
              context: { action: 'status', userId },
              mastra,
              runtimeContext: null as any
            });
            
            return c.json({
              success: result.success,
              config: result.config || {
                enabled: false,
                minLiquidity: 10000,
                maxRugScore: 30,
                autoExecute: false,
                maxBuyAmount: 0.1,
                targetChains: ['solana']
              }
            });
          } catch (error: any) {
            logger?.error('‚ùå [Mini App] Sniping status error', { error: error.message });
            return c.json({ success: false, config: null });
          }
        },
      },
      {
        path: "/api/sniping",
        method: "POST",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          try {
            const body = await c.req.json();
            const userId = body.userId || 'demo-user';
            logger?.info('üéØ [Mini App] Update sniping config', { userId, config: body.config });
            
            const result = await tokenSnipingTool.execute({
              context: {
                action: 'configure',
                userId,
                config: body.config
              },
              mastra,
              runtimeContext: null as any
            });
            
            return c.json(result);
          } catch (error: any) {
            logger?.error('‚ùå [Mini App] Update sniping error', { error: error.message });
            return c.json({ success: false, message: 'Error updating config' }, 500);
          }
        },
      },
      {
        path: "/api/settings",
        method: "GET",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          const userId = c.req.query('userId') || 'demo-user';
          logger?.info('‚öôÔ∏è [Mini App] Settings request', { userId });
          
          try {
            const result = await userSettingsTool.execute({
              context: { action: 'view', userId },
              mastra,
              runtimeContext: null as any
            });
            
            return c.json({
              alerts: result.settings?.priceAlertsEnabled || false,
              autoMonitor: result.settings?.autoMonitorWatchlist || false,
              sniping: result.settings?.snipingEnabled || false,
              autoExecute: result.settings?.autoExecuteLimitOrders || false,
              scope: result.settings?.assetScope || 'both',
              exchange: result.settings?.defaultExchangeLink || 'dexscreener'
            });
          } catch (error: any) {
            logger?.error('‚ùå [Mini App] Settings error', { error: error.message });
            return c.json({ alerts: false, autoMonitor: false, sniping: false, autoExecute: false, scope: 'both', exchange: 'dexscreener' });
          }
        },
      },
      {
        path: "/api/settings",
        method: "POST",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          try {
            const body = await c.req.json();
            const userId = body.userId || 'demo-user';
            logger?.info('‚öôÔ∏è [Mini App] Update settings', { userId, settings: body });
            
            // Map Mini App settings to tool settings
            const settings: any = {};
            if (body.alerts !== undefined) settings.priceAlertsEnabled = body.alerts;
            if (body.autoMonitor !== undefined) settings.autoMonitorWatchlist = body.autoMonitor;
            if (body.sniping !== undefined) settings.snipingEnabled = body.sniping;
            if (body.autoExecute !== undefined) settings.autoExecuteLimitOrders = body.autoExecute;
            if (body.scope) settings.assetScope = body.scope;
            if (body.exchange) settings.defaultExchangeLink = body.exchange;
            
            await userSettingsTool.execute({
              context: { action: 'update', userId, settings },
              mastra,
              runtimeContext: null as any
            });
            
            return c.json({ success: true });
          } catch (error: any) {
            logger?.error('‚ùå [Mini App] Update settings error', { error: error.message });
            return c.json({ success: false }, 500);
          }
        },
      },
      // Scanner endpoint
      {
        path: "/api/scanner",
        method: "POST",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          try {
            const { type = 'crypto', limit = 20, userId } = await c.req.json();
            logger?.info('üîç [Mini App] Scanner request', { type, limit, userId });
            
            const result = await scannerTool.execute({
              context: { type, limit },
              mastra,
              runtimeContext: null as any
            });
            
            return c.json({
              results: result.strongBuys || [],
              scannedCount: result.scannedCount || 0,
              type: type,
              timestamp: new Date().toISOString()
            });
          } catch (error: any) {
            logger?.error('‚ùå [Mini App] Scanner error', { error: error.message });
            return c.json({ results: [], scannedCount: 0, error: error.message }, 500);
          }
        },
      },
      // Subscription endpoints
      {
        path: "/api/subscription",
        method: "GET",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          const userId = c.req.query('userId') || 'demo-user';
          logger?.info('üí≥ [Mini App] Get subscription status', { userId });
          
          try {
            const result = await subscriptionTool.execute({
              context: { action: 'check_status', userId },
              mastra,
              runtimeContext: null as any
            });
            
            return c.json(result);
          } catch (error: any) {
            logger?.error('‚ùå [Mini App] Subscription status error', { error: error.message });
            return c.json({ success: false, message: error.message }, 500);
          }
        },
      },
      {
        path: "/api/subscription/checkout",
        method: "POST",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          try {
            const { userId } = await c.req.json();
            const returnUrl = `${c.req.header('origin') || 'https://your-app.replit.app'}/mini-app`;
            
            logger?.info('üõí [Mini App] Create checkout session', { userId, returnUrl });
            
            const result = await subscriptionTool.execute({
              context: { action: 'create_checkout', userId: userId || 'demo-user', returnUrl },
              mastra,
              runtimeContext: null as any
            });
            
            return c.json(result);
          } catch (error: any) {
            logger?.error('‚ùå [Mini App] Checkout error', { error: error.message });
            return c.json({ success: false, message: error.message }, 500);
          }
        },
      },
      {
        path: "/api/subscription/cancel",
        method: "POST",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          try {
            const { userId } = await c.req.json();
            logger?.info('‚ùå [Mini App] Cancel subscription', { userId });
            
            const result = await subscriptionTool.execute({
              context: { action: 'cancel', userId: userId || 'demo-user' },
              mastra,
              runtimeContext: null as any
            });
            
            return c.json(result);
          } catch (error: any) {
            logger?.error('‚ùå [Mini App] Cancel error', { error: error.message });
            return c.json({ success: false, message: error.message }, 500);
          }
        },
      },
      {
        path: "/api/stripe/webhook",
        method: "POST",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          const Stripe = await import('stripe');
          const stripe = new Stripe.default(process.env.STRIPE_SECRET_KEY || "");
          const { db } = await import('../db/client.js');
          const { subscriptions } = await import('../db/schema.js');
          const { eq } = await import('drizzle-orm');
          
          try {
            const rawBody = await c.req.text();
            const sig = c.req.header('stripe-signature');
            
            if (!sig) {
              logger?.error('‚ùå [Stripe] No signature provided');
              return c.json({ error: 'No signature' }, 400);
            }
            
            // Verify webhook signature with STRIPE_WEBHOOK_SECRET
            const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET;
            
            if (!webhookSecret) {
              logger?.error('üö® [Stripe] STRIPE_WEBHOOK_SECRET not configured - rejecting webhook for security');
              logger?.error('üîß [Stripe] Set STRIPE_WEBHOOK_SECRET environment variable to enable webhook processing');
              return c.json({ 
                error: 'Webhook secret not configured',
                message: 'Set STRIPE_WEBHOOK_SECRET environment variable' 
              }, 500);
            }
            
            // SECURE: Verify webhook signature
            let event;
            try {
              event = stripe.webhooks.constructEvent(rawBody, sig, webhookSecret);
              logger?.info('‚úÖ [Stripe] Webhook signature verified', { type: event.type });
            } catch (err: any) {
              logger?.error('‚ùå [Stripe] Webhook signature verification failed', { error: err.message });
              return c.json({ error: 'Invalid signature' }, 400);
            }
            
            // Import audit trail service
            const { auditTrailService, AUDIT_EVENT_TYPES, EVENT_CATEGORIES } = await import('../services/auditTrailService.js');
            
            // Handle checkout.session.completed
            if (event.type === 'checkout.session.completed') {
              const session = event.data.object;
              const userId = session.metadata?.telegramUserId;
              const plan = session.metadata?.plan || 'premium'; // Default to premium if not specified
              
              if (!userId) {
                logger?.warn('‚ö†Ô∏è [Stripe] No userId in session metadata');
                return c.json({ received: true });
              }
              
              logger?.info(`üí≥ [Stripe] Activating ${plan} plan for user`, { userId, plan });
              
              // üîó AUDIT TRAIL: Record subscription payment
              try {
                await auditTrailService.logEvent({
                  userId,
                  eventType: AUDIT_EVENT_TYPES.SUBSCRIPTION_STARTED,
                  category: EVENT_CATEGORIES.SUBSCRIPTION,
                  data: {
                    plan,
                    provider: 'stripe',
                    amount: plan === 'premium' ? 500 : 200,
                    currency: 'usd',
                    stripeSessionId: session.id,
                    customerEmail: session.customer_details?.email || null,
                    source: 'stripe_webhook',
                  },
                });
                logger?.info('üîó [Audit] Subscription event recorded to blockchain trail', { userId });
              } catch (auditError: any) {
                logger?.error('‚ùå [Audit] Failed to record subscription event', { error: auditError.message });
              }
              
              // Calculate expiry (1 month from now)
              const expiryDate = new Date();
              expiryDate.setMonth(expiryDate.getMonth() + 1);
              
              // Update or create subscription
              await db.insert(subscriptions).values({
                userId,
                plan: plan as 'basic' | 'premium',
                status: 'active',
                provider: 'stripe',
                stripeCustomerId: session.customer as string,
                stripeSubscriptionId: session.subscription as string,
                expiryDate,
                autoRenew: true,
              }).onConflictDoUpdate({
                target: subscriptions.userId,
                set: {
                  plan: plan as 'basic' | 'premium',
                  status: 'active',
                  provider: 'stripe',
                  stripeCustomerId: session.customer as string,
                  stripeSubscriptionId: session.subscription as string,
                  expiryDate,
                  autoRenew: true,
                  updatedAt: new Date(),
                }
              });
              
              logger?.info(`‚úÖ [Stripe] ${plan.charAt(0).toUpperCase() + plan.slice(1)} plan activated`, { userId, plan });
              
              // üéØ AUTO-WHITELIST: Add customer email to whitelist for unlimited access
              try {
                const customerEmail = session.customer_details?.email || session.customer_email;
                
                if (customerEmail) {
                  const { whitelistedUsers } = await import('../db/schema.js');
                  
                  // Add email to whitelist (auto-grant unlimited access)
                  await db.insert(whitelistedUsers).values({
                    userId: customerEmail, // Use email as userId for easy lookup
                    email: customerEmail,
                    reason: 'Paid subscriber (Stripe)',
                    expiresAt: null, // Never expires (lifetime whitelist for paying customers)
                  }).onConflictDoNothing();
                  
                  logger?.info('‚úÖ [Stripe] Email auto-whitelisted', { email: customerEmail, userId });
                } else {
                  logger?.warn('‚ö†Ô∏è [Stripe] No customer email found in session - skipping auto-whitelist');
                }
              } catch (whitelistError: any) {
                logger?.error('‚ùå [Stripe] Failed to auto-whitelist email', { error: whitelistError.message });
                // Don't fail the webhook if whitelist fails
              }
              
              // üìß Send Email notification to admin
              try {
                const adminEmail = process.env.ADMIN_EMAIL;
                
                if (adminEmail) {
                  const { sendEmail } = await import('../utils/replitmail.js');
                  const htmlContent = `
                    <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
                      <h2 style="color: #4ADE80;">üéâ New Premium Subscriber!</h2>
                      <div style="background: #f5f5f5; padding: 20px; border-radius: 8px; margin: 20px 0;">
                        <p><strong>üë§ User ID:</strong> ${userId}</p>
                        <p><strong>üí≥ Amount:</strong> $6.00/month</p>
                        <p><strong>üìÖ Subscribed:</strong> ${new Date().toLocaleString()}</p>
                        <p><strong>üîÑ Auto-renewal:</strong> Yes</p>
                        <p><strong>‚è∞ Expires:</strong> ${expiryDate.toLocaleDateString()}</p>
                      </div>
                      <p style="color: #4ADE80; font-size: 18px; font-weight: bold;">üí∞ Monthly Revenue +$5</p>
                    </div>
                  `;
                  
                  await sendEmail({
                    to: adminEmail,
                    subject: 'üéâ New DarkWave Premium Subscriber!',
                    html: htmlContent,
                    text: `New Premium Subscriber!\n\nUser ID: ${userId}\nAmount: $6.00/month\nSubscribed: ${new Date().toLocaleString()}\nExpires: ${expiryDate.toLocaleDateString()}\n\nMonthly Revenue +$6`
                  });
                  
                  logger?.info('üìß [Email] Admin notification sent', { userId });
                } else {
                  logger?.debug('‚ö†Ô∏è [Email] Admin notifications not configured (missing ADMIN_EMAIL)');
                }
              } catch (emailError: any) {
                logger?.error('‚ùå [Email] Failed to send admin notification', { error: emailError.message });
                // Don't fail the webhook if email fails
              }
              
              // üìß Send Telegram notification to admin
              try {
                const telegramToken = process.env.TELEGRAM_BOT_TOKEN;
                const adminChatId = process.env.TELEGRAM_ADMIN_CHAT_ID; // Your Telegram chat ID
                
                if (telegramToken && adminChatId) {
                  const axios = await import('axios');
                  const message = `üéâ *New Premium Subscriber!*\n\n` +
                    `üë§ User ID: \`${userId}\`\n` +
                    `üí≥ Amount: $6.00/month\n` +
                    `üìÖ Subscribed: ${new Date().toLocaleString()}\n` +
                    `üîÑ Auto-renewal: Yes\n` +
                    `‚è∞ Expires: ${expiryDate.toLocaleDateString()}\n\n` +
                    `üí∞ Monthly Revenue +$6`;
                  
                  await axios.default.post(`https://api.telegram.org/bot${telegramToken}/sendMessage`, {
                    chat_id: adminChatId,
                    text: message,
                    parse_mode: 'Markdown'
                  });
                  
                  logger?.info('üì± [Telegram] Admin notification sent', { userId });
                } else {
                  logger?.debug('‚ö†Ô∏è [Telegram] Admin notifications not configured (missing TELEGRAM_ADMIN_CHAT_ID)');
                }
              } catch (telegramError: any) {
                logger?.error('‚ùå [Telegram] Failed to send admin notification', { error: telegramError.message });
                // Don't fail the webhook if Telegram fails
              }
            }
            
            // Handle subscription.deleted (cancellation)
            if (event.type === 'customer.subscription.deleted') {
              const subscription = event.data.object;
              const stripeSubId = subscription.id;
              
              logger?.info('‚ùå [Stripe] Subscription cancelled', { stripeSubId });
              
              // Find and update subscription
              const [sub] = await db.select().from(subscriptions).where(eq(subscriptions.stripeSubscriptionId, stripeSubId));
              
              if (sub) {
                await db.update(subscriptions)
                  .set({ status: 'cancelled', autoRenew: false, updatedAt: new Date() })
                  .where(eq(subscriptions.userId, sub.userId));
                
                logger?.info('‚úÖ [Stripe] Subscription status updated', { userId: sub.userId });
                
                // üîó AUDIT TRAIL: Record subscription cancellation
                try {
                  await auditTrailService.logEvent({
                    userId: sub.userId,
                    eventType: AUDIT_EVENT_TYPES.SUBSCRIPTION_CANCELLED,
                    category: EVENT_CATEGORIES.SUBSCRIPTION,
                    data: {
                      plan: sub.plan,
                      provider: 'stripe',
                      stripeSubscriptionId: stripeSubId,
                      source: 'stripe_webhook',
                    },
                  });
                  logger?.info('üîó [Audit] Cancellation event recorded to blockchain trail', { userId: sub.userId });
                } catch (auditError: any) {
                  logger?.error('‚ùå [Audit] Failed to record cancellation event', { error: auditError.message });
                }
                
                // üìß Send Telegram notification to admin about cancellation
                try {
                  const telegramToken = process.env.TELEGRAM_BOT_TOKEN;
                  const adminChatId = process.env.TELEGRAM_ADMIN_CHAT_ID;
                  
                  if (telegramToken && adminChatId) {
                    const axios = await import('axios');
                    const message = `‚ùå *Subscription Cancelled*\n\n` +
                      `üë§ User ID: \`${sub.userId}\`\n` +
                      `üìÖ Cancelled: ${new Date().toLocaleString()}\n` +
                      `üí∏ Monthly Revenue -$5`;
                    
                    await axios.default.post(`https://api.telegram.org/bot${telegramToken}/sendMessage`, {
                      chat_id: adminChatId,
                      text: message,
                      parse_mode: 'Markdown'
                    });
                    
                    logger?.info('üì± [Telegram] Cancellation notification sent', { userId: sub.userId });
                  }
                } catch (telegramError: any) {
                  logger?.error('‚ùå [Telegram] Failed to send cancellation notification', { error: telegramError.message });
                }
              }
            }
            
            return c.json({ received: true });
          } catch (error: any) {
            logger?.error('‚ùå [Stripe] Webhook error', { error: error.message });
            return c.json({ error: 'Webhook processing failed' }, 500);
          }
        },
      },
      // Crypto Payment Endpoint (Coinbase Commerce)
      {
        path: "/api/crypto/create-charge",
        method: "POST",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          try {
            logger?.info('üí∞ [Crypto] Creating payment charge');
            
            // Check access session
            const { checkAccessSession } = await import('./middleware/accessControl.js');
            const sessionCheck = await checkAccessSession(c);
            if (!sessionCheck.valid) {
              return c.json({ error: 'Unauthorized - Invalid or expired session' }, 401);
            }
            
            const { userId } = await c.req.json();
            
            if (!userId) {
              return c.json({ error: 'User ID required' }, 400);
            }
            
            // Get Coinbase Commerce API key from environment
            const apiKey = process.env.COINBASE_COMMERCE_API_KEY;
            if (!apiKey) {
              logger?.error('‚ùå [Crypto] COINBASE_COMMERCE_API_KEY not configured');
              return c.json({ error: 'Crypto payments not configured' }, 500);
            }
            
            // Create charge via Coinbase Commerce API
            const axios = await import('axios');
            const chargeData = {
              name: 'DarkWave-V2 Premium Subscription',
              description: 'Monthly premium subscription ($5/month)',
              local_price: {
                amount: '5.00',
                currency: 'USD'
              },
              pricing_type: 'fixed_price',
              metadata: {
                userId: userId,
                plan: 'premium'
              }
            };
            
            logger?.info('üì§ [Crypto] Sending charge request to Coinbase', { userId });
            
            const response = await axios.default.post(
              'https://api.commerce.coinbase.com/charges',
              chargeData,
              {
                headers: {
                  'Content-Type': 'application/json',
                  'Accept': 'application/json',
                  'X-CC-Api-Key': apiKey,
                  'X-CC-Version': '2018-03-22'
                }
              }
            );
            
            const charge = response.data.data;
            
            logger?.info('‚úÖ [Crypto] Charge created', { chargeId: charge.id, userId });
            
            // Save payment to database
            const db = await import('../db/client.js').then(m => m.db);
            const { cryptoPayments } = await import('../db/schema.js');
            
            const paymentId = `crypto_${Date.now()}_${Math.random().toString(36).substring(7)}`;
            
            await db.insert(cryptoPayments).values({
              id: paymentId,
              userId: userId,
              coinbaseChargeId: charge.id,
              coinbaseChargeCode: charge.code,
              amountUSD: '5.00',
              status: 'pending',
              hostedUrl: charge.hosted_url,
              expiresAt: new Date(charge.expires_at),
              description: 'Premium Subscription',
              metadata: JSON.stringify({ plan: 'premium' }),
              createdAt: new Date(),
              updatedAt: new Date()
            });
            
            logger?.info('üíæ [Crypto] Payment record created', { paymentId, userId });
            
            return c.json({
              success: true,
              chargeId: charge.id,
              hostedUrl: charge.hosted_url,
              expiresAt: charge.expires_at,
              addresses: charge.addresses
            });
            
          } catch (error: any) {
            logger?.error('‚ùå [Crypto] Failed to create charge', { error: error.message, response: error.response?.data });
            return c.json({ error: 'Failed to create crypto payment' }, 500);
          }
        },
      },
      // Crypto Webhook (Coinbase Commerce payment confirmations)
      {
        path: "/api/crypto/webhook",
        method: "POST",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          try {
            logger?.info('üîî [Crypto] Webhook received');
            
            // CRITICAL SECURITY: Verify Coinbase Commerce webhook signature
            const webhookSecret = process.env.COINBASE_WEBHOOK_SECRET;
            if (!webhookSecret) {
              logger?.error('‚ùå [Crypto] COINBASE_WEBHOOK_SECRET not configured');
              return c.json({ error: 'Webhook secret not configured' }, 500);
            }
            
            // Get raw body and signature from headers
            const signature = c.req.header('x-cc-webhook-signature');
            if (!signature) {
              logger?.warn('‚ö†Ô∏è [Crypto] Missing webhook signature header');
              return c.json({ error: 'Missing signature' }, 400);
            }
            
            // Get raw request body (need to read as text for signature verification)
            const rawBody = await c.req.text();
            
            // Verify signature using HMAC-SHA256
            const crypto = await import('crypto');
            const hmac = crypto.createHmac('sha256', webhookSecret);
            hmac.update(rawBody, 'utf8');
            const computedSignature = hmac.digest('hex');
            
            // Timing-safe comparison to prevent timing attacks
            let isValid = false;
            try {
              isValid = crypto.timingSafeEqual(
                Buffer.from(signature),
                Buffer.from(computedSignature)
              );
            } catch (err) {
              // timingSafeEqual throws if buffers have different lengths
              isValid = false;
            }
            
            if (!isValid) {
              logger?.warn('‚ö†Ô∏è [Crypto] Invalid webhook signature', { 
                received: signature.substring(0, 10) + '...',
                computed: computedSignature.substring(0, 10) + '...'
              });
              return c.json({ error: 'Invalid signature' }, 401);
            }
            
            logger?.info('‚úÖ [Crypto] Webhook signature verified');
            
            // Parse the verified request body
            const body = JSON.parse(rawBody);
            const event = body.event;
            
            if (!event) {
              return c.json({ error: 'No event data' }, 400);
            }
            
            logger?.info('üì© [Crypto] Processing event', { type: event.type, chargeId: event.data?.id });
            
            // Handle charge:confirmed event
            if (event.type === 'charge:confirmed') {
              const charge = event.data;
              const chargeId = charge.id;
              const userId = charge.metadata?.userId;
              
              if (!userId) {
                logger?.warn('‚ö†Ô∏è [Crypto] No userId in charge metadata', { chargeId });
                return c.json({ received: true });
              }
              
              logger?.info('‚úÖ [Crypto] Payment confirmed', { chargeId, userId });
              
              // Update payment status
              const db = await import('../db/client.js').then(m => m.db);
              const { cryptoPayments, subscriptions, whitelistedUsers } = await import('../db/schema.js');
              const { eq } = await import('drizzle-orm');
              
              await db.update(cryptoPayments)
                .set({ 
                  status: 'completed',
                  completedAt: new Date(),
                  cryptoCurrency: charge.payments[0]?.network || 'unknown',
                  cryptoAmount: charge.payments[0]?.value?.crypto?.amount || '0',
                  updatedAt: new Date()
                })
                .where(eq(cryptoPayments.coinbaseChargeId, chargeId));
              
              // Grant subscription (30 days)
              const expiryDate = new Date();
              expiryDate.setDate(expiryDate.getDate() + 30);
              
              // Check if subscription exists
              const [existingSub] = await db.select().from(subscriptions).where(eq(subscriptions.userId, userId));
              
              if (existingSub) {
                // Update existing subscription
                await db.update(subscriptions)
                  .set({
                    plan: 'premium',
                    status: 'active',
                    provider: 'crypto',
                    cryptoPaymentId: chargeId,
                    expiryDate: expiryDate,
                    autoRenew: false, // Crypto payments don't auto-renew
                    updatedAt: new Date()
                  })
                  .where(eq(subscriptions.userId, userId));
              } else {
                // Create new subscription
                await db.insert(subscriptions).values({
                  userId: userId,
                  plan: 'premium',
                  status: 'active',
                  provider: 'crypto',
                  cryptoPaymentId: chargeId,
                  expiryDate: expiryDate,
                  autoRenew: false,
                  createdAt: new Date(),
                  updatedAt: new Date()
                });
              }
              
              // Add to whitelist
              const [existingWhitelist] = await db.select().from(whitelistedUsers).where(eq(whitelistedUsers.userId, userId));
              
              if (!existingWhitelist) {
                await db.insert(whitelistedUsers).values({
                  userId: userId,
                  reason: 'Premium subscriber (crypto payment)',
                  expiresAt: expiryDate,
                  createdAt: new Date(),
                  updatedAt: new Date()
                });
              } else {
                await db.update(whitelistedUsers)
                  .set({
                    expiresAt: expiryDate,
                    updatedAt: new Date()
                  })
                  .where(eq(whitelistedUsers.userId, userId));
              }
              
              logger?.info('üéâ [Crypto] Subscription activated', { userId, expiryDate });
              
              // üîó AUDIT TRAIL: Record crypto payment
              try {
                const { auditTrailService, AUDIT_EVENT_TYPES, EVENT_CATEGORIES } = await import('../services/auditTrailService.js');
                await auditTrailService.logEvent({
                  userId,
                  eventType: AUDIT_EVENT_TYPES.PAYMENT_COMPLETED,
                  category: EVENT_CATEGORIES.PAYMENT,
                  data: {
                    plan: 'premium',
                    provider: 'crypto',
                    chargeId: chargeId,
                    cryptoCurrency: charge.payments[0]?.network || 'unknown',
                    cryptoAmount: charge.payments[0]?.value?.crypto?.amount || '0',
                    usdAmount: 600,
                    source: 'coinbase_webhook',
                  },
                });
                logger?.info('üîó [Audit] Crypto payment recorded to blockchain trail', { userId });
              } catch (auditError: any) {
                logger?.error('‚ùå [Audit] Failed to record crypto payment', { error: auditError.message });
              }
              
              // Send admin notification
              try {
                const telegramToken = process.env.TELEGRAM_BOT_TOKEN;
                const adminChatId = process.env.TELEGRAM_ADMIN_CHAT_ID;
                
                if (telegramToken && adminChatId) {
                  const axios = await import('axios');
                  const cryptoCurrency = charge.payments[0]?.network || 'Unknown';
                  const cryptoAmount = charge.payments[0]?.value?.crypto?.amount || '0';
                  
                  const message = `üíé *New Crypto Payment!*\n\n` +
                    `üë§ User ID: \`${userId}\`\n` +
                    `üí∞ Amount: $6.00 (${cryptoAmount} ${cryptoCurrency})\n` +
                    `üìÖ Subscribed: ${new Date().toLocaleString()}\n` +
                    `üîÑ Auto-renewal: No (Manual crypto payment)\n` +
                    `‚è∞ Expires: ${expiryDate.toLocaleDateString()}\n\n` +
                    `üíµ Monthly Revenue +$6`;
                  
                  await axios.default.post(`https://api.telegram.org/bot${telegramToken}/sendMessage`, {
                    chat_id: adminChatId,
                    text: message,
                    parse_mode: 'Markdown'
                  });
                  
                  logger?.info('üì± [Telegram] Crypto payment notification sent', { userId });
                }
              } catch (telegramError: any) {
                logger?.error('‚ùå [Telegram] Failed to send crypto notification', { error: telegramError.message });
              }
            }
            
            return c.json({ received: true });
            
          } catch (error: any) {
            logger?.error('‚ùå [Crypto] Webhook error', { error: error.message });
            return c.json({ error: 'Webhook processing failed' }, 500);
          }
        },
      },
      // Feedback & Token Submission endpoint
      {
        path: "/api/submit-feedback",
        method: "POST",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          try {
            // Check access session
            const { checkAccessSession } = await import('./middleware/accessControl.js');
            const sessionCheck = await checkAccessSession(c);
            if (!sessionCheck.valid) {
              return c.json({ error: 'Unauthorized - Invalid or expired session' }, 401);
            }
            
            const body = await c.req.json();
            const { 
              type, userId, suggestion, tokenName, tokenSymbol, tokenContract, tokenChain, tokenDescription, tokenContact, tokenLogo,
              // Social Links
              website, twitter, telegram, discord,
              // Documentation
              whitepaper, tokenomics, auditReport,
              // Project Qualifiers
              hasWhitepaper, hasAudit, isDoxxedTeam, hasLockedLiquidity
            } = body;
            
            logger?.info('üí¨ [Feedback] Received submission', { type, userId, hasImage: !!tokenLogo, hasDocs: !!(whitepaper || tokenomics || auditReport) });
            
            // SERVER-SIDE FILE VALIDATION: Validate uploaded files to prevent abuse
            const validateFile = (file: any, maxSizeMB: number, allowedTypes: string[], fileLabel: string) => {
              if (!file) return null;
              
              // Validate structure
              if (!file.data || typeof file.data !== 'string') {
                throw new Error(`${fileLabel}: Invalid file structure`);
              }
              
              // Validate base64 data URI format and EXTRACT actual MIME type from data URI
              if (!file.data.startsWith('data:')) {
                throw new Error(`${fileLabel}: Invalid base64 format - must be a data URI`);
              }
              
              // Extract MIME type from the data URI itself (not the client-supplied mimeType field)
              const dataUriMatch = file.data.match(/^data:([^;]+);base64,/);
              if (!dataUriMatch) {
                throw new Error(`${fileLabel}: Invalid data URI format`);
              }
              
              const actualMimeType = dataUriMatch[1].toLowerCase();
              
              // Validate MIME type against allowed types (using EXTRACTED type, not client claim)
              const normalizedAllowedTypes = allowedTypes.map(t => t.toLowerCase());
              if (!normalizedAllowedTypes.includes(actualMimeType)) {
                throw new Error(`${fileLabel}: Invalid file type '${actualMimeType}'. Allowed: ${allowedTypes.join(', ')}`);
              }
              
              // Extract and validate base64 payload
              const base64Data = file.data.split(',')[1];
              if (!base64Data) {
                throw new Error(`${fileLabel}: Missing base64 data`);
              }
              
              // Attempt to decode base64 to verify it's valid
              let buffer: Buffer;
              try {
                buffer = Buffer.from(base64Data, 'base64');
              } catch (decodeError) {
                throw new Error(`${fileLabel}: Invalid base64 encoding`);
              }
              
              // MAGIC BYTE VALIDATION: Verify actual file content matches declared MIME type
              const verifyFileSignature = (buf: Buffer, mimeType: string): boolean => {
                // PDF signature: %PDF- (25 50 44 46 2D)
                if (mimeType === 'application/pdf') {
                  return buf.slice(0, 4).toString() === '%PDF';
                }
                
                // PNG signature: 89 50 4E 47 0D 0A 1A 0A
                if (mimeType === 'image/png') {
                  return buf[0] === 0x89 && buf[1] === 0x50 && buf[2] === 0x4E && buf[3] === 0x47;
                }
                
                // JPEG signature: FF D8 FF
                if (mimeType === 'image/jpeg' || mimeType === 'image/jpg') {
                  return buf[0] === 0xFF && buf[1] === 0xD8 && buf[2] === 0xFF;
                }
                
                // GIF signature: GIF87a or GIF89a
                if (mimeType === 'image/gif') {
                  const sig = buf.slice(0, 6).toString();
                  return sig === 'GIF87a' || sig === 'GIF89a';
                }
                
                // WEBP signature: RIFF....WEBP
                if (mimeType === 'image/webp') {
                  return buf.slice(0, 4).toString() === 'RIFF' && buf.slice(8, 12).toString() === 'WEBP';
                }
                
                return false;
              };
              
              if (!verifyFileSignature(buffer, actualMimeType)) {
                throw new Error(`${fileLabel}: File content does not match declared type '${actualMimeType}'. File may be corrupted or malicious.`);
              }
              
              // Calculate actual file size
              const sizeInBytes = buffer.length;
              const sizeInMB = sizeInBytes / (1024 * 1024);
              
              if (sizeInMB > maxSizeMB) {
                throw new Error(`${fileLabel}: File too large (${sizeInMB.toFixed(2)}MB). Max: ${maxSizeMB}MB`);
              }
              
              logger?.info(`‚úÖ [Validation] ${fileLabel} passed all checks`, { sizeInMB: sizeInMB.toFixed(2), mimeType: actualMimeType, signatureVerified: true });
              return file;
            };
            
            // Validate all uploaded files
            if (type === 'token') {
              try {
                // Validate logo (max 2MB, image only)
                if (tokenLogo) {
                  validateFile(tokenLogo, 2, ['image/png', 'image/jpeg', 'image/jpg', 'image/gif', 'image/webp'], 'Token Logo');
                }
                
                // Validate documents (max 5MB, PDF only)
                if (whitepaper) {
                  validateFile(whitepaper, 5, ['application/pdf'], 'Whitepaper');
                }
                if (tokenomics) {
                  validateFile(tokenomics, 5, ['application/pdf'], 'Tokenomics');
                }
                if (auditReport) {
                  validateFile(auditReport, 5, ['application/pdf'], 'Audit Report');
                }
              } catch (validationError: any) {
                logger?.warn('‚ö†Ô∏è [Validation] File validation failed', { error: validationError.message, userId });
                return c.json({ error: validationError.message }, 400);
              }
            }
            
            // Get admin email from environment
            const adminEmail = process.env.ADMIN_EMAIL;
            if (!adminEmail) {
              logger?.error('‚ùå [Feedback] ADMIN_EMAIL not configured');
              return c.json({ error: 'Admin email not configured' }, 500);
            }
            
            let subject, htmlContent, textContent;
            
            if (type === 'suggestion') {
              subject = 'üí° New User Suggestion - DarkWave-V2';
              htmlContent = `
                <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
                  <h2 style="color: #A855F7;">üí° New User Suggestion</h2>
                  <div style="background: #f5f5f5; padding: 20px; border-radius: 8px; margin: 20px 0;">
                    <p><strong>üë§ User ID:</strong> ${userId}</p>
                    <p><strong>üìÖ Submitted:</strong> ${new Date().toLocaleString()}</p>
                  </div>
                  <div style="background: #fff; border-left: 4px solid #A855F7; padding: 20px; margin: 20px 0;">
                    <h3 style="margin-top: 0; color: #333;">Suggestion:</h3>
                    <p style="color: #555; white-space: pre-wrap;">${suggestion}</p>
                  </div>
                  <p style="color: #999; font-size: 0.9rem;">Sent from DarkWave-V2 Feedback System</p>
                </div>
              `;
              textContent = `New User Suggestion\n\nUser ID: ${userId}\nSubmitted: ${new Date().toLocaleString()}\n\nSuggestion:\n${suggestion}`;
            } else if (type === 'token') {
              subject = 'üöÄ New Token Submission - DarkWave-V2';
              
              // Include token logo in email if provided
              const logoHtml = tokenLogo ? `
                <div style="text-align: center; margin: 20px 0;">
                  <img src="${tokenLogo.data}" alt="Token Logo" style="max-width: 150px; max-height: 150px; border-radius: 50%; border: 3px solid #4ADE80; box-shadow: 0 4px 12px rgba(74, 222, 128, 0.3);">
                  <p style="color: #4ADE80; font-size: 0.9rem; margin-top: 10px;">üì∑ Token Logo Attached</p>
                </div>
              ` : '';
              
              htmlContent = `
                <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
                  <h2 style="color: #4ADE80;">üöÄ New Token Submission</h2>
                  <div style="background: #f5f5f5; padding: 20px; border-radius: 8px; margin: 20px 0;">
                    <p><strong>üë§ Submitted by:</strong> ${userId}</p>
                    <p><strong>üìÖ Submitted:</strong> ${new Date().toLocaleString()}</p>
                  </div>
                  ${logoHtml}
                  <div style="background: #fff; border-left: 4px solid #4ADE80; padding: 20px; margin: 20px 0;">
                    <h3 style="margin-top: 0; color: #333;">Token Details:</h3>
                    <p><strong>Name:</strong> ${tokenName}</p>
                    <p><strong>Symbol:</strong> ${tokenSymbol}</p>
                    <p><strong>Contract:</strong> <code style="background: #f0f0f0; padding: 4px 8px; border-radius: 4px;">${tokenContract}</code></p>
                    <p><strong>Blockchain:</strong> ${tokenChain}</p>
                    <p><strong>Contact:</strong> ${tokenContact}</p>
                  </div>
                  <div style="background: #fff; border-left: 4px solid #4ADE80; padding: 20px; margin: 20px 0;">
                    <h3 style="margin-top: 0; color: #333;">Why List This Token:</h3>
                    <p style="color: #555; white-space: pre-wrap;">${tokenDescription}</p>
                  </div>
                  <p style="color: #999; font-size: 0.9rem;">Sent from DarkWave-V2 Feedback System</p>
                </div>
              `;
              textContent = `New Token Submission\n\nSubmitted by: ${userId}\nSubmitted: ${new Date().toLocaleString()}\n\nToken Details:\nName: ${tokenName}\nSymbol: ${tokenSymbol}\nContract: ${tokenContract}\nBlockchain: ${tokenChain}\nContact: ${tokenContact}\n${tokenLogo ? '\nToken Logo: Included (see email attachment)\n' : ''}\nWhy List This Token:\n${tokenDescription}`;
            } else {
              return c.json({ error: 'Invalid submission type' }, 400);
            }
            
            // Save token submission to database (for admin approval)
            if (type === 'token') {
              try {
                const { db } = await import('../db/client.js');
                const { tokenSubmissions } = await import('../db/schema.js');
                const submissionId = `sub_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                
                await db.insert(tokenSubmissions).values({
                  id: submissionId,
                  tokenName,
                  tokenSymbol,
                  tokenContract,
                  tokenChain,
                  tokenDescription,
                  tokenContact: tokenContact || 'Not provided',
                  tokenLogo: tokenLogo?.data || null,
                  
                  // Social Links
                  website: website || null,
                  twitter: twitter || null,
                  telegram: telegram || null,
                  discord: discord || null,
                  
                  // Documentation
                  whitepaper: whitepaper?.data || null,
                  tokenomics: tokenomics?.data || null,
                  auditReport: auditReport?.data || null,
                  
                  // Project Qualifiers
                  hasWhitepaper: hasWhitepaper || false,
                  hasAudit: hasAudit || false,
                  isDoxxedTeam: isDoxxedTeam || false,
                  hasLockedLiquidity: hasLockedLiquidity || false,
                  
                  status: 'pending',
                  submittedBy: userId,
                });
                
                logger?.info('‚úÖ [Feedback] Token submission saved to database', { submissionId });
              } catch (dbError: any) {
                logger?.error('‚ùå [Feedback] Failed to save to database', { error: dbError.message });
              }
            }
            
            // Send email to admin
            try {
              const { sendEmail } = await import('../utils/replitmail.js');
              await sendEmail({
                to: adminEmail,
                subject,
                html: htmlContent,
                text: textContent
              });
              
              logger?.info('‚úÖ [Feedback] Email sent to admin', { type, adminEmail });
            } catch (emailError: any) {
              logger?.error('‚ùå [Feedback] Failed to send email', { error: emailError.message });
              return c.json({ error: 'Failed to send email' }, 500);
            }
            
            return c.json({ success: true, message: 'Submission sent successfully' });
          } catch (error: any) {
            logger?.error('‚ùå [Feedback] Submission error', { error: error.message });
            return c.json({ error: 'Failed to process submission' }, 500);
          }
        },
      },
      // Chart endpoint - Returns time-series data for LightweightCharts
      {
        path: "/api/chart",
        method: "POST",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          try {
            const { ticker, timeframe, type } = await c.req.json();
            logger?.info('üìà [Chart API] Chart data request', { ticker, timeframe, type });
            
            // Get market data
            const days = timeframe === '1W' ? 7 : timeframe === '1M' ? 30 : timeframe === '3M' ? 90 : 1;
            const marketData = await marketDataTool.execute({
              context: { ticker, days: Math.max(days, 200) }, // Need 200 days for EMA 200 calculation
              mastra,
              runtimeContext: null as any
            });
            
            const { EMA, SMA, BollingerBands } = await import('technicalindicators');
            const prices = marketData.prices || [];
            
            if (prices.length < 50) {
              return c.json({ 
                success: false, 
                error: 'Insufficient price data for indicators'
              }, 400);
            }
            
            const closePrices = prices.map((p: any) => p.close);
            
            // Calculate full time-series for each indicator
            const ema9Values = EMA.calculate({ period: 9, values: closePrices });
            const ema21Values = EMA.calculate({ period: 21, values: closePrices });
            const ema50Values = EMA.calculate({ period: 50, values: closePrices });
            const ema200Values = EMA.calculate({ period: 200, values: closePrices });
            const sma50Values = SMA.calculate({ period: 50, values: closePrices });
            const sma200Values = SMA.calculate({ period: 200, values: closePrices });
            const bbValues = BollingerBands.calculate({ period: 20, values: closePrices, stdDev: 2 });
            
            // Convert to LightweightCharts format: {time: timestamp, value: number}
            // EMAs/SMAs have warm-up periods, so align timestamps
            const formatSeries = (values: number[], warmupPeriod: number) => {
              return values.map((val, idx) => ({
                time: prices[idx + warmupPeriod].timestamp,
                value: val
              }));
            };
            
            const chartData = {
              prices: prices.slice(-days).map((p: any) => ({
                time: p.timestamp,
                open: p.open || p.close,
                high: p.high || p.close,
                low: p.low || p.close,
                close: p.close
              })),
              ema9: formatSeries(ema9Values, 8),
              ema21: formatSeries(ema21Values, 20),
              ema50: formatSeries(ema50Values, 49),
              ema200: formatSeries(ema200Values, 199),
              sma50: formatSeries(sma50Values, 49),
              sma200: formatSeries(sma200Values, 199),
              bollingerUpper: bbValues.map((bb: any, idx) => ({
                time: prices[idx + 19].timestamp,
                value: bb.upper
              })),
              bollingerLower: bbValues.map((bb: any, idx) => ({
                time: prices[idx + 19].timestamp,
                value: bb.lower
              }))
            };
            
            logger?.info('‚úÖ [Chart API] Chart data prepared', { 
              ticker, 
              pricePoints: chartData.prices.length,
              ema9Points: chartData.ema9.length 
            });
            
            return c.json({ success: true, chartData });
          } catch (error: any) {
            logger?.error('‚ùå [Chart API] Error', { error: error.message });
            return c.json({ success: false, error: error.message }, 500);
          }
        },
      },
      // Multi-Timeframe Analysis endpoint
      {
        path: "/api/multi-timeframe",
        method: "POST",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          try {
            // Check access session
            const { checkAccessSession } = await import('./middleware/accessControl.js');
            const sessionCheck = await checkAccessSession(c);
            if (!sessionCheck.valid) {
              return c.json({ error: 'Unauthorized - Invalid or expired session' }, 401);
            }
            
            const { ticker, userId } = await c.req.json();
            logger?.info('üìä [Mini App] Multi-timeframe analysis request', { ticker, userId });
            
            // Fetch data for different timeframes
            const timeframes = [
              { name: '1H', days: 0.05 }, // ~1 hour of data
              { name: '4H', days: 0.2 },  // ~4 hours
              { name: '1D', days: 1 },     // 1 day
              { name: '1W', days: 7 },     // 1 week
              { name: '1M', days: 30 },    // 1 month
            ];
            
            const results = await Promise.all(
              timeframes.map(async (tf) => {
                try {
                  const marketData = await marketDataTool.execute({
                    context: { ticker, days: tf.days < 1 ? 1 : tf.days }, // Minimum 1 day
                    mastra,
                    runtimeContext: null as any
                  });
                  
                  if (!marketData || !marketData.prices || marketData.prices.length === 0) {
                    return {
                      timeframe: tf.name,
                      trend: 'UNKNOWN',
                      strength: 0,
                      price: 0,
                      change: 0
                    };
                  }
                  
                  // Get appropriate data slice for timeframe
                  let dataSlice = marketData.prices;
                  if (tf.days < 1) {
                    // For hour-based timeframes, use last portion of the day's data
                    const sliceSize = Math.floor(marketData.prices.length * tf.days);
                    dataSlice = marketData.prices.slice(-Math.max(sliceSize, 10));
                  }
                  
                  const analysis = await technicalAnalysisTool.execute({
                    context: { 
                      ticker,
                      prices: dataSlice,
                      currentPrice: marketData.currentPrice,
                      priceChange24h: marketData.priceChange24h,
                      priceChangePercent24h: marketData.priceChangePercent24h
                    },
                    mastra,
                    runtimeContext: null as any
                  });
                  
                  // Determine trend based on signals
                  let trend = 'NEUTRAL';
                  if (analysis.signalCount.bullish > analysis.signalCount.bearish + 2) {
                    trend = 'BULLISH';
                  } else if (analysis.signalCount.bearish > analysis.signalCount.bullish + 2) {
                    trend = 'BEARISH';
                  }
                  
                  const strength = Math.abs(analysis.signalCount.bullish - analysis.signalCount.bearish);
                  
                  return {
                    timeframe: tf.name,
                    trend,
                    strength,
                    price: analysis.currentPrice,
                    change: analysis.priceChangePercent24h,
                    rsi: analysis.rsi,
                    recommendation: analysis.recommendation
                  };
                } catch (error: any) {
                  logger?.error(`Error analyzing ${tf.name} timeframe`, { error: error.message });
                  return {
                    timeframe: tf.name,
                    trend: 'ERROR',
                    strength: 0,
                    price: 0,
                    change: 0
                  };
                }
              })
            );
            
            return c.json({
              ticker: ticker.toUpperCase(),
              timeframes: results,
              success: true
            });
          } catch (error: any) {
            logger?.error('‚ùå [Mini App] Multi-timeframe error', { error: error.message });
            return c.json({ success: false, error: error.message }, 500);
          }
        },
      },
      // DEX Search endpoint
      {
        path: "/api/dex-search",
        method: "POST",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          
          // Check access session
          const { checkAccessSession } = await import('./middleware/accessControl.js');
          const sessionCheck = await checkAccessSession(c);
          if (!sessionCheck.valid) {
            logger?.warn('üö´ [Access Control] Unauthorized DEX search request');
            return sessionCheck.error;
          }
          
          try {
            const { query, userId } = await c.req.json();
            logger?.info('üîç [Mini App] DEX search request', { query, userId });
            
            const result = await dexscreenerTool.execute({
              context: { query },
              mastra,
              runtimeContext: null as any
            });
            
            // dexscreenerTool returns a single pair object, not an array
            return c.json({
              pair: result.success ? result : null,
              success: result.success || false,
              query: query
            });
          } catch (error: any) {
            logger?.error('‚ùå [Mini App] DEX search error', { error: error.message });
            return c.json({ pair: null, success: false, query: '', error: error.message }, 500);
          }
        },
      },
      // DEX Analysis endpoint
      {
        path: "/api/dex-analyze",
        method: "POST",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          
          // Check access session
          const { checkAccessSession } = await import('./middleware/accessControl.js');
          const sessionCheck = await checkAccessSession(c);
          if (!sessionCheck.valid) {
            logger?.warn('üö´ [Access Control] Unauthorized DEX analyze request');
            return sessionCheck.error;
          }
          
          try {
            const { query, userId } = await c.req.json();
            logger?.info('üìä [Mini App] DEX analysis request', { query, userId });
            
            // First search for the DEX pair
            const searchResult = await dexscreenerTool.execute({
              context: { query },
              mastra,
              runtimeContext: null as any
            });
            
            if (!searchResult.success) {
              return c.json({ error: 'Pair not found', success: false }, 404);
            }
            
            // Then analyze it
            const analysisResult = await dexAnalysisTool.execute({
              context: {
                ticker: searchResult.ticker,
                name: searchResult.name,
                chain: searchResult.chain,
                dex: searchResult.dex,
                currentPrice: searchResult.currentPrice,
                priceChange24h: searchResult.priceChange24h,
                priceChangePercent24h: searchResult.priceChangePercent24h,
                priceChange6h: searchResult.priceChange6h,
                priceChangePercent6h: searchResult.priceChangePercent6h,
                volume24h: searchResult.volume24h,
                volume6h: searchResult.volume6h,
                liquidity: searchResult.liquidity,
                marketCap: searchResult.marketCap,
                txns24h: searchResult.txns24h,
                priceHistory: searchResult.priceHistory || []
              },
              mastra,
              runtimeContext: null as any
            });
            
            return c.json(analysisResult);
          } catch (error: any) {
            logger?.error('‚ùå [Mini App] DEX analysis error', { error: error.message });
            return c.json({ error: error.message, success: false }, 500);
          }
        },
      },
      // NFT Analysis endpoint
      {
        path: "/api/nft-analyze",
        method: "POST",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          
          // Check access session
          const { checkAccessSession } = await import('./middleware/accessControl.js');
          const sessionCheck = await checkAccessSession(c);
          if (!sessionCheck.valid) {
            logger?.warn('üö´ [Access Control] Unauthorized NFT analyze request');
            return sessionCheck.error;
          }
          
          try {
            const { query, userId } = await c.req.json();
            logger?.info('üé® [Mini App] NFT analysis request', { query, userId });
            
            // Check subscription limits (pass session token for email whitelist check)
            const sessionToken = c.req.header('X-Session-Token');
            const { checkSubscriptionLimit } = await import('./middleware/subscriptionCheck.js');
            const limitCheck = await checkSubscriptionLimit(userId || 'demo-user', 'search', sessionToken);
            
            if (!limitCheck.allowed) {
              logger?.warn('üö´ [Mini App] NFT search limit exceeded', { userId });
              return c.json({ 
                error: limitCheck.message,
                upgradeRequired: true
              }, 402);
            }
            
            const result = await nftTool.execute({
              context: { query },
              mastra,
              runtimeContext: null as any
            });
            
            return c.json(result);
          } catch (error: any) {
            logger?.error('‚ùå [Mini App] NFT analysis error', { error: error.message });
            return c.json({ error: error.message, success: false }, 500);
          }
        },
      },
      // Download DarkWave banner image for Telegram
      {
        path: "/telegram-banner.png",
        method: "GET",
        createHandler: async () => async (c: any) => {
          const fs = await import('fs/promises');
          const path = await import('path');
          
          // Try multiple paths for dev vs deployment - serve JPEG version (Telegram compliant)
          const possiblePaths = [
            path.join(process.cwd(), '.mastra', 'output', 'public', 'darkwave-banner.jpg'),
            path.join(process.cwd(), 'public', 'darkwave-banner.jpg'),
            path.resolve(process.cwd(), '../..', 'public', 'darkwave-banner.jpg'),
          ];
          
          for (const filePath of possiblePaths) {
            try {
              const imageBuffer = await fs.readFile(filePath);
              c.header('Content-Type', 'image/jpeg');
              c.header('Content-Disposition', 'attachment; filename="darkwave-telegram-banner.jpg"');
              c.header('Cache-Control', 'public, max-age=31536000');
              return c.body(imageBuffer);
            } catch (error) {
              continue;
            }
          }
          
          return c.text('Image not found. Tried paths: ' + possiblePaths.join(', '), 404);
        },
      },
      // Simple download page for the banner
      {
        path: "/download-banner",
        method: "GET",
        createHandler: async () => async (c: any) => {
          const html = `
<!DOCTYPE html>
<html>
<head>
  <title>Download DarkWave Banner</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #0F172A 0%, #1E293B 100%);
      color: white;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      margin: 0;
      padding: 20px;
    }
    .container {
      text-align: center;
      max-width: 700px;
    }
    h1 {
      color: #A855F7;
      margin-bottom: 30px;
    }
    .banner-preview {
      width: 100%;
      max-width: 640px;
      border: 2px solid #A855F7;
      border-radius: 12px;
      margin: 20px 0;
      box-shadow: 0 8px 32px rgba(168, 85, 247, 0.3);
    }
    .download-btn {
      display: inline-block;
      background: linear-gradient(135deg, #E63946, #A855F7);
      color: white;
      padding: 15px 40px;
      border-radius: 8px;
      text-decoration: none;
      font-size: 18px;
      font-weight: bold;
      margin: 20px 0;
      transition: transform 0.2s;
    }
    .download-btn:hover {
      transform: scale(1.05);
    }
    .instructions {
      margin-top: 30px;
      padding: 20px;
      background: rgba(255,255,255,0.05);
      border-radius: 8px;
      text-align: left;
    }
    .instructions h3 {
      color: #A855F7;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>üåä DarkWave Banner Download</h1>
    <p>Your Telegram Mini App banner is ready!</p>
    
    <img src="/telegram-banner.png" class="banner-preview" alt="DarkWave Banner">
    
    <a href="/telegram-banner.png" download="darkwave-telegram-banner.jpg" class="download-btn">
      ‚¨áÔ∏è Download Banner (640√ó360 JPEG)
    </a>
    
    <p style="color: #4ADE80; margin-top: 10px; font-size: 0.9rem;">‚úÖ Optimized for Telegram (640√ó360px, 46KB)</p>
    
    <div class="instructions">
      <h3>üìã How to Use This Banner:</h3>
      <ol>
        <li>Tap the "Download Banner" button above</li>
        <li>The image will save to your device</li>
        <li>Open Telegram and find @BotFather</li>
        <li>Send command: <code>/newapp</code></li>
        <li>Choose your bot: <code>@Darkwave_RSI_Bot</code></li>
        <li>Upload the banner image you just downloaded</li>
        <li>Follow the prompts to complete setup</li>
      </ol>
    </div>
  </div>
</body>
</html>
          `;
          return c.html(html);
        },
      },
      // Mini App static files - Helper to resolve public files in both dev and deployment
      {
        path: "/mini-app",
        method: "GET",
        createHandler: async () => async (c: any) => {
          const fs = await import('fs/promises');
          const path = await import('path');
          
          // Try multiple paths for dev vs deployment
          const possiblePaths = [
            path.join(process.cwd(), '.mastra', 'output', 'public', 'index.html'),
            path.join(process.cwd(), 'public', 'index.html'),
            path.resolve(process.cwd(), '../..', 'public', 'index.html'),
          ];
          
          for (const filePath of possiblePaths) {
            try {
              const html = await fs.readFile(filePath, 'utf-8');
              return c.html(html);
            } catch (err) {
              continue;
            }
          }
          
          return c.text('Mini App not found', 404);
        },
      },
      {
        path: "/mini-app/styles.css",
        method: "GET",
        createHandler: async () => async (c: any) => {
          const fs = await import('fs/promises');
          const path = await import('path');
          
          const possiblePaths = [
            path.join(process.cwd(), '.mastra', 'output', 'public', 'styles.css'),
            path.join(process.cwd(), 'public', 'styles.css'),
            path.resolve(process.cwd(), '../..', 'public', 'styles.css'),
          ];
          
          for (const filePath of possiblePaths) {
            try {
              const css = await fs.readFile(filePath, 'utf-8');
              c.header('Content-Type', 'text/css');
              return c.body(css);
            } catch (err) {
              continue;
            }
          }
          
          return c.text('CSS not found', 404);
        },
      },
      {
        path: "/mini-app/app.js",
        method: "GET",
        createHandler: async () => async (c: any) => {
          const fs = await import('fs/promises');
          const path = await import('path');
          
          const possiblePaths = [
            path.join(process.cwd(), '.mastra', 'output', 'public', 'app.js'),
            path.join(process.cwd(), 'public', 'app.js'),
            path.resolve(process.cwd(), '../..', 'public', 'app.js'),
          ];
          
          for (const filePath of possiblePaths) {
            try {
              const js = await fs.readFile(filePath, 'utf-8');
              c.header('Content-Type', 'application/javascript');
              return c.body(js);
            } catch (err) {
              continue;
            }
          }
          
          return c.text('JavaScript not found', 404);
        },
      },
      // CoinCap Market API - Serves coin market data from CoinGecko
      {
        path: "/api/coincap/market/:coinId",
        method: "GET",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          const coinId = c.req.param('coinId');
          
          try {
            const axios = await import('axios');
            const response = await axios.default.get(
              `https://api.coingecko.com/api/v3/simple/price?ids=${coinId}&vs_currencies=usd&include_market_cap=true&include_24hr_vol=true&include_market_cap_change_percentage_24h_in=usd`
            );
            
            const data = response.data[coinId];
            if (!data) {
              return c.json({ error: 'Coin not found' }, 404);
            }
            
            // Format response for frontend
            const result = {
              name: coinId,
              symbol: coinId.toUpperCase(),
              price: data.usd || 0,
              change24h: data.usd_24h_change || 0,
              marketCap: data.usd_market_cap || 0,
              volume24h: data.usd_24h_vol || 0
            };
            
            return c.json(result);
          } catch (error: any) {
            logger?.error('Failed to fetch market data:', { coinId, error: error.message });
            return c.json({ error: 'Failed to fetch market data' }, 500);
          }
        },
      },
      // CoinCap History API - Serves historical price data
      {
        path: "/api/coincap/history/:coinId",
        method: "GET",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          const coinId = c.req.param('coinId');
          const interval = c.req.query('interval') || '1d';
          const limit = parseInt(c.req.query('limit') || '730');
          
          try {
            const axios = await import('axios');
            
            // Map CoinGecko intervals
            const daysMap: Record<string, number> = {
              '1m': 1,
              '5m': 1,
              '1h': 1,
              '6h': 1,
              '1d': 365,
              '1w': 365,
              '30d': 30,
              '1y': 365,
              'all': 730
            };
            
            const days = daysMap[interval] || 365;
            const response = await axios.default.get(
              `https://api.coingecko.com/api/v3/coins/${coinId}/market_chart?vs_currency=usd&days=${days}`
            );
            
            const prices = response.data.prices || [];
            
            // Convert to candlestick format (OHLCV)
            const candles = prices.slice(-limit).map((price: any, index: number) => ({
              date: new Date(price[0]),
              open: price[1],
              high: price[1] * 1.02, // Approximate
              low: price[1] * 0.98,  // Approximate
              close: price[1],
              volume: 0
            }));
            
            return c.json(candles);
          } catch (error: any) {
            logger?.error('Failed to fetch historical data:', { coinId, error: error.message });
            return c.json({ error: 'Failed to fetch historical data' }, 500);
          }
        },
      },
      // CoinCap ATH API - Serves all-time high data
      {
        path: "/api/coincap/ath/:coinId",
        method: "GET",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          const coinId = c.req.param('coinId');
          
          try {
            const axios = await import('axios');
            const response = await axios.default.get(
              `https://api.coingecko.com/api/v3/coins/${coinId}?localization=false`
            );
            
            const data = response.data;
            const result = {
              ath: data.market_data?.ath?.usd || 0,
              athChangePercentage: data.market_data?.ath_change_percentage?.usd || 0,
              athDate: data.market_data?.ath_date?.usd || null
            };
            
            return c.json(result);
          } catch (error: any) {
            logger?.error('Failed to fetch ATH data:', { coinId, error: error.message });
            return c.json(null); // Return null on error
          }
        },
      },
      // ============================================
      // AUDIT TRAIL & HALLMARK API ROUTES
      // ============================================
      
      // Get user's audit trail
      {
        path: "/api/audit-trail",
        method: "GET",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          try {
            const { checkAccessSession } = await import('./middleware/accessControl.js');
            const sessionCheck = await checkAccessSession(c);
            if (!sessionCheck.valid) {
              return c.json({ error: 'Unauthorized' }, 401);
            }
            
            const userId = sessionCheck.userId || c.req.query('userId');
            if (!userId) {
              return c.json({ error: 'User ID required' }, 400);
            }
            
            const { auditTrailService } = await import('../services/auditTrailService.js');
            const events = await auditTrailService.getUserAuditTrail(userId, 100);
            
            logger?.info('üìã [AuditTrail] Trail retrieved', { userId, count: events.length });
            
            return c.json({
              success: true,
              events: events.map(e => ({
                id: e.id,
                type: e.eventType,
                category: e.eventCategory,
                hash: e.payloadHash,
                status: e.status,
                onChainSignature: e.onchainSignature,
                createdAt: e.createdAt,
                confirmedAt: e.confirmedAt,
              })),
            });
          } catch (error: any) {
            logger?.error('‚ùå [AuditTrail] Error', { error: error.message });
            return c.json({ error: 'Failed to get audit trail' }, 500);
          }
        }
      },
      
      // Verify an audit event
      {
        path: "/api/audit-trail/verify/:eventId",
        method: "GET",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          try {
            const eventId = c.req.param('eventId');
            
            const { auditTrailService } = await import('../services/auditTrailService.js');
            const result = await auditTrailService.verifyEventHash(eventId);
            
            return c.json({
              valid: result.valid,
              eventId,
              storedHash: result.event?.payloadHash,
              computedHash: result.computedHash,
              match: result.valid,
              onChain: !!result.event?.onchainSignature,
              signature: result.event?.onchainSignature,
            });
          } catch (error: any) {
            logger?.error('‚ùå [AuditTrail] Verify error', { error: error.message });
            return c.json({ error: 'Verification failed' }, 500);
          }
        }
      },
      
      // Get audit trail stats (admin)
      {
        path: "/api/audit-trail/stats",
        method: "GET",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          try {
            const { auditTrailService } = await import('../services/auditTrailService.js');
            const stats = await auditTrailService.getStats();
            
            return c.json({ success: true, stats });
          } catch (error: any) {
            logger?.error('‚ùå [AuditTrail] Stats error', { error: error.message });
            return c.json({ error: 'Failed to get stats' }, 500);
          }
        }
      },
      
      // Get user's Hallmark profile
      {
        path: "/api/hallmark/profile",
        method: "GET",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          try {
            const { checkAccessSession } = await import('./middleware/accessControl.js');
            const sessionCheck = await checkAccessSession(c);
            if (!sessionCheck.valid) {
              return c.json({ error: 'Unauthorized' }, 401);
            }
            
            const userId = sessionCheck.userId || c.req.query('userId');
            if (!userId) {
              return c.json({ error: 'User ID required' }, 400);
            }
            
            const { hallmarkService } = await import('../services/hallmarkService.js');
            const profile = await hallmarkService.getOrCreateProfile(userId);
            
            return c.json({ success: true, profile });
          } catch (error: any) {
            logger?.error('‚ùå [Hallmark] Profile error', { error: error.message });
            return c.json({ error: 'Failed to get profile' }, 500);
          }
        }
      },
      
      // Get user's Hallmark collection
      {
        path: "/api/hallmark/collection",
        method: "GET",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          try {
            const { checkAccessSession } = await import('./middleware/accessControl.js');
            const sessionCheck = await checkAccessSession(c);
            if (!sessionCheck.valid) {
              return c.json({ error: 'Unauthorized' }, 401);
            }
            
            const userId = sessionCheck.userId || c.req.query('userId');
            if (!userId) {
              return c.json({ error: 'User ID required' }, 400);
            }
            
            const { hallmarkService } = await import('../services/hallmarkService.js');
            const hallmarks = await hallmarkService.getUserHallmarks(userId);
            
            return c.json({ success: true, hallmarks });
          } catch (error: any) {
            logger?.error('‚ùå [Hallmark] Collection error', { error: error.message });
            return c.json({ error: 'Failed to get collection' }, 500);
          }
        }
      },
      
      // Create draft Hallmark (before payment)
      {
        path: "/api/hallmark/create-draft",
        method: "POST",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          try {
            const { checkAccessSession } = await import('./middleware/accessControl.js');
            const sessionCheck = await checkAccessSession(c);
            if (!sessionCheck.valid) {
              return c.json({ error: 'Unauthorized' }, 401);
            }
            
            const { userId, avatarType, avatarId, template } = await c.req.json();
            if (!userId) {
              return c.json({ error: 'User ID required' }, 400);
            }
            
            const { hallmarkService } = await import('../services/hallmarkService.js');
            const draft = await hallmarkService.createDraftHallmark(userId, {
              avatarType,
              avatarId,
              template,
            });
            
            logger?.info('üìã [Hallmark] Draft created', { hallmarkId: draft.id, serialNumber: draft.serialNumber });
            
            return c.json({
              success: true,
              hallmark: draft,
              price: '1.99',
            });
          } catch (error: any) {
            logger?.error('‚ùå [Hallmark] Create draft error', { error: error.message });
            return c.json({ error: 'Failed to create draft' }, 500);
          }
        }
      },
      
      // Verify a Hallmark
      {
        path: "/api/hallmark/verify/:serialNumber",
        method: "GET",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          try {
            const serialNumber = c.req.param('serialNumber');
            
            const { hallmarkService } = await import('../services/hallmarkService.js');
            const result = await hallmarkService.verifyHallmark(serialNumber);
            
            return c.json({
              valid: result.valid,
              serialNumber,
              onChain: result.onChain,
              hallmark: result.valid ? {
                userId: result.hallmark?.userId,
                createdAt: result.hallmark?.createdAt,
                template: result.hallmark?.templateUsed,
                payloadHash: result.hallmark?.payloadHash,
              } : null,
            });
          } catch (error: any) {
            logger?.error('‚ùå [Hallmark] Verify error', { error: error.message });
            return c.json({ error: 'Verification failed' }, 500);
          }
        }
      },
      
      // Get Hallmark stats (admin)
      {
        path: "/api/hallmark/stats",
        method: "GET",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          try {
            const { hallmarkService } = await import('../services/hallmarkService.js');
            const stats = await hallmarkService.getStats();
            
            return c.json({ success: true, stats });
          } catch (error: any) {
            logger?.error('‚ùå [Hallmark] Stats error', { error: error.message });
            return c.json({ error: 'Failed to get stats' }, 500);
          }
        }
      },
      
      // Developer/Admin dashboard data
      {
        path: "/api/dev/dashboard",
        method: "GET",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          
          const expectedCode = process.env.ADMIN_ACCESS_CODE;
          const adminCode = c.req.query('code') || c.req.header('X-Admin-Code');
          
          if (!expectedCode || adminCode !== expectedCode) {
            return c.json({ error: 'Unauthorized' }, 401);
          }
          
          try {
            const { db } = await import('../db/client.js');
            const { subscriptions, whitelistedUsers, sessions, auditEvents, hallmarkMints, systemConfig } = await import('../db/schema.js');
            const { desc } = await import('drizzle-orm');
            
            const allSubscribers = await db.select().from(subscriptions);
            const allWhitelisted = await db.select().from(whitelistedUsers);
            const activeSessions = await db.select().from(sessions);
            
            let auditStats = { total: 0, pending: 0, confirmed: 0 };
            let hallmarkStats = { total: 0, revenue: 0 };
            
            try {
              const allAuditEvents = await db.select().from(auditEvents);
              auditStats = {
                total: allAuditEvents.length,
                pending: allAuditEvents.filter(e => e.status === 'pending').length,
                confirmed: allAuditEvents.filter(e => e.status === 'confirmed').length,
              };
            } catch (e) {}
            
            try {
              const allHallmarks = await db.select().from(hallmarkMints);
              hallmarkStats = {
                total: allHallmarks.filter(h => h.status !== 'draft').length,
                revenue: allHallmarks.filter(h => h.paidAt).length * 1.99,
              };
            } catch (e) {}
            
            let config: Record<string, any> = {};
            try {
              const allConfig = await db.select().from(systemConfig);
              allConfig.forEach(c => {
                if (!c.isSecret) {
                  config[c.key] = c.value;
                } else {
                  config[c.key] = '***HIDDEN***';
                }
              });
            } catch (e) {}
            
            const premiumCount = allSubscribers.filter(s => s.plan === 'premium' && s.status === 'active').length;
            const basicCount = allSubscribers.filter(s => s.plan === 'basic' && s.status === 'active').length;
            
            return c.json({
              success: true,
              dashboard: {
                subscriptions: {
                  total: allSubscribers.length,
                  premium: premiumCount,
                  basic: basicCount,
                  monthlyRevenue: (premiumCount * 6) + (basicCount * 2),
                },
                users: {
                  whitelisted: allWhitelisted.length,
                  activeSessions: activeSessions.length,
                },
                auditTrail: auditStats,
                hallmarks: hallmarkStats,
                systemConfig: config,
                walletConfigured: !!config['solana_audit_wallet'],
                heliusConfigured: !!process.env.HELIUS_API_KEY,
              },
            });
          } catch (error: any) {
            logger?.error('‚ùå [Dev] Dashboard error', { error: error.message });
            return c.json({ error: 'Failed to load dashboard' }, 500);
          }
        }
      },
      
      // Update system config (admin)
      {
        path: "/api/dev/config",
        method: "POST",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          
          const expectedCode = process.env.ADMIN_ACCESS_CODE;
          const adminCode = c.req.header('X-Admin-Code');
          
          if (!expectedCode || adminCode !== expectedCode) {
            return c.json({ error: 'Unauthorized' }, 401);
          }
          
          try {
            const { key, value, description, isSecret } = await c.req.json();
            
            if (!key || !value) {
              return c.json({ error: 'Key and value required' }, 400);
            }
            
            const { db } = await import('../db/client.js');
            const { systemConfig } = await import('../db/schema.js');
            
            await db.insert(systemConfig).values({
              key,
              value,
              description,
              isSecret: isSecret || false,
              updatedAt: new Date(),
            }).onConflictDoUpdate({
              target: systemConfig.key,
              set: {
                value,
                description,
                isSecret: isSecret || false,
                updatedAt: new Date(),
              },
            });
            
            logger?.info('‚úÖ [Dev] Config updated', { key });
            
            return c.json({ success: true, key });
          } catch (error: any) {
            logger?.error('‚ùå [Dev] Config error', { error: error.message });
            return c.json({ error: 'Failed to update config' }, 500);
          }
        }
      },
      
      // ============================================
      // USER FAVORITES API ENDPOINTS
      // ============================================
      
      // GET /api/users/:userId/favorites - Get user's favorites
      {
        path: "/api/users/:userId/favorites",
        method: "GET",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          const userId = c.req.param('userId');
          
          logger?.info('‚≠ê [Favorites] GET request', { userId });
          
          if (!userId) {
            return c.json({ error: 'User ID is required' }, 400);
          }
          
          try {
            const { db } = await import('../db/client.js');
            const { userFavorites } = await import('../db/schema.js');
            const { eq, asc } = await import('drizzle-orm');
            
            const favorites = await db
              .select()
              .from(userFavorites)
              .where(eq(userFavorites.userId, userId))
              .orderBy(asc(userFavorites.displayOrder));
            
            logger?.info('‚úÖ [Favorites] Retrieved', { userId, count: favorites.length });
            return c.json({ favorites, count: favorites.length });
          } catch (error: any) {
            logger?.error('‚ùå [Favorites] Error', { error: error.message });
            return c.json({ error: 'Failed to fetch favorites' }, 500);
          }
        }
      },
      
      // POST /api/users/:userId/favorites - Add a favorite
      {
        path: "/api/users/:userId/favorites",
        method: "POST",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          const userId = c.req.param('userId');
          
          logger?.info('‚≠ê [Favorites] POST request', { userId });
          
          if (!userId) {
            return c.json({ error: 'User ID is required' }, 400);
          }
          
          try {
            const body = await c.req.json();
            const { assetId, assetType, symbol, name, notes } = body;
            
            if (!assetId || !symbol || !name) {
              return c.json({ error: 'assetId, symbol, and name are required' }, 400);
            }
            
            const { db } = await import('../db/client.js');
            const { userFavorites } = await import('../db/schema.js');
            const { eq, max } = await import('drizzle-orm');
            const crypto = await import('crypto');
            
            // Get max displayOrder for this user
            const maxOrderResult = await db
              .select({ maxOrder: max(userFavorites.displayOrder) })
              .from(userFavorites)
              .where(eq(userFavorites.userId, userId));
            
            const nextOrder = (maxOrderResult[0]?.maxOrder || 0) + 1;
            
            const id = crypto.randomUUID();
            const now = new Date();
            
            await db.insert(userFavorites).values({
              id,
              userId,
              assetId,
              assetType: assetType || 'crypto',
              symbol,
              name,
              displayOrder: nextOrder,
              notes: notes || null,
              alertsEnabled: false,
              createdAt: now,
              updatedAt: now,
            });
            
            logger?.info('‚úÖ [Favorites] Created', { userId, assetId, id });
            return c.json({ success: true, id, displayOrder: nextOrder });
          } catch (error: any) {
            logger?.error('‚ùå [Favorites] Error creating', { error: error.message });
            return c.json({ error: 'Failed to add favorite' }, 500);
          }
        }
      },
      
      // DELETE /api/users/:userId/favorites/:id - Remove a favorite
      {
        path: "/api/users/:userId/favorites/:id",
        method: "DELETE",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          const userId = c.req.param('userId');
          const favoriteId = c.req.param('id');
          
          logger?.info('‚≠ê [Favorites] DELETE request', { userId, favoriteId });
          
          if (!userId || !favoriteId) {
            return c.json({ error: 'User ID and favorite ID are required' }, 400);
          }
          
          try {
            const { db } = await import('../db/client.js');
            const { userFavorites } = await import('../db/schema.js');
            const { eq, and } = await import('drizzle-orm');
            
            const result = await db
              .delete(userFavorites)
              .where(and(
                eq(userFavorites.id, favoriteId),
                eq(userFavorites.userId, userId)
              ));
            
            logger?.info('‚úÖ [Favorites] Deleted', { userId, favoriteId });
            return c.json({ success: true });
          } catch (error: any) {
            logger?.error('‚ùå [Favorites] Error deleting', { error: error.message });
            return c.json({ error: 'Failed to delete favorite' }, 500);
          }
        }
      },
      
      // PUT /api/users/:userId/favorites/:id - Update favorite (order, notes)
      {
        path: "/api/users/:userId/favorites/:id",
        method: "PUT",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          const userId = c.req.param('userId');
          const favoriteId = c.req.param('id');
          
          logger?.info('‚≠ê [Favorites] PUT request', { userId, favoriteId });
          
          if (!userId || !favoriteId) {
            return c.json({ error: 'User ID and favorite ID are required' }, 400);
          }
          
          try {
            const body = await c.req.json();
            const { displayOrder, notes, alertsEnabled } = body;
            
            const { db } = await import('../db/client.js');
            const { userFavorites } = await import('../db/schema.js');
            const { eq, and } = await import('drizzle-orm');
            
            const updateData: any = { updatedAt: new Date() };
            if (displayOrder !== undefined) updateData.displayOrder = displayOrder;
            if (notes !== undefined) updateData.notes = notes;
            if (alertsEnabled !== undefined) updateData.alertsEnabled = alertsEnabled;
            
            await db
              .update(userFavorites)
              .set(updateData)
              .where(and(
                eq(userFavorites.id, favoriteId),
                eq(userFavorites.userId, userId)
              ));
            
            logger?.info('‚úÖ [Favorites] Updated', { userId, favoriteId });
            return c.json({ success: true });
          } catch (error: any) {
            logger?.error('‚ùå [Favorites] Error updating', { error: error.message });
            return c.json({ error: 'Failed to update favorite' }, 500);
          }
        }
      },
      
      // ============================================
      // USER DASHBOARD CONFIG API ENDPOINTS
      // ============================================
      
      // GET /api/users/:userId/dashboard - Get dashboard config
      {
        path: "/api/users/:userId/dashboard",
        method: "GET",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          const userId = c.req.param('userId');
          
          logger?.info('üìä [Dashboard] GET request', { userId });
          
          if (!userId) {
            return c.json({ error: 'User ID is required' }, 400);
          }
          
          try {
            const { db } = await import('../db/client.js');
            const { userDashboardConfigs } = await import('../db/schema.js');
            const { eq } = await import('drizzle-orm');
            
            // Determine access level based on userId prefix or ADMIN_EMAIL match
            const adminEmail = process.env.ADMIN_EMAIL;
            let accessLevel: 'user' | 'admin' | 'owner' = 'user';
            
            // Sanitize admin email the same way login sanitizes emails for userId comparison
            // Login uses: credential.replace(/[^a-zA-Z0-9]/g, '-') without lowercasing
            const sanitizedAdminEmail = adminEmail?.replace(/[^a-zA-Z0-9]/g, '-');
            
            if (userId.startsWith('owner-') || (sanitizedAdminEmail && userId === sanitizedAdminEmail)) {
              accessLevel = 'owner';
            } else if (userId.startsWith('admin-')) {
              accessLevel = 'admin';
            }
            
            const configs = await db
              .select()
              .from(userDashboardConfigs)
              .where(eq(userDashboardConfigs.userId, userId));
            
            if (configs.length === 0) {
              // Return default config if none exists
              logger?.info('üìä [Dashboard] No config found, returning defaults', { userId, accessLevel });
              return c.json({
                userId,
                hallmarkId: null,
                defaultLandingTab: 'dashboard',
                layout: null,
                showFavoritesOnly: false,
                defaultChart: 'bitcoin',
                chartTimeframe: '7D',
                theme: 'dark',
                emailNotifications: true,
                pushNotifications: true,
                avatarConfig: null,
                avatarMode: 'custom',
                accessLevel,
              });
            }
            
            logger?.info('‚úÖ [Dashboard] Retrieved', { userId, accessLevel });
            return c.json({ ...configs[0], accessLevel });
          } catch (error: any) {
            logger?.error('‚ùå [Dashboard] Error', { error: error.message });
            return c.json({ error: 'Failed to fetch dashboard config' }, 500);
          }
        }
      },
      
      // PUT /api/users/:userId/dashboard - Update dashboard config
      {
        path: "/api/users/:userId/dashboard",
        method: "PUT",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          const userId = c.req.param('userId');
          
          logger?.info('üìä [Dashboard] PUT request', { userId });
          
          if (!userId) {
            return c.json({ error: 'User ID is required' }, 400);
          }
          
          try {
            const body = await c.req.json();
            const { db } = await import('../db/client.js');
            const { userDashboardConfigs } = await import('../db/schema.js');
            
            const now = new Date();
            const validFields = [
              'defaultLandingTab', 'layout', 'showFavoritesOnly', 
              'defaultChart', 'chartTimeframe', 'theme',
              'emailNotifications', 'pushNotifications', 
              'avatarConfig', 'avatarMode'
            ];
            
            const updateData: any = { updatedAt: now };
            for (const field of validFields) {
              if (body[field] !== undefined) {
                updateData[field] = body[field];
              }
            }
            
            await db.insert(userDashboardConfigs).values({
              userId,
              ...updateData,
              createdAt: now,
            }).onConflictDoUpdate({
              target: userDashboardConfigs.userId,
              set: updateData,
            });
            
            logger?.info('‚úÖ [Dashboard] Updated', { userId });
            return c.json({ success: true });
          } catch (error: any) {
            logger?.error('‚ùå [Dashboard] Error updating', { error: error.message });
            return c.json({ error: 'Failed to update dashboard config' }, 500);
          }
        }
      },
      
      // POST /api/users/:userId/hallmark - Generate hallmark ID if not exists
      {
        path: "/api/users/:userId/hallmark",
        method: "POST",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          const userId = c.req.param('userId');
          
          logger?.info('üéñÔ∏è [Hallmark] POST request', { userId });
          
          if (!userId) {
            return c.json({ error: 'User ID is required' }, 400);
          }
          
          try {
            const { db } = await import('../db/client.js');
            const { userDashboardConfigs } = await import('../db/schema.js');
            const { eq } = await import('drizzle-orm');
            
            // Check if user already has a hallmark ID
            const existing = await db
              .select()
              .from(userDashboardConfigs)
              .where(eq(userDashboardConfigs.userId, userId));
            
            if (existing.length > 0 && existing[0].hallmarkId) {
              logger?.info('üéñÔ∏è [Hallmark] Already exists', { userId, hallmarkId: existing[0].hallmarkId });
              return c.json({ hallmarkId: existing[0].hallmarkId, isNew: false });
            }
            
            // Generate unique hallmark ID: PULSE-XXXX-2026
            const crypto = await import('crypto');
            const randomPart = crypto.randomBytes(2).toString('hex').toUpperCase();
            const year = new Date().getFullYear();
            const hallmarkId = `PULSE-${randomPart}-${year}`;
            
            const now = new Date();
            
            await db.insert(userDashboardConfigs).values({
              userId,
              hallmarkId,
              createdAt: now,
              updatedAt: now,
            }).onConflictDoUpdate({
              target: userDashboardConfigs.userId,
              set: { hallmarkId, updatedAt: now },
            });
            
            logger?.info('‚úÖ [Hallmark] Generated', { userId, hallmarkId });
            return c.json({ hallmarkId, isNew: true });
          } catch (error: any) {
            logger?.error('‚ùå [Hallmark] Error', { error: error.message });
            return c.json({ error: 'Failed to generate hallmark ID' }, 500);
          }
        }
      },
      
      // Sniper Bot API Routes (MUST be before catch-all)
      ...sniperBotRoutes,
      
      // Demo Trading Routes (no auth required)
      ...demoRoutes,
      
      // Limit Order API Routes
      ...limitOrderRoutes,
      
      // Multi-Chain Wallet API Routes
      ...walletRoutes,
      
      // Stripe Payment API Routes
      ...paymentRoutes,
      
      // ML Stats API Routes
      ...mlRoutes,
      
      // Dust Buster Routes
      ...dustBusterRoutes,
      
      // Quant System Routes
      ...quantRoutes,
      
      // Auto Trade Routes (Autonomous Trading System)
      ...autoTradeRoutes,
      
      // Trade Execution Routes (AI Trading Engine)
      ...tradeExecutionRoutes,
      
      // Crypto Onramp Routes (Stripe fiat-to-crypto)
      ...cryptoOnrampRoutes,
      
      // MoonPay Crypto Onramp Routes
      ...moonpayRoutes,
      
      // Transak Crypto Onramp Routes
      ...transakRoutes,
      
      ...swapRoutes,
      
      // Multi-Sig Vault Routes
      ...vaultRoutes,
      
      // Analytics Routes (Developers Portal)
      ...analyticsRoutes,
      
      // API Billing Routes (Developer API subscriptions)
      ...apiBillingRoutes,
      
      // Social Trading Routes (Leaderboard, Copy Trading, Signals)
      ...socialTradingRoutes,
      
      // Exchange Connector Routes (CEX/DEX Trading Integrations)
      ...exchangeRoutes,
      
      // Autonomous Trading Routes (Profiles, Suggestions, Executions, Milestones)
      ...autonomousTradingRoutes,
      
      // WebAuthn Biometric Authentication Routes
      ...webauthnRoutes,
      
      // Ecosystem Integration Routes (Dev Hub handoff protocol)
      ...ecosystemRoutes,
      
      // DarkWave Chain L1 Integration Routes (Hash verification, Hallmarks)
      ...darkwaveChainRoutes,
      
      // Catch-all static file handler (MUST BE LAST) - serves all assets from public/
      {
        path: "/*",
        method: "GET",
        createHandler: async ({ mastra }) => async (c: any) => {
          const fs = await import('fs/promises');
          const path = await import('path');
          const url = await import('url');
          
          // Get requested path and sanitize it
          const requestPath = c.req.path.substring(1); // Remove leading slash
          
          // Skip API routes (already handled above)
          if (requestPath.startsWith('api/') || requestPath === 'admin' || requestPath === 'dev' || requestPath.startsWith('webhooks/')) {
            return c.text('Not found', 404);
          }
          
          // Security: prevent directory traversal
          if (requestPath.includes('..') || requestPath.includes('~')) {
            return c.text('Invalid path', 400);
          }
          
          const __dirname = path.dirname(url.fileURLToPath(import.meta.url));
          const possibleBasePaths = [
            path.join(process.cwd(), 'public'),
            path.resolve(process.cwd(), '..', '..', 'public'), // Repo root for bundled output
            path.join(__dirname, '..', '..', 'public'),
            path.join(__dirname, '..', '..', '..', 'public'),
            path.join(__dirname, '..', '..', '..', '..', 'public'),
          ];
          
          // Try each base path
          for (const basePath of possibleBasePaths) {
            try {
              const filePath = path.join(basePath, requestPath);
              const fileContent = await fs.readFile(filePath);
              
              // Detect content type based on extension
              const ext = path.extname(requestPath).toLowerCase();
              const contentTypes: Record<string, string> = {
                '.png': 'image/png',
                '.jpg': 'image/jpeg',
                '.jpeg': 'image/jpeg',
                '.gif': 'image/gif',
                '.svg': 'image/svg+xml',
                '.webp': 'image/webp',
                '.ico': 'image/x-icon',
                '.css': 'text/css',
                '.js': 'application/javascript',
                '.json': 'application/json',
                '.html': 'text/html',
                '.txt': 'text/plain',
                '.pdf': 'application/pdf',
                '.woff': 'font/woff',
                '.woff2': 'font/woff2',
                '.ttf': 'font/ttf',
                '.eot': 'application/vnd.ms-fontobject',
              };
              
              const contentType = contentTypes[ext] || 'application/octet-stream';
              c.header('Content-Type', contentType);
              c.header('Cache-Control', 'public, max-age=300'); // 5 min cache
              return c.body(fileContent);
            } catch (err) {
              continue; // Try next base path
            }
          }
          
          // File not found in any path, return 404
          return c.text('File not found', 404);
        }
      },
      
      // ============================================
      // PUBLIC API v1 - For External Developers
      // ============================================
      
      // API Key Management - Generate new API key (requires authentication)
      {
        path: "/api/developer/keys",
        method: "POST",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          try {
            const body = await c.req.json();
            const { sessionToken, name, tier = 'free', description, environment = 'live' } = body;
            
            if (!sessionToken || !name) {
              return c.json({ error: 'sessionToken and name are required' }, 400);
            }
            
            // Validate environment
            if (environment !== 'live' && environment !== 'test') {
              return c.json({ error: 'environment must be "live" or "test"' }, 400);
            }
            
            // Verify session token and get user
            const { db } = await import('../db/client.js');
            const { sessions } = await import('../db/schema.js');
            const { eq } = await import('drizzle-orm');
            
            const sessionRecords = await db.select().from(sessions).where(eq(sessions.token, sessionToken));
            
            if (sessionRecords.length === 0) {
              logger?.warn('üîí [API Keys] Invalid session token attempted');
              return c.json({ error: 'Invalid or expired session' }, 401);
            }
            
            const session = sessionRecords[0];
            
            // Check if session is expired
            if (session.expiresAt && new Date(session.expiresAt) < new Date()) {
              logger?.warn('üîí [API Keys] Expired session token used');
              return c.json({ error: 'Session has expired, please log in again' }, 401);
            }
            
            // Use the userId from the verified session
            const userId = session.userId || session.email || 'anonymous';
            
            const { apiKeyService } = await import('../services/apiKeyService.js');
            const result = await apiKeyService.generateApiKey(userId, name, tier, description, environment);
            
            logger?.info('üîë [API Keys] New key generated', { userId, name, tier, environment });
            
            return c.json({
              success: true,
              apiKey: result.key,
              keyId: result.keyId,
              prefix: result.prefix,
              environment: result.environment,
              message: 'Store this API key securely - it cannot be retrieved again'
            });
          } catch (error: any) {
            logger?.error('‚ùå [API Keys] Error generating key', { error: error.message });
            return c.json({ error: 'Failed to generate API key' }, 500);
          }
        }
      },
      
      // API Key Management - Get user's API keys
      {
        path: "/api/developer/list-keys",
        method: "GET",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          try {
            const userId = c.req.query('userId');
            
            if (!userId) {
              return c.json({ error: 'userId is required' }, 400);
            }
            
            const { apiKeyService } = await import('../services/apiKeyService.js');
            const keys = await apiKeyService.getUserApiKeys(userId);
            
            return c.json({ keys });
          } catch (error: any) {
            logger?.error('‚ùå [API Keys] Error fetching keys', { error: error.message });
            return c.json({ error: 'Failed to fetch API keys' }, 500);
          }
        }
      },
      
      // API Key Management - Revoke API key
      {
        path: "/api/developer/keys/:keyId",
        method: "DELETE",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          try {
            const keyId = c.req.param('keyId');
            const userId = c.req.query('userId');
            
            if (!userId) {
              return c.json({ error: 'userId is required' }, 400);
            }
            
            const { apiKeyService } = await import('../services/apiKeyService.js');
            await apiKeyService.revokeApiKey(keyId, userId);
            
            logger?.info('üîí [API Keys] Key revoked', { keyId, userId });
            
            return c.json({ success: true, message: 'API key revoked' });
          } catch (error: any) {
            logger?.error('‚ùå [API Keys] Error revoking key', { error: error.message });
            return c.json({ error: 'Failed to revoke API key' }, 500);
          }
        }
      },
      
      // API Key Management - Regenerate key
      {
        path: "/api/developer/keys/regenerate",
        method: "POST",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          try {
            const body = await c.req.json();
            const { sessionToken, keyId } = body;
            
            if (!sessionToken || !keyId) {
              return c.json({ error: 'sessionToken and keyId are required' }, 400);
            }
            
            // Verify session
            const { db } = await import('../db/client.js');
            const { sessions, apiKeys } = await import('../db/schema.js');
            const { eq, and } = await import('drizzle-orm');
            
            const sessionRecords = await db.select().from(sessions).where(eq(sessions.token, sessionToken));
            if (sessionRecords.length === 0) {
              return c.json({ error: 'Invalid session' }, 401);
            }
            
            const session = sessionRecords[0];
            const userId = session.userId || session.email || 'anonymous';
            
            // Get the old key to preserve its settings
            const oldKeyRecords = await db.select().from(apiKeys).where(and(eq(apiKeys.id, parseInt(keyId)), eq(apiKeys.userId, userId)));
            if (oldKeyRecords.length === 0) {
              return c.json({ error: 'Key not found or unauthorized' }, 404);
            }
            
            const oldKey = oldKeyRecords[0];
            
            // Revoke old key
            const { apiKeyService } = await import('../services/apiKeyService.js');
            await apiKeyService.revokeApiKey(keyId, userId);
            
            // Generate new key with same settings
            const result = await apiKeyService.generateApiKey(
              userId, 
              oldKey.name || 'Regenerated Key', 
              oldKey.tier || 'free',
              oldKey.description,
              oldKey.environment || 'live'
            );
            
            logger?.info('üîÑ [API Keys] Key regenerated', { oldKeyId: keyId, newKeyId: result.keyId, userId });
            
            return c.json({
              success: true,
              apiKey: result.key,
              keyId: result.keyId,
              prefix: result.prefix,
              environment: result.environment,
              message: 'New key generated - save it now, it cannot be retrieved again'
            });
          } catch (error: any) {
            logger?.error('‚ùå [API Keys] Error regenerating key', { error: error.message });
            return c.json({ error: 'Failed to regenerate API key' }, 500);
          }
        }
      },
      
      // API Subscription - Get user's current subscription
      {
        path: "/api/developer/subscription",
        method: "GET",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          try {
            const userId = c.req.query('userId');
            
            if (!userId) {
              return c.json({ error: 'userId is required' }, 400);
            }
            
            const { ApiBillingService } = await import('../services/apiBillingService.js');
            const billingService = new ApiBillingService();
            const subscription = await billingService.getUserApiSubscription(userId);
            
            if (!subscription) {
              return c.json({
                success: true,
                subscription: {
                  tier: 'free',
                  status: 'active',
                  currentPeriodEnd: null,
                  cancelAtPeriodEnd: false
                }
              });
            }
            
            return c.json({
              success: true,
              subscription
            });
          } catch (error: any) {
            logger?.error('‚ùå [API Subscription] Error fetching subscription', { error: error.message });
            return c.json({ error: 'Failed to fetch subscription' }, 500);
          }
        }
      },
      
      // API Key Management - Get usage stats
      {
        path: "/api/developer/keys/:keyId/usage",
        method: "GET",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          try {
            const keyId = c.req.param('keyId');
            const days = parseInt(c.req.query('days') || '30');
            
            const { apiKeyService } = await import('../services/apiKeyService.js');
            const usage = await apiKeyService.getKeyUsageStats(keyId, days);
            
            return c.json({ usage });
          } catch (error: any) {
            logger?.error('‚ùå [API Keys] Error fetching usage', { error: error.message });
            return c.json({ error: 'Failed to fetch usage stats' }, 500);
          }
        }
      },
      
      // ============================================
      // PUBLIC API v1 - Market Data Endpoints
      // ============================================
      
      // Public API - Market Overview
      {
        path: "/api/v1/market-overview",
        method: "GET",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          const startTime = Date.now();
          
          // Validate API key
          const apiKey = c.req.header('X-Pulse-Api-Key');
          if (!apiKey) {
            return c.json({ 
              error: 'Missing API key', 
              code: 'MISSING_API_KEY',
              docs: '/developers#api-docs' 
            }, 401);
          }
          
          const { apiKeyService } = await import('../services/apiKeyService.js');
          const validation = await apiKeyService.validateApiKey(apiKey);
          
          if (!validation.valid) {
            return c.json({ 
              error: validation.error, 
              code: 'INVALID_API_KEY',
              docs: '/developers#api-docs' 
            }, 401);
          }
          
          const keyRecord = validation.keyRecord;
          
          // Check rate limit
          const rateCheck = await apiKeyService.checkRateLimit(keyRecord.id, keyRecord.rateLimit);
          if (!rateCheck.allowed) {
            await apiKeyService.recordUsage(keyRecord.id, '/api/v1/market-overview', 429);
            return c.json({ 
              error: 'Rate limit exceeded', 
              code: 'RATE_LIMIT_EXCEEDED',
              retryAfter: Math.ceil(rateCheck.resetIn / 1000) 
            }, 429);
          }
          
          // Check daily limit
          const dailyCheck = await apiKeyService.checkDailyLimit(keyRecord.id, keyRecord.dailyLimit);
          if (!dailyCheck.allowed) {
            await apiKeyService.recordUsage(keyRecord.id, '/api/v1/market-overview', 429);
            return c.json({ 
              error: 'Daily limit exceeded', 
              code: 'DAILY_LIMIT_EXCEEDED',
              used: dailyCheck.used,
              limit: keyRecord.dailyLimit 
            }, 429);
          }
          
          try {
            const category = c.req.query('category') || 'top';
            const { fetchCryptoOverview } = await import('./tools/helpers/marketOverview.js');
            const data = await fetchCryptoOverview(category, logger);
            
            const latency = Date.now() - startTime;
            await apiKeyService.recordUsage(keyRecord.id, '/api/v1/market-overview', 200, latency);
            
            // Add rate limit headers
            c.header('X-RateLimit-Limit', keyRecord.rateLimit.toString());
            c.header('X-RateLimit-Remaining', rateCheck.remaining.toString());
            c.header('X-DailyLimit-Remaining', dailyCheck.remaining.toString());
            
            return c.json({
              success: true,
              data,
              meta: {
                category,
                count: data.length,
                timestamp: new Date().toISOString()
              }
            });
          } catch (error: any) {
            const latency = Date.now() - startTime;
            await apiKeyService.recordUsage(keyRecord.id, '/api/v1/market-overview', 500, latency, error.message);
            return c.json({ error: 'Failed to fetch market data', code: 'INTERNAL_ERROR' }, 500);
          }
        }
      },
      
      // Public API - Coin Price
      {
        path: "/api/v1/price/:symbol",
        method: "GET",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          const startTime = Date.now();
          
          // Validate API key
          const apiKey = c.req.header('X-Pulse-Api-Key');
          if (!apiKey) {
            return c.json({ error: 'Missing API key', code: 'MISSING_API_KEY' }, 401);
          }
          
          const { apiKeyService } = await import('../services/apiKeyService.js');
          const validation = await apiKeyService.validateApiKey(apiKey);
          
          if (!validation.valid) {
            return c.json({ error: validation.error, code: 'INVALID_API_KEY' }, 401);
          }
          
          const keyRecord = validation.keyRecord;
          
          // Check rate limit
          const rateCheck = await apiKeyService.checkRateLimit(keyRecord.id, keyRecord.rateLimit);
          if (!rateCheck.allowed) {
            return c.json({ error: 'Rate limit exceeded', retryAfter: Math.ceil(rateCheck.resetIn / 1000) }, 429);
          }
          
          try {
            const symbol = c.req.param('symbol')?.toUpperCase();
            
            if (!symbol) {
              return c.json({ error: 'Symbol is required', code: 'MISSING_SYMBOL' }, 400);
            }
            
            // Symbol to CoinGecko ID mapping
            const symbolToId: Record<string, string> = {
              'BTC': 'bitcoin', 'ETH': 'ethereum', 'USDT': 'tether', 'BNB': 'binancecoin',
              'SOL': 'solana', 'XRP': 'ripple', 'USDC': 'usd-coin', 'ADA': 'cardano',
              'AVAX': 'avalanche-2', 'DOGE': 'dogecoin', 'DOT': 'polkadot', 'LINK': 'chainlink',
              'MATIC': 'matic-network', 'SHIB': 'shiba-inu', 'LTC': 'litecoin', 'TRX': 'tron'
            };
            
            const coinId = symbolToId[symbol] || symbol.toLowerCase();
            const response = await fetch(
              `https://api.coingecko.com/api/v3/simple/price?ids=${coinId}&vs_currencies=usd&include_24hr_change=true`
            );
            
            if (!response.ok) {
              throw new Error('CoinGecko API error');
            }
            
            const data = await response.json();
            const coinData = data[coinId];
            
            if (!coinData) {
              return c.json({ error: 'Coin not found', code: 'COIN_NOT_FOUND' }, 404);
            }
            
            const latency = Date.now() - startTime;
            await apiKeyService.recordUsage(keyRecord.id, '/api/v1/price', 200, latency);
            
            return c.json({
              success: true,
              data: {
                symbol,
                coinId,
                price: coinData.usd,
                change24h: coinData.usd_24h_change,
                timestamp: new Date().toISOString()
              }
            });
          } catch (error: any) {
            const latency = Date.now() - startTime;
            await apiKeyService.recordUsage(keyRecord.id, '/api/v1/price', 500, latency, error.message);
            return c.json({ error: 'Failed to fetch price', code: 'INTERNAL_ERROR' }, 500);
          }
        }
      },
      
      // Public API - AI Signals
      {
        path: "/api/v1/signals",
        method: "GET",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          const startTime = Date.now();
          
          // Validate API key
          const apiKey = c.req.header('X-Pulse-Api-Key');
          if (!apiKey) {
            return c.json({ error: 'Missing API key', code: 'MISSING_API_KEY' }, 401);
          }
          
          const { apiKeyService, API_TIERS } = await import('../services/apiKeyService.js');
          const validation = await apiKeyService.validateApiKey(apiKey);
          
          if (!validation.valid) {
            return c.json({ error: validation.error, code: 'INVALID_API_KEY' }, 401);
          }
          
          const keyRecord = validation.keyRecord;
          
          // Check permissions - signals require at least 'signals' permission
          const permissions = keyRecord.permissions ? JSON.parse(keyRecord.permissions) : [];
          if (!permissions.includes('signals')) {
            return c.json({ 
              error: 'Insufficient permissions - signals access required', 
              code: 'INSUFFICIENT_PERMISSIONS',
              currentTier: keyRecord.tier,
              requiredTier: 'free+'
            }, 403);
          }
          
          // Check rate limit
          const rateCheck = await apiKeyService.checkRateLimit(keyRecord.id, keyRecord.rateLimit);
          if (!rateCheck.allowed) {
            return c.json({ error: 'Rate limit exceeded', retryAfter: Math.ceil(rateCheck.resetIn / 1000) }, 429);
          }
          
          try {
            const symbol = c.req.query('symbol')?.toUpperCase();
            
            if (!symbol) {
              return c.json({ error: 'Symbol is required', code: 'MISSING_SYMBOL' }, 400);
            }
            
            // Symbol to CoinGecko ID mapping
            const symbolToId: Record<string, string> = {
              'BTC': 'bitcoin', 'ETH': 'ethereum', 'USDT': 'tether', 'BNB': 'binancecoin',
              'SOL': 'solana', 'XRP': 'ripple', 'USDC': 'usd-coin', 'ADA': 'cardano',
              'AVAX': 'avalanche-2', 'DOGE': 'dogecoin', 'DOT': 'polkadot', 'LINK': 'chainlink'
            };
            
            const coinId = symbolToId[symbol] || symbol.toLowerCase();
            
            // Fetch market data from CoinGecko
            const response = await fetch(
              `https://api.coingecko.com/api/v3/coins/${coinId}?localization=false&tickers=false&market_data=true&community_data=false&developer_data=false`
            );
            
            if (!response.ok) {
              throw new Error('Failed to fetch coin data');
            }
            
            const data = await response.json();
            const marketData = data.market_data;
            
            // Generate simple signal based on price changes
            let signal = 'HOLD';
            let confidence = 0.5;
            
            const change24h = marketData?.price_change_percentage_24h || 0;
            const change7d = marketData?.price_change_percentage_7d || 0;
            
            if (change24h > 5 && change7d > 10) {
              signal = 'STRONG_BUY';
              confidence = 0.8;
            } else if (change24h > 2) {
              signal = 'BUY';
              confidence = 0.65;
            } else if (change24h < -5 && change7d < -10) {
              signal = 'STRONG_SELL';
              confidence = 0.8;
            } else if (change24h < -2) {
              signal = 'SELL';
              confidence = 0.65;
            }
            
            const latency = Date.now() - startTime;
            await apiKeyService.recordUsage(keyRecord.id, '/api/v1/signals', 200, latency);
            
            return c.json({
              success: true,
              data: {
                symbol,
                coinId,
                signal,
                confidence,
                price: marketData?.current_price?.usd,
                change24h,
                change7d,
                marketCap: marketData?.market_cap?.usd,
                volume24h: marketData?.total_volume?.usd,
                timestamp: new Date().toISOString()
              }
            });
          } catch (error: any) {
            const latency = Date.now() - startTime;
            await apiKeyService.recordUsage(keyRecord.id, '/api/v1/signals', 500, latency, error.message);
            return c.json({ error: 'Failed to analyze', code: 'INTERNAL_ERROR' }, 500);
          }
        }
      },
      
      // Public API - ML Predictions
      {
        path: "/api/v1/predictions/:symbol",
        method: "GET",
        createHandler: async ({ mastra }) => async (c: any) => {
          const logger = mastra.getLogger();
          const startTime = Date.now();
          
          // Validate API key
          const apiKey = c.req.header('X-Pulse-Api-Key');
          if (!apiKey) {
            return c.json({ error: 'Missing API key', code: 'MISSING_API_KEY' }, 401);
          }
          
          const { apiKeyService } = await import('../services/apiKeyService.js');
          const validation = await apiKeyService.validateApiKey(apiKey);
          
          if (!validation.valid) {
            return c.json({ error: validation.error, code: 'INVALID_API_KEY' }, 401);
          }
          
          const keyRecord = validation.keyRecord;
          
          // Check permissions - predictions require 'predictions' permission (Pro+ tier)
          const permissions = keyRecord.permissions ? JSON.parse(keyRecord.permissions) : [];
          if (!permissions.includes('predictions')) {
            return c.json({ 
              error: 'Insufficient permissions - Pro tier required for predictions', 
              code: 'INSUFFICIENT_PERMISSIONS',
              currentTier: keyRecord.tier,
              requiredTier: 'pro'
            }, 403);
          }
          
          try {
            const symbol = c.req.param('symbol')?.toUpperCase();
            const horizon = c.req.query('horizon') || '24h';
            
            if (!symbol) {
              return c.json({ error: 'Symbol is required', code: 'MISSING_SYMBOL' }, 400);
            }
            
            // Get ML prediction (simplified - would connect to actual ML service)
            const { db } = await import('../db/client.js');
            const { predictionEvents, predictionAccuracyStats } = await import('../db/schema.js');
            const { eq, desc } = await import('drizzle-orm');
            
            // Get latest prediction for this symbol
            const predictions = await db.select()
              .from(predictionEvents)
              .where(eq(predictionEvents.ticker, symbol))
              .orderBy(desc(predictionEvents.timestamp))
              .limit(1);
            
            // Get accuracy stats
            const stats = await db.select()
              .from(predictionAccuracyStats)
              .where(eq(predictionAccuracyStats.ticker, symbol))
              .limit(1);
            
            const latency = Date.now() - startTime;
            await apiKeyService.recordUsage(keyRecord.id, '/api/v1/predictions', 200, latency);
            
            return c.json({
              success: true,
              data: {
                symbol,
                horizon,
                prediction: predictions.length > 0 ? {
                  signal: predictions[0].signalType,
                  confidence: predictions[0].confidence,
                  timestamp: predictions[0].timestamp
                } : null,
                accuracy: stats.length > 0 ? {
                  winRate: stats[0].winRate,
                  totalPredictions: stats[0].totalPredictions
                } : null,
                timestamp: new Date().toISOString()
              }
            });
          } catch (error: any) {
            const latency = Date.now() - startTime;
            await apiKeyService.recordUsage(keyRecord.id, '/api/v1/predictions', 500, latency, error.message);
            return c.json({ error: 'Failed to fetch predictions', code: 'INTERNAL_ERROR' }, 500);
          }
        }
      },
      
      // Public API - API Documentation
      {
        path: "/api/v1/docs",
        method: "GET",
        createHandler: async ({ mastra }) => async (c: any) => {
          return c.json({
            name: 'Pulse Public API',
            version: 'v1',
            baseUrl: '/api/v1',
            authentication: {
              type: 'API Key',
              header: 'X-Pulse-Api-Key',
              format: 'pk_live_XXXX...'
            },
            tiers: {
              free: { rateLimit: '60/min', dailyLimit: 2000, endpoints: ['market', 'signals'] },
              pro: { rateLimit: '600/min', dailyLimit: 100000, endpoints: ['market', 'signals', 'predictions', 'strikeagent'] },
              enterprise: { rateLimit: '3000/min', dailyLimit: 1000000, endpoints: ['all + webhooks'] }
            },
            endpoints: [
              { path: '/market-overview', method: 'GET', description: 'Get market overview by category', params: ['category'] },
              { path: '/price/:symbol', method: 'GET', description: 'Get current price for a coin' },
              { path: '/signals', method: 'GET', description: 'Get AI analysis for a coin', params: ['symbol'] },
              { path: '/predictions/:symbol', method: 'GET', description: 'Get ML predictions (Pro+)', params: ['horizon'] }
            ],
            errors: {
              MISSING_API_KEY: 'No API key provided in X-Pulse-Api-Key header',
              INVALID_API_KEY: 'API key is invalid or expired',
              RATE_LIMIT_EXCEEDED: 'Too many requests - slow down',
              DAILY_LIMIT_EXCEEDED: 'Daily request limit reached',
              INSUFFICIENT_PERMISSIONS: 'Upgrade tier for this endpoint'
            }
          });
        }
      },
    ],
  },
  logger:
    process.env.NODE_ENV === "production"
      ? new ProductionPinoLogger({
          name: "Mastra",
          level: "info",
        })
      : new PinoLogger({
          name: "Mastra",
          level: "info",
        }),
});

/*  Sanity check 1: Throw an error if there are more than 1 workflows.  */
// !!!!!! Do not remove this check. !!!!!!
if (Object.keys(mastra.getWorkflows()).length > 1) {
  throw new Error(
    "More than 1 workflows found. Currently, more than 1 workflows are not supported in the UI, since doing so will cause app state to be inconsistent.",
  );
}

/*  Sanity check 2: Throw an error if there are more than 1 agents.  */
// !!!!!! Do not remove this check. !!!!!!
if (Object.keys(mastra.getAgents()).length > 1) {
  throw new Error(
    "More than 1 agents found. Currently, more than 1 agents are not supported in the UI, since doing so will cause app state to be inconsistent.",
  );
}
