{"version":3,"file":"p256.mjs","sources":["../.build/_shortw_utils.mjs","../.build/p256.mjs"],"sourcesContent":["import { h as hexToBytes, c as abytes, d as bytesToHex, i as isBytes, e as concatBytes, f as anumber, g as ahash, r as randomBytes, j as hmac } from './hmac.mjs';\n\n/**\n * Hex, bytes and number utilities.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nconst _0n$3 = /* @__PURE__ */ BigInt(0);\nconst _1n$3 = /* @__PURE__ */ BigInt(1);\n// tmp name until v2\nfunction _abool2(value, title = '') {\n    if (typeof value !== 'boolean') {\n        const prefix = title && `\"${title}\"`;\n        throw new Error(prefix + 'expected boolean, got type=' + typeof value);\n    }\n    return value;\n}\n// tmp name until v2\n/** Asserts something is Uint8Array. */\nfunction _abytes2(value, length, title = '') {\n    const bytes = isBytes(value);\n    const len = value?.length;\n    const needsLen = length !== undefined;\n    if (!bytes || (needsLen && len !== length)) {\n        const prefix = title && `\"${title}\" `;\n        const ofLen = needsLen ? ` of length ${length}` : '';\n        const got = bytes ? `length=${len}` : `type=${typeof value}`;\n        throw new Error(prefix + 'expected Uint8Array' + ofLen + ', got ' + got);\n    }\n    return value;\n}\n// Used in weierstrass, der\nfunction numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? '0' + hex : hex;\n}\nfunction hexToNumber(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    return hex === '' ? _0n$3 : BigInt('0x' + hex); // Big Endian\n}\n// BE: Big Endian, LE: Little Endian\nfunction bytesToNumberBE(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nfunction bytesToNumberLE(bytes) {\n    abytes(bytes);\n    return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\n}\nfunction numberToBytesBE(n, len) {\n    return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\nfunction numberToBytesLE(n, len) {\n    return numberToBytesBE(n, len).reverse();\n}\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'secret key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */\nfunction ensureBytes(title, hex, expectedLength) {\n    let res;\n    if (typeof hex === 'string') {\n        try {\n            res = hexToBytes(hex);\n        }\n        catch (e) {\n            throw new Error(title + ' must be hex string or Uint8Array, cause: ' + e);\n        }\n    }\n    else if (isBytes(hex)) {\n        // Uint8Array.from() instead of hash.slice() because node.js Buffer\n        // is instance of Uint8Array, and its slice() creates **mutable** copy\n        res = Uint8Array.from(hex);\n    }\n    else {\n        throw new Error(title + ' must be hex string or Uint8Array');\n    }\n    const len = res.length;\n    if (typeof expectedLength === 'number' && len !== expectedLength)\n        throw new Error(title + ' of length ' + expectedLength + ' expected, got ' + len);\n    return res;\n}\n/**\n * Copies Uint8Array. We can't use u8a.slice(), because u8a can be Buffer,\n * and Buffer#slice creates mutable copy. Never use Buffers!\n */\nfunction copyBytes(bytes) {\n    return Uint8Array.from(bytes);\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\n// export const utf8ToBytes: typeof utf8ToBytes_ = utf8ToBytes_;\n/**\n * Converts bytes to string using UTF8 encoding.\n * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'\n */\n// export const bytesToUtf8: typeof bytesToUtf8_ = bytesToUtf8_;\n// Is positive bigint\nconst isPosBig = (n) => typeof n === 'bigint' && _0n$3 <= n;\nfunction inRange(n, min, max) {\n    return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;\n}\n/**\n * Asserts min <= n < max. NOTE: It's < max and not <= max.\n * @example\n * aInRange('x', x, 1n, 256n); // would assume x is in (1n..255n)\n */\nfunction aInRange(title, n, min, max) {\n    // Why min <= n < max and not a (min < n < max) OR b (min <= n <= max)?\n    // consider P=256n, min=0n, max=P\n    // - a for min=0 would require -1:          `inRange('x', x, -1n, P)`\n    // - b would commonly require subtraction:  `inRange('x', x, 0n, P - 1n)`\n    // - our way is the cleanest:               `inRange('x', x, 0n, P)\n    if (!inRange(n, min, max))\n        throw new Error('expected valid ' + title + ': ' + min + ' <= n < ' + max + ', got ' + n);\n}\n// Bit operations\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n * TODO: merge with nLength in modular\n */\nfunction bitLen(n) {\n    let len;\n    for (len = 0; n > _0n$3; n >>= _1n$3, len += 1)\n        ;\n    return len;\n}\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */\nconst bitMask = (n) => (_1n$3 << BigInt(n)) - _1n$3;\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\nfunction createHmacDrbg(hashLen, qByteLen, hmacFn) {\n    if (typeof hashLen !== 'number' || hashLen < 2)\n        throw new Error('hashLen must be a number');\n    if (typeof qByteLen !== 'number' || qByteLen < 2)\n        throw new Error('qByteLen must be a number');\n    if (typeof hmacFn !== 'function')\n        throw new Error('hmacFn must be a function');\n    // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n    const u8n = (len) => new Uint8Array(len); // creates Uint8Array\n    const u8of = (byte) => Uint8Array.of(byte); // another shortcut\n    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n    let i = 0; // Iterations counter, will throw when over 1000\n    const reset = () => {\n        v.fill(1);\n        k.fill(0);\n        i = 0;\n    };\n    const h = (...b) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n    const reseed = (seed = u8n(0)) => {\n        // HMAC-DRBG reseed() function. Steps D-G\n        k = h(u8of(0x00), seed); // k = hmac(k || v || 0x00 || seed)\n        v = h(); // v = hmac(k || v)\n        if (seed.length === 0)\n            return;\n        k = h(u8of(0x01), seed); // k = hmac(k || v || 0x01 || seed)\n        v = h(); // v = hmac(k || v)\n    };\n    const gen = () => {\n        // HMAC-DRBG generate() function\n        if (i++ >= 1000)\n            throw new Error('drbg: tried 1000 values');\n        let len = 0;\n        const out = [];\n        while (len < qByteLen) {\n            v = h();\n            const sl = v.slice();\n            out.push(sl);\n            len += v.length;\n        }\n        return concatBytes(...out);\n    };\n    const genUntil = (seed, pred) => {\n        reset();\n        reseed(seed); // Steps D-G\n        let res = undefined; // Step H: grind until k is in [1..n-1]\n        while (!(res = pred(gen())))\n            reseed();\n        reset();\n        return res;\n    };\n    return genUntil;\n}\nfunction _validateObject(object, fields, optFields = {}) {\n    if (!object || typeof object !== 'object')\n        throw new Error('expected valid options object');\n    function checkField(fieldName, expectedType, isOpt) {\n        const val = object[fieldName];\n        if (isOpt && val === undefined)\n            return;\n        const current = typeof val;\n        if (current !== expectedType || val === null)\n            throw new Error(`param \"${fieldName}\" is invalid: expected ${expectedType}, got ${current}`);\n    }\n    Object.entries(fields).forEach(([k, v]) => checkField(k, v, false));\n    Object.entries(optFields).forEach(([k, v]) => checkField(k, v, true));\n}\n/**\n * Memoizes (caches) computation result.\n * Uses WeakMap: the value is going auto-cleaned by GC after last reference is removed.\n */\nfunction memoized(fn) {\n    const map = new WeakMap();\n    return (arg, ...args) => {\n        const val = map.get(arg);\n        if (val !== undefined)\n            return val;\n        const computed = fn(arg, ...args);\n        map.set(arg, computed);\n        return computed;\n    };\n}\n\n/**\n * Utils for modular division and fields.\n * Field over 11 is a finite (Galois) field is integer number operations `mod 11`.\n * There is no division: it is replaced by modular multiplicative inverse.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// prettier-ignore\nconst _0n$2 = BigInt(0), _1n$2 = BigInt(1), _2n$1 = /* @__PURE__ */ BigInt(2), _3n$1 = /* @__PURE__ */ BigInt(3);\n// prettier-ignore\nconst _4n$1 = /* @__PURE__ */ BigInt(4), _5n = /* @__PURE__ */ BigInt(5), _7n = /* @__PURE__ */ BigInt(7);\n// prettier-ignore\nconst _8n = /* @__PURE__ */ BigInt(8), _9n = /* @__PURE__ */ BigInt(9), _16n = /* @__PURE__ */ BigInt(16);\n// Calculates a modulo b\nfunction mod(a, b) {\n    const result = a % b;\n    return result >= _0n$2 ? result : b + result;\n}\n/** Does `x^(2^power)` mod p. `pow2(30, 4)` == `30^(2^4)` */\nfunction pow2(x, power, modulo) {\n    let res = x;\n    while (power-- > _0n$2) {\n        res *= res;\n        res %= modulo;\n    }\n    return res;\n}\n/**\n * Inverses number over modulo.\n * Implemented using [Euclidean GCD](https://brilliant.org/wiki/extended-euclidean-algorithm/).\n */\nfunction invert(number, modulo) {\n    if (number === _0n$2)\n        throw new Error('invert: expected non-zero number');\n    if (modulo <= _0n$2)\n        throw new Error('invert: expected positive modulus, got ' + modulo);\n    // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n    let a = mod(number, modulo);\n    let b = modulo;\n    // prettier-ignore\n    let x = _0n$2, u = _1n$2;\n    while (a !== _0n$2) {\n        // JIT applies optimization if those two lines follow each other\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        // prettier-ignore\n        b = a, a = r, x = u, u = m;\n    }\n    const gcd = b;\n    if (gcd !== _1n$2)\n        throw new Error('invert: does not exist');\n    return mod(x, modulo);\n}\nfunction assertIsSquare(Fp, root, n) {\n    if (!Fp.eql(Fp.sqr(root), n))\n        throw new Error('Cannot find square root');\n}\n// Not all roots are possible! Example which will throw:\n// const NUM =\n// n = 72057594037927816n;\n// Fp = Field(BigInt('0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab'));\nfunction sqrt3mod4(Fp, n) {\n    const p1div4 = (Fp.ORDER + _1n$2) / _4n$1;\n    const root = Fp.pow(n, p1div4);\n    assertIsSquare(Fp, root, n);\n    return root;\n}\nfunction sqrt5mod8(Fp, n) {\n    const p5div8 = (Fp.ORDER - _5n) / _8n;\n    const n2 = Fp.mul(n, _2n$1);\n    const v = Fp.pow(n2, p5div8);\n    const nv = Fp.mul(n, v);\n    const i = Fp.mul(Fp.mul(nv, _2n$1), v);\n    const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n    assertIsSquare(Fp, root, n);\n    return root;\n}\n// Based on RFC9380, Kong algorithm\n// prettier-ignore\nfunction sqrt9mod16(P) {\n    const Fp_ = Field(P);\n    const tn = tonelliShanks(P);\n    const c1 = tn(Fp_, Fp_.neg(Fp_.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n    const c2 = tn(Fp_, c1); //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n    const c3 = tn(Fp_, Fp_.neg(c1)); //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n    const c4 = (P + _7n) / _16n; //  4. c4 = (q + 7) / 16        # Integer arithmetic\n    return (Fp, n) => {\n        let tv1 = Fp.pow(n, c4); //  1. tv1 = x^c4\n        let tv2 = Fp.mul(tv1, c1); //  2. tv2 = c1 * tv1\n        const tv3 = Fp.mul(tv1, c2); //  3. tv3 = c2 * tv1\n        const tv4 = Fp.mul(tv1, c3); //  4. tv4 = c3 * tv1\n        const e1 = Fp.eql(Fp.sqr(tv2), n); //  5.  e1 = (tv2^2) == x\n        const e2 = Fp.eql(Fp.sqr(tv3), n); //  6.  e2 = (tv3^2) == x\n        tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n        tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n        const e3 = Fp.eql(Fp.sqr(tv2), n); //  9.  e3 = (tv2^2) == x\n        const root = Fp.cmov(tv1, tv2, e3); // 10.  z = CMOV(tv1, tv2, e3)   # Select sqrt from tv1 & tv2\n        assertIsSquare(Fp, root, n);\n        return root;\n    };\n}\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */\nfunction tonelliShanks(P) {\n    // Initialization (precomputation).\n    // Caching initialization could boost perf by 7%.\n    if (P < _3n$1)\n        throw new Error('sqrt is not defined for small field');\n    // Factor P - 1 = Q * 2^S, where Q is odd\n    let Q = P - _1n$2;\n    let S = 0;\n    while (Q % _2n$1 === _0n$2) {\n        Q /= _2n$1;\n        S++;\n    }\n    // Find the first quadratic non-residue Z >= 2\n    let Z = _2n$1;\n    const _Fp = Field(P);\n    while (FpLegendre(_Fp, Z) === 1) {\n        // Basic primality test for P. After x iterations, chance of\n        // not finding quadratic non-residue is 2^x, so 2^1000.\n        if (Z++ > 1000)\n            throw new Error('Cannot find square root: probably non-prime P');\n    }\n    // Fast-path; usually done before Z, but we do \"primality test\".\n    if (S === 1)\n        return sqrt3mod4;\n    // Slow-path\n    // TODO: test on Fp2 and others\n    let cc = _Fp.pow(Z, Q); // c = z^Q\n    const Q1div2 = (Q + _1n$2) / _2n$1;\n    return function tonelliSlow(Fp, n) {\n        if (Fp.is0(n))\n            return n;\n        // Check if n is a quadratic residue using Legendre symbol\n        if (FpLegendre(Fp, n) !== 1)\n            throw new Error('Cannot find square root');\n        // Initialize variables for the main loop\n        let M = S;\n        let c = Fp.mul(Fp.ONE, cc); // c = z^Q, move cc from field _Fp into field Fp\n        let t = Fp.pow(n, Q); // t = n^Q, first guess at the fudge factor\n        let R = Fp.pow(n, Q1div2); // R = n^((Q+1)/2), first guess at the square root\n        // Main loop\n        // while t != 1\n        while (!Fp.eql(t, Fp.ONE)) {\n            if (Fp.is0(t))\n                return Fp.ZERO; // if t=0 return R=0\n            let i = 1;\n            // Find the smallest i >= 1 such that t^(2^i) ‚â° 1 (mod P)\n            let t_tmp = Fp.sqr(t); // t^(2^1)\n            while (!Fp.eql(t_tmp, Fp.ONE)) {\n                i++;\n                t_tmp = Fp.sqr(t_tmp); // t^(2^2)...\n                if (i === M)\n                    throw new Error('Cannot find square root');\n            }\n            // Calculate the exponent for b: 2^(M - i - 1)\n            const exponent = _1n$2 << BigInt(M - i - 1); // bigint is important\n            const b = Fp.pow(c, exponent); // b = 2^(M - i - 1)\n            // Update variables\n            M = i;\n            c = Fp.sqr(b); // c = b^2\n            t = Fp.mul(t, c); // t = (t * b^2)\n            R = Fp.mul(R, b); // R = R*b\n        }\n        return R;\n    };\n}\n/**\n * Square root for a finite field. Will try optimized versions first:\n *\n * 1. P ‚â° 3 (mod 4)\n * 2. P ‚â° 5 (mod 8)\n * 3. P ‚â° 9 (mod 16)\n * 4. Tonelli-Shanks algorithm\n *\n * Different algorithms can give different roots, it is up to user to decide which one they want.\n * For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n */\nfunction FpSqrt(P) {\n    // P ‚â° 3 (mod 4) => ‚àön = n^((P+1)/4)\n    if (P % _4n$1 === _3n$1)\n        return sqrt3mod4;\n    // P ‚â° 5 (mod 8) => Atkin algorithm, page 10 of https://eprint.iacr.org/2012/685.pdf\n    if (P % _8n === _5n)\n        return sqrt5mod8;\n    // P ‚â° 9 (mod 16) => Kong algorithm, page 11 of https://eprint.iacr.org/2012/685.pdf (algorithm 4)\n    if (P % _16n === _9n)\n        return sqrt9mod16(P);\n    // Tonelli-Shanks algorithm\n    return tonelliShanks(P);\n}\n// Little-endian check for first LE bit (last BE bit);\nconst isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n$2) === _1n$2;\n// prettier-ignore\nconst FIELD_FIELDS = [\n    'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',\n    'eql', 'add', 'sub', 'mul', 'pow', 'div',\n    'addN', 'subN', 'mulN', 'sqrN'\n];\nfunction validateField(field) {\n    const initial = {\n        ORDER: 'bigint',\n        MASK: 'bigint',\n        BYTES: 'number',\n        BITS: 'number',\n    };\n    const opts = FIELD_FIELDS.reduce((map, val) => {\n        map[val] = 'function';\n        return map;\n    }, initial);\n    _validateObject(field, opts);\n    // const max = 16384;\n    // if (field.BYTES < 1 || field.BYTES > max) throw new Error('invalid field');\n    // if (field.BITS < 1 || field.BITS > 8 * max) throw new Error('invalid field');\n    return field;\n}\n// Generic field functions\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */\nfunction FpPow(Fp, num, power) {\n    if (power < _0n$2)\n        throw new Error('invalid exponent, negatives unsupported');\n    if (power === _0n$2)\n        return Fp.ONE;\n    if (power === _1n$2)\n        return num;\n    let p = Fp.ONE;\n    let d = num;\n    while (power > _0n$2) {\n        if (power & _1n$2)\n            p = Fp.mul(p, d);\n        d = Fp.sqr(d);\n        power >>= _1n$2;\n    }\n    return p;\n}\n/**\n * Efficiently invert an array of Field elements.\n * Exception-free. Will return `undefined` for 0 elements.\n * @param passZero map 0 to 0 (instead of undefined)\n */\nfunction FpInvertBatch(Fp, nums, passZero = false) {\n    const inverted = new Array(nums.length).fill(passZero ? Fp.ZERO : undefined);\n    // Walk from first to last, multiply them by each other MOD p\n    const multipliedAcc = nums.reduce((acc, num, i) => {\n        if (Fp.is0(num))\n            return acc;\n        inverted[i] = acc;\n        return Fp.mul(acc, num);\n    }, Fp.ONE);\n    // Invert last element\n    const invertedAcc = Fp.inv(multipliedAcc);\n    // Walk from last to first, multiply them by inverted each other MOD p\n    nums.reduceRight((acc, num, i) => {\n        if (Fp.is0(num))\n            return acc;\n        inverted[i] = Fp.mul(acc, inverted[i]);\n        return Fp.mul(acc, num);\n    }, invertedAcc);\n    return inverted;\n}\n/**\n * Legendre symbol.\n * Legendre constant is used to calculate Legendre symbol (a | p)\n * which denotes the value of a^((p-1)/2) (mod p).\n *\n * * (a | p) ‚â° 1    if a is a square (mod p), quadratic residue\n * * (a | p) ‚â° -1   if a is not a square (mod p), quadratic non residue\n * * (a | p) ‚â° 0    if a ‚â° 0 (mod p)\n */\nfunction FpLegendre(Fp, n) {\n    // We can use 3rd argument as optional cache of this value\n    // but seems unneeded for now. The operation is very fast.\n    const p1mod2 = (Fp.ORDER - _1n$2) / _2n$1;\n    const powered = Fp.pow(n, p1mod2);\n    const yes = Fp.eql(powered, Fp.ONE);\n    const zero = Fp.eql(powered, Fp.ZERO);\n    const no = Fp.eql(powered, Fp.neg(Fp.ONE));\n    if (!yes && !zero && !no)\n        throw new Error('invalid Legendre symbol result');\n    return yes ? 1 : zero ? 0 : -1;\n}\n// CURVE.n lengths\nfunction nLength(n, nBitLength) {\n    // Bit size, byte size of CURVE.n\n    if (nBitLength !== undefined)\n        anumber(nBitLength);\n    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n    const nByteLength = Math.ceil(_nBitLength / 8);\n    return { nBitLength: _nBitLength, nByteLength };\n}\n/**\n * Creates a finite field. Major performance optimizations:\n * * 1. Denormalized operations like mulN instead of mul.\n * * 2. Identical object shape: never add or remove keys.\n * * 3. `Object.freeze`.\n * Fragile: always run a benchmark on a change.\n * Security note: operations don't check 'isValid' for all elements for performance reasons,\n * it is caller responsibility to check this.\n * This is low-level code, please make sure you know what you're doing.\n *\n * Note about field properties:\n * * CHARACTERISTIC p = prime number, number of elements in main subgroup.\n * * ORDER q = similar to cofactor in curves, may be composite `q = p^m`.\n *\n * @param ORDER field order, probably prime, or could be composite\n * @param bitLen how many bits the field consumes\n * @param isLE (default: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */\nfunction Field(ORDER, bitLenOrOpts, // TODO: use opts only in v2?\nisLE = false, opts = {}) {\n    if (ORDER <= _0n$2)\n        throw new Error('invalid field: expected ORDER > 0, got ' + ORDER);\n    let _nbitLength = undefined;\n    let _sqrt = undefined;\n    let modFromBytes = false;\n    let allowedLengths = undefined;\n    if (typeof bitLenOrOpts === 'object' && bitLenOrOpts != null) {\n        if (opts.sqrt || isLE)\n            throw new Error('cannot specify opts in two arguments');\n        const _opts = bitLenOrOpts;\n        if (_opts.BITS)\n            _nbitLength = _opts.BITS;\n        if (_opts.sqrt)\n            _sqrt = _opts.sqrt;\n        if (typeof _opts.isLE === 'boolean')\n            isLE = _opts.isLE;\n        if (typeof _opts.modFromBytes === 'boolean')\n            modFromBytes = _opts.modFromBytes;\n        allowedLengths = _opts.allowedLengths;\n    }\n    else {\n        if (typeof bitLenOrOpts === 'number')\n            _nbitLength = bitLenOrOpts;\n        if (opts.sqrt)\n            _sqrt = opts.sqrt;\n    }\n    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, _nbitLength);\n    if (BYTES > 2048)\n        throw new Error('invalid field: expected ORDER of <= 2048 bytes');\n    let sqrtP; // cached sqrtP\n    const f = Object.freeze({\n        ORDER,\n        isLE,\n        BITS,\n        BYTES,\n        MASK: bitMask(BITS),\n        ZERO: _0n$2,\n        ONE: _1n$2,\n        allowedLengths: allowedLengths,\n        create: (num) => mod(num, ORDER),\n        isValid: (num) => {\n            if (typeof num !== 'bigint')\n                throw new Error('invalid field element: expected bigint, got ' + typeof num);\n            return _0n$2 <= num && num < ORDER; // 0 is valid element, but it's not invertible\n        },\n        is0: (num) => num === _0n$2,\n        // is valid and invertible\n        isValidNot0: (num) => !f.is0(num) && f.isValid(num),\n        isOdd: (num) => (num & _1n$2) === _1n$2,\n        neg: (num) => mod(-num, ORDER),\n        eql: (lhs, rhs) => lhs === rhs,\n        sqr: (num) => mod(num * num, ORDER),\n        add: (lhs, rhs) => mod(lhs + rhs, ORDER),\n        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),\n        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),\n        pow: (num, power) => FpPow(f, num, power),\n        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),\n        // Same as above, but doesn't normalize\n        sqrN: (num) => num * num,\n        addN: (lhs, rhs) => lhs + rhs,\n        subN: (lhs, rhs) => lhs - rhs,\n        mulN: (lhs, rhs) => lhs * rhs,\n        inv: (num) => invert(num, ORDER),\n        sqrt: _sqrt ||\n            ((n) => {\n                if (!sqrtP)\n                    sqrtP = FpSqrt(ORDER);\n                return sqrtP(f, n);\n            }),\n        toBytes: (num) => (isLE ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES)),\n        fromBytes: (bytes, skipValidation = true) => {\n            if (allowedLengths) {\n                if (!allowedLengths.includes(bytes.length) || bytes.length > BYTES) {\n                    throw new Error('Field.fromBytes: expected ' + allowedLengths + ' bytes, got ' + bytes.length);\n                }\n                const padded = new Uint8Array(BYTES);\n                // isLE add 0 to right, !isLE to the left.\n                padded.set(bytes, isLE ? 0 : padded.length - bytes.length);\n                bytes = padded;\n            }\n            if (bytes.length !== BYTES)\n                throw new Error('Field.fromBytes: expected ' + BYTES + ' bytes, got ' + bytes.length);\n            let scalar = isLE ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);\n            if (modFromBytes)\n                scalar = mod(scalar, ORDER);\n            if (!skipValidation)\n                if (!f.isValid(scalar))\n                    throw new Error('invalid field element: outside of range 0..ORDER');\n            // NOTE: we don't validate scalar here, please use isValid. This done such way because some\n            // protocol may allow non-reduced scalar that reduced later or changed some other way.\n            return scalar;\n        },\n        // TODO: we don't need it here, move out to separate fn\n        invertBatch: (lst) => FpInvertBatch(f, lst),\n        // We can't move this out because Fp6, Fp12 implement it\n        // and it's unclear what to return in there.\n        cmov: (a, b, c) => (c ? b : a),\n    });\n    return Object.freeze(f);\n}\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */\nfunction getFieldBytesLength(fieldOrder) {\n    if (typeof fieldOrder !== 'bigint')\n        throw new Error('field order must be bigint');\n    const bitLength = fieldOrder.toString(2).length;\n    return Math.ceil(bitLength / 8);\n}\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */\nfunction getMinHashLength(fieldOrder) {\n    const length = getFieldBytesLength(fieldOrder);\n    return length + Math.ceil(length / 2);\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */\nfunction mapHashToField(key, fieldOrder, isLE = false) {\n    const len = key.length;\n    const fieldLen = getFieldBytesLength(fieldOrder);\n    const minLen = getMinHashLength(fieldOrder);\n    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n    if (len < 16 || len < minLen || len > 1024)\n        throw new Error('expected ' + minLen + '-1024 bytes of input, got ' + len);\n    const num = isLE ? bytesToNumberLE(key) : bytesToNumberBE(key);\n    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n    const reduced = mod(num, fieldOrder - _1n$2) + _1n$2;\n    return isLE ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);\n}\n\n/**\n * Methods for elliptic curve multiplication by scalars.\n * Contains wNAF, pippenger.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nconst _0n$1 = BigInt(0);\nconst _1n$1 = BigInt(1);\nfunction negateCt(condition, item) {\n    const neg = item.negate();\n    return condition ? neg : item;\n}\n/**\n * Takes a bunch of Projective Points but executes only one\n * inversion on all of them. Inversion is very slow operation,\n * so this improves performance massively.\n * Optimization: converts a list of projective points to a list of identical points with Z=1.\n */\nfunction normalizeZ(c, points) {\n    const invertedZs = FpInvertBatch(c.Fp, points.map((p) => p.Z));\n    return points.map((p, i) => c.fromAffine(p.toAffine(invertedZs[i])));\n}\nfunction validateW(W, bits) {\n    if (!Number.isSafeInteger(W) || W <= 0 || W > bits)\n        throw new Error('invalid window size, expected [1..' + bits + '], got W=' + W);\n}\nfunction calcWOpts(W, scalarBits) {\n    validateW(W, scalarBits);\n    const windows = Math.ceil(scalarBits / W) + 1; // W=8 33. Not 32, because we skip zero\n    const windowSize = 2 ** (W - 1); // W=8 128. Not 256, because we skip zero\n    const maxNumber = 2 ** W; // W=8 256\n    const mask = bitMask(W); // W=8 255 == mask 0b11111111\n    const shiftBy = BigInt(W); // W=8 8\n    return { windows, windowSize, mask, maxNumber, shiftBy };\n}\nfunction calcOffsets(n, window, wOpts) {\n    const { windowSize, mask, maxNumber, shiftBy } = wOpts;\n    let wbits = Number(n & mask); // extract W bits.\n    let nextN = n >> shiftBy; // shift number by W bits.\n    // What actually happens here:\n    // const highestBit = Number(mask ^ (mask >> 1n));\n    // let wbits2 = wbits - 1; // skip zero\n    // if (wbits2 & highestBit) { wbits2 ^= Number(mask); // (~);\n    // split if bits > max: +224 => 256-32\n    if (wbits > windowSize) {\n        // we skip zero, which means instead of `>= size-1`, we do `> size`\n        wbits -= maxNumber; // -32, can be maxNumber - wbits, but then we need to set isNeg here.\n        nextN += _1n$1; // +256 (carry)\n    }\n    const offsetStart = window * windowSize;\n    const offset = offsetStart + Math.abs(wbits) - 1; // -1 because we skip zero\n    const isZero = wbits === 0; // is current window slice a 0?\n    const isNeg = wbits < 0; // is current window slice negative?\n    const isNegF = window % 2 !== 0; // fake random statement for noise\n    const offsetF = offsetStart; // fake offset for noise\n    return { nextN, offset, isZero, isNeg, isNegF, offsetF };\n}\nfunction validateMSMPoints(points, c) {\n    if (!Array.isArray(points))\n        throw new Error('array expected');\n    points.forEach((p, i) => {\n        if (!(p instanceof c))\n            throw new Error('invalid point at index ' + i);\n    });\n}\nfunction validateMSMScalars(scalars, field) {\n    if (!Array.isArray(scalars))\n        throw new Error('array of scalars expected');\n    scalars.forEach((s, i) => {\n        if (!field.isValid(s))\n            throw new Error('invalid scalar at index ' + i);\n    });\n}\n// Since points in different groups cannot be equal (different object constructor),\n// we can have single place to store precomputes.\n// Allows to make points frozen / immutable.\nconst pointPrecomputes = new WeakMap();\nconst pointWindowSizes = new WeakMap();\nfunction getW(P) {\n    // To disable precomputes:\n    // return 1;\n    return pointWindowSizes.get(P) || 1;\n}\nfunction assert0(n) {\n    if (n !== _0n$1)\n        throw new Error('invalid wNAF');\n}\n/**\n * Elliptic curve multiplication of Point by scalar. Fragile.\n * Table generation takes **30MB of ram and 10ms on high-end CPU**,\n * but may take much longer on slow devices. Actual generation will happen on\n * first call of `multiply()`. By default, `BASE` point is precomputed.\n *\n * Scalars should always be less than curve order: this should be checked inside of a curve itself.\n * Creates precomputation tables for fast multiplication:\n * - private scalar is split by fixed size windows of W bits\n * - every window point is collected from window's table & added to accumulator\n * - since windows are different, same point inside tables won't be accessed more than once per calc\n * - each multiplication is 'Math.ceil(CURVE_ORDER / ùëä) + 1' point additions (fixed for any scalar)\n * - +1 window is neccessary for wNAF\n * - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n *\n * @todo Research returning 2d JS array of windows, instead of a single window.\n * This would allow windows to be in different memory locations\n */\nclass wNAF {\n    // Parametrized with a given Point class (not individual point)\n    constructor(Point, bits) {\n        this.BASE = Point.BASE;\n        this.ZERO = Point.ZERO;\n        this.Fn = Point.Fn;\n        this.bits = bits;\n    }\n    // non-const time multiplication ladder\n    _unsafeLadder(elm, n, p = this.ZERO) {\n        let d = elm;\n        while (n > _0n$1) {\n            if (n & _1n$1)\n                p = p.add(d);\n            d = d.double();\n            n >>= _1n$1;\n        }\n        return p;\n    }\n    /**\n     * Creates a wNAF precomputation window. Used for caching.\n     * Default window size is set by `utils.precompute()` and is equal to 8.\n     * Number of precomputed points depends on the curve size:\n     * 2^(ùëä‚àí1) * (Math.ceil(ùëõ / ùëä) + 1), where:\n     * - ùëä is the window size\n     * - ùëõ is the bitlength of the curve order.\n     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n     * @param point Point instance\n     * @param W window size\n     * @returns precomputed point tables flattened to a single array\n     */\n    precomputeWindow(point, W) {\n        const { windows, windowSize } = calcWOpts(W, this.bits);\n        const points = [];\n        let p = point;\n        let base = p;\n        for (let window = 0; window < windows; window++) {\n            base = p;\n            points.push(base);\n            // i=1, bc we skip 0\n            for (let i = 1; i < windowSize; i++) {\n                base = base.add(p);\n                points.push(base);\n            }\n            p = base.double();\n        }\n        return points;\n    }\n    /**\n     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n     * More compact implementation:\n     * https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541\n     * @returns real and fake (for const-time) points\n     */\n    wNAF(W, precomputes, n) {\n        // Scalar should be smaller than field order\n        if (!this.Fn.isValid(n))\n            throw new Error('invalid scalar');\n        // Accumulators\n        let p = this.ZERO;\n        let f = this.BASE;\n        // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n        // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n        // there is negate now: it is possible that negated element from low value\n        // would be the same as high element, which will create carry into next window.\n        // It's not obvious how this can fail, but still worth investigating later.\n        const wo = calcWOpts(W, this.bits);\n        for (let window = 0; window < wo.windows; window++) {\n            // (n === _0n) is handled and not early-exited. isEven and offsetF are used for noise\n            const { nextN, offset, isZero, isNeg, isNegF, offsetF } = calcOffsets(n, window, wo);\n            n = nextN;\n            if (isZero) {\n                // bits are 0: add garbage to fake point\n                // Important part for const-time getPublicKey: add random \"noise\" point to f.\n                f = f.add(negateCt(isNegF, precomputes[offsetF]));\n            }\n            else {\n                // bits are 1: add to result point\n                p = p.add(negateCt(isNeg, precomputes[offset]));\n            }\n        }\n        assert0(n);\n        // Return both real and fake points: JIT won't eliminate f.\n        // At this point there is a way to F be infinity-point even if p is not,\n        // which makes it less const-time: around 1 bigint multiply.\n        return { p, f };\n    }\n    /**\n     * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.\n     * @param acc accumulator point to add result of multiplication\n     * @returns point\n     */\n    wNAFUnsafe(W, precomputes, n, acc = this.ZERO) {\n        const wo = calcWOpts(W, this.bits);\n        for (let window = 0; window < wo.windows; window++) {\n            if (n === _0n$1)\n                break; // Early-exit, skip 0 value\n            const { nextN, offset, isZero, isNeg } = calcOffsets(n, window, wo);\n            n = nextN;\n            if (isZero) {\n                // Window bits are 0: skip processing.\n                // Move to next window.\n                continue;\n            }\n            else {\n                const item = precomputes[offset];\n                acc = acc.add(isNeg ? item.negate() : item); // Re-using acc allows to save adds in MSM\n            }\n        }\n        assert0(n);\n        return acc;\n    }\n    getPrecomputes(W, point, transform) {\n        // Calculate precomputes on a first run, reuse them after\n        let comp = pointPrecomputes.get(point);\n        if (!comp) {\n            comp = this.precomputeWindow(point, W);\n            if (W !== 1) {\n                // Doing transform outside of if brings 15% perf hit\n                if (typeof transform === 'function')\n                    comp = transform(comp);\n                pointPrecomputes.set(point, comp);\n            }\n        }\n        return comp;\n    }\n    cached(point, scalar, transform) {\n        const W = getW(point);\n        return this.wNAF(W, this.getPrecomputes(W, point, transform), scalar);\n    }\n    unsafe(point, scalar, transform, prev) {\n        const W = getW(point);\n        if (W === 1)\n            return this._unsafeLadder(point, scalar, prev); // For W=1 ladder is ~x2 faster\n        return this.wNAFUnsafe(W, this.getPrecomputes(W, point, transform), scalar, prev);\n    }\n    // We calculate precomputes for elliptic curve point multiplication\n    // using windowed method. This specifies window size and\n    // stores precomputed values. Usually only base point would be precomputed.\n    createCache(P, W) {\n        validateW(W, this.bits);\n        pointWindowSizes.set(P, W);\n        pointPrecomputes.delete(P);\n    }\n    hasCache(elm) {\n        return getW(elm) !== 1;\n    }\n}\n/**\n * Endomorphism-specific multiplication for Koblitz curves.\n * Cost: 128 dbl, 0-256 adds.\n */\nfunction mulEndoUnsafe(Point, point, k1, k2) {\n    let acc = point;\n    let p1 = Point.ZERO;\n    let p2 = Point.ZERO;\n    while (k1 > _0n$1 || k2 > _0n$1) {\n        if (k1 & _1n$1)\n            p1 = p1.add(acc);\n        if (k2 & _1n$1)\n            p2 = p2.add(acc);\n        acc = acc.double();\n        k1 >>= _1n$1;\n        k2 >>= _1n$1;\n    }\n    return { p1, p2 };\n}\n/**\n * Pippenger algorithm for multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * 30x faster vs naive addition on L=4096, 10x faster than precomputes.\n * For N=254bit, L=1, it does: 1024 ADD + 254 DBL. For L=5: 1536 ADD + 254 DBL.\n * Algorithmically constant-time (for same L), even when 1 point + scalar, or when scalar = 0.\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @param scalars array of L scalars (aka secret keys / bigints)\n */\nfunction pippenger(c, fieldN, points, scalars) {\n    // If we split scalars by some window (let's say 8 bits), every chunk will only\n    // take 256 buckets even if there are 4096 scalars, also re-uses double.\n    // TODO:\n    // - https://eprint.iacr.org/2024/750.pdf\n    // - https://tches.iacr.org/index.php/TCHES/article/view/10287\n    // 0 is accepted in scalars\n    validateMSMPoints(points, c);\n    validateMSMScalars(scalars, fieldN);\n    const plength = points.length;\n    const slength = scalars.length;\n    if (plength !== slength)\n        throw new Error('arrays of points and scalars must have equal length');\n    // if (plength === 0) throw new Error('array must be of length >= 2');\n    const zero = c.ZERO;\n    const wbits = bitLen(BigInt(plength));\n    let windowSize = 1; // bits\n    if (wbits > 12)\n        windowSize = wbits - 3;\n    else if (wbits > 4)\n        windowSize = wbits - 2;\n    else if (wbits > 0)\n        windowSize = 2;\n    const MASK = bitMask(windowSize);\n    const buckets = new Array(Number(MASK) + 1).fill(zero); // +1 for zero array\n    const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;\n    let sum = zero;\n    for (let i = lastBits; i >= 0; i -= windowSize) {\n        buckets.fill(zero);\n        for (let j = 0; j < slength; j++) {\n            const scalar = scalars[j];\n            const wbits = Number((scalar >> BigInt(i)) & MASK);\n            buckets[wbits] = buckets[wbits].add(points[j]);\n        }\n        let resI = zero; // not using this will do small speed-up, but will lose ct\n        // Skip first bucket, because it is zero\n        for (let j = buckets.length - 1, sumI = zero; j > 0; j--) {\n            sumI = sumI.add(buckets[j]);\n            resI = resI.add(sumI);\n        }\n        sum = sum.add(resI);\n        if (i !== 0)\n            for (let j = 0; j < windowSize; j++)\n                sum = sum.double();\n    }\n    return sum;\n}\nfunction createField(order, field, isLE) {\n    if (field) {\n        if (field.ORDER !== order)\n            throw new Error('Field.ORDER must match order: Fp == p, Fn == n');\n        validateField(field);\n        return field;\n    }\n    else {\n        return Field(order, { isLE });\n    }\n}\n/** Validates CURVE opts and creates fields */\nfunction _createCurveFields(type, CURVE, curveOpts = {}, FpFnLE) {\n    if (FpFnLE === undefined)\n        FpFnLE = type === 'edwards';\n    if (!CURVE || typeof CURVE !== 'object')\n        throw new Error(`expected valid ${type} CURVE object`);\n    for (const p of ['p', 'n', 'h']) {\n        const val = CURVE[p];\n        if (!(typeof val === 'bigint' && val > _0n$1))\n            throw new Error(`CURVE.${p} must be positive bigint`);\n    }\n    const Fp = createField(CURVE.p, curveOpts.Fp, FpFnLE);\n    const Fn = createField(CURVE.n, curveOpts.Fn, FpFnLE);\n    const _b = type === 'weierstrass' ? 'b' : 'd';\n    const params = ['Gx', 'Gy', 'a', _b];\n    for (const p of params) {\n        // @ts-ignore\n        if (!Fp.isValid(CURVE[p]))\n            throw new Error(`CURVE.${p} must be valid field element of CURVE.Fp`);\n    }\n    CURVE = Object.freeze(Object.assign({}, CURVE));\n    return { CURVE, Fp, Fn };\n}\n\n/**\n * Short Weierstrass curve methods. The formula is: y¬≤ = x¬≥ + ax + b.\n *\n * ### Design rationale for types\n *\n * * Interaction between classes from different curves should fail:\n *   `k256.Point.BASE.add(p256.Point.BASE)`\n * * For this purpose we want to use `instanceof` operator, which is fast and works during runtime\n * * Different calls of `curve()` would return different classes -\n *   `curve(params) !== curve(params)`: if somebody decided to monkey-patch their curve,\n *   it won't affect others\n *\n * TypeScript can't infer types for classes created inside a function. Classes is one instance\n * of nominative types in TypeScript and interfaces only check for shape, so it's hard to create\n * unique type for every function call.\n *\n * We can use generic types via some param, like curve opts, but that would:\n *     1. Enable interaction between `curve(params)` and `curve(params)` (curves of same params)\n *     which is hard to debug.\n *     2. Params can be generic and we can't enforce them to be constant value:\n *     if somebody creates curve from non-constant params,\n *     it would be allowed to interact with other curves with non-constant params\n *\n * @todo https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html#unique-symbol\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// We construct basis in such way that den is always positive and equals n, but num sign depends on basis (not on secret value)\nconst divNearest = (num, den) => (num + (num >= 0 ? den : -den) / _2n) / den;\n/**\n * Splits scalar for GLV endomorphism.\n */\nfunction _splitEndoScalar(k, basis, n) {\n    // Split scalar into two such that part is ~half bits: `abs(part) < sqrt(N)`\n    // Since part can be negative, we need to do this on point.\n    // TODO: verifyScalar function which consumes lambda\n    const [[a1, b1], [a2, b2]] = basis;\n    const c1 = divNearest(b2 * k, n);\n    const c2 = divNearest(-b1 * k, n);\n    // |k1|/|k2| is < sqrt(N), but can be negative.\n    // If we do `k1 mod N`, we'll get big scalar (`> sqrt(N)`): so, we do cheaper negation instead.\n    let k1 = k - c1 * a1 - c2 * a2;\n    let k2 = -c1 * b1 - c2 * b2;\n    const k1neg = k1 < _0n;\n    const k2neg = k2 < _0n;\n    if (k1neg)\n        k1 = -k1;\n    if (k2neg)\n        k2 = -k2;\n    // Double check that resulting scalar less than half bits of N: otherwise wNAF will fail.\n    // This should only happen on wrong basises. Also, math inside is too complex and I don't trust it.\n    const MAX_NUM = bitMask(Math.ceil(bitLen(n) / 2)) + _1n; // Half bits of N\n    if (k1 < _0n || k1 >= MAX_NUM || k2 < _0n || k2 >= MAX_NUM) {\n        throw new Error('splitScalar (endomorphism): failed, k=' + k);\n    }\n    return { k1neg, k1, k2neg, k2 };\n}\nfunction validateSigFormat(format) {\n    if (!['compact', 'recovered', 'der'].includes(format))\n        throw new Error('Signature format must be \"compact\", \"recovered\", or \"der\"');\n    return format;\n}\nfunction validateSigOpts(opts, def) {\n    const optsn = {};\n    for (let optName of Object.keys(def)) {\n        // @ts-ignore\n        optsn[optName] = opts[optName] === undefined ? def[optName] : opts[optName];\n    }\n    _abool2(optsn.lowS, 'lowS');\n    _abool2(optsn.prehash, 'prehash');\n    if (optsn.format !== undefined)\n        validateSigFormat(optsn.format);\n    return optsn;\n}\nclass DERErr extends Error {\n    constructor(m = '') {\n        super(m);\n    }\n}\n/**\n * ASN.1 DER encoding utilities. ASN is very complex & fragile. Format:\n *\n *     [0x30 (SEQUENCE), bytelength, 0x02 (INTEGER), intLength, R, 0x02 (INTEGER), intLength, S]\n *\n * Docs: https://letsencrypt.org/docs/a-warm-welcome-to-asn1-and-der/, https://luca.ntop.org/Teaching/Appunti/asn1.html\n */\nconst DER = {\n    // asn.1 DER encoding utils\n    Err: DERErr,\n    // Basic building block is TLV (Tag-Length-Value)\n    _tlv: {\n        encode: (tag, data) => {\n            const { Err: E } = DER;\n            if (tag < 0 || tag > 256)\n                throw new E('tlv.encode: wrong tag');\n            if (data.length & 1)\n                throw new E('tlv.encode: unpadded data');\n            const dataLen = data.length / 2;\n            const len = numberToHexUnpadded(dataLen);\n            if ((len.length / 2) & 128)\n                throw new E('tlv.encode: long form length too big');\n            // length of length with long form flag\n            const lenLen = dataLen > 127 ? numberToHexUnpadded((len.length / 2) | 128) : '';\n            const t = numberToHexUnpadded(tag);\n            return t + lenLen + len + data;\n        },\n        // v - value, l - left bytes (unparsed)\n        decode(tag, data) {\n            const { Err: E } = DER;\n            let pos = 0;\n            if (tag < 0 || tag > 256)\n                throw new E('tlv.encode: wrong tag');\n            if (data.length < 2 || data[pos++] !== tag)\n                throw new E('tlv.decode: wrong tlv');\n            const first = data[pos++];\n            const isLong = !!(first & 128); // First bit of first length byte is flag for short/long form\n            let length = 0;\n            if (!isLong)\n                length = first;\n            else {\n                // Long form: [longFlag(1bit), lengthLength(7bit), length (BE)]\n                const lenLen = first & 127;\n                if (!lenLen)\n                    throw new E('tlv.decode(long): indefinite length not supported');\n                if (lenLen > 4)\n                    throw new E('tlv.decode(long): byte length is too big'); // this will overflow u32 in js\n                const lengthBytes = data.subarray(pos, pos + lenLen);\n                if (lengthBytes.length !== lenLen)\n                    throw new E('tlv.decode: length bytes not complete');\n                if (lengthBytes[0] === 0)\n                    throw new E('tlv.decode(long): zero leftmost byte');\n                for (const b of lengthBytes)\n                    length = (length << 8) | b;\n                pos += lenLen;\n                if (length < 128)\n                    throw new E('tlv.decode(long): not minimal encoding');\n            }\n            const v = data.subarray(pos, pos + length);\n            if (v.length !== length)\n                throw new E('tlv.decode: wrong value length');\n            return { v, l: data.subarray(pos + length) };\n        },\n    },\n    // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n    // since we always use positive integers here. It must always be empty:\n    // - add zero byte if exists\n    // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n    _int: {\n        encode(num) {\n            const { Err: E } = DER;\n            if (num < _0n)\n                throw new E('integer: negative integers are not allowed');\n            let hex = numberToHexUnpadded(num);\n            // Pad with zero byte if negative flag is present\n            if (Number.parseInt(hex[0], 16) & 0b1000)\n                hex = '00' + hex;\n            if (hex.length & 1)\n                throw new E('unexpected DER parsing assertion: unpadded hex');\n            return hex;\n        },\n        decode(data) {\n            const { Err: E } = DER;\n            if (data[0] & 128)\n                throw new E('invalid signature integer: negative');\n            if (data[0] === 0x00 && !(data[1] & 128))\n                throw new E('invalid signature integer: unnecessary leading zero');\n            return bytesToNumberBE(data);\n        },\n    },\n    toSig(hex) {\n        // parse DER signature\n        const { Err: E, _int: int, _tlv: tlv } = DER;\n        const data = ensureBytes('signature', hex);\n        const { v: seqBytes, l: seqLeftBytes } = tlv.decode(0x30, data);\n        if (seqLeftBytes.length)\n            throw new E('invalid signature: left bytes after parsing');\n        const { v: rBytes, l: rLeftBytes } = tlv.decode(0x02, seqBytes);\n        const { v: sBytes, l: sLeftBytes } = tlv.decode(0x02, rLeftBytes);\n        if (sLeftBytes.length)\n            throw new E('invalid signature: left bytes after parsing');\n        return { r: int.decode(rBytes), s: int.decode(sBytes) };\n    },\n    hexFromSig(sig) {\n        const { _tlv: tlv, _int: int } = DER;\n        const rs = tlv.encode(0x02, int.encode(sig.r));\n        const ss = tlv.encode(0x02, int.encode(sig.s));\n        const seq = rs + ss;\n        return tlv.encode(0x30, seq);\n    },\n};\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\nfunction _normFnElement(Fn, key) {\n    const { BYTES: expected } = Fn;\n    let num;\n    if (typeof key === 'bigint') {\n        num = key;\n    }\n    else {\n        let bytes = ensureBytes('private key', key);\n        try {\n            num = Fn.fromBytes(bytes);\n        }\n        catch (error) {\n            throw new Error(`invalid private key: expected ui8a of size ${expected}, got ${typeof key}`);\n        }\n    }\n    if (!Fn.isValidNot0(num))\n        throw new Error('invalid private key: out of range [1..N-1]');\n    return num;\n}\n/**\n * Creates weierstrass Point constructor, based on specified curve options.\n *\n * @example\n```js\nconst opts = {\n  p: BigInt('0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff'),\n  n: BigInt('0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551'),\n  h: BigInt(1),\n  a: BigInt('0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc'),\n  b: BigInt('0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b'),\n  Gx: BigInt('0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296'),\n  Gy: BigInt('0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5'),\n};\nconst p256_Point = weierstrass(opts);\n```\n */\nfunction weierstrassN(params, extraOpts = {}) {\n    const validated = _createCurveFields('weierstrass', params, extraOpts);\n    const { Fp, Fn } = validated;\n    let CURVE = validated.CURVE;\n    const { h: cofactor, n: CURVE_ORDER } = CURVE;\n    _validateObject(extraOpts, {}, {\n        allowInfinityPoint: 'boolean',\n        clearCofactor: 'function',\n        isTorsionFree: 'function',\n        fromBytes: 'function',\n        toBytes: 'function',\n        endo: 'object',\n        wrapPrivateKey: 'boolean',\n    });\n    const { endo } = extraOpts;\n    if (endo) {\n        // validateObject(endo, { beta: 'bigint', splitScalar: 'function' });\n        if (!Fp.is0(CURVE.a) || typeof endo.beta !== 'bigint' || !Array.isArray(endo.basises)) {\n            throw new Error('invalid endo: expected \"beta\": bigint and \"basises\": array');\n        }\n    }\n    const lengths = getWLengths(Fp, Fn);\n    function assertCompressionIsSupported() {\n        if (!Fp.isOdd)\n            throw new Error('compression is not supported: Field does not have .isOdd()');\n    }\n    // Implements IEEE P1363 point encoding\n    function pointToBytes(_c, point, isCompressed) {\n        const { x, y } = point.toAffine();\n        const bx = Fp.toBytes(x);\n        _abool2(isCompressed, 'isCompressed');\n        if (isCompressed) {\n            assertCompressionIsSupported();\n            const hasEvenY = !Fp.isOdd(y);\n            return concatBytes(pprefix(hasEvenY), bx);\n        }\n        else {\n            return concatBytes(Uint8Array.of(0x04), bx, Fp.toBytes(y));\n        }\n    }\n    function pointFromBytes(bytes) {\n        _abytes2(bytes, undefined, 'Point');\n        const { publicKey: comp, publicKeyUncompressed: uncomp } = lengths; // e.g. for 32-byte: 33, 65\n        const length = bytes.length;\n        const head = bytes[0];\n        const tail = bytes.subarray(1);\n        // No actual validation is done here: use .assertValidity()\n        if (length === comp && (head === 0x02 || head === 0x03)) {\n            const x = Fp.fromBytes(tail);\n            if (!Fp.isValid(x))\n                throw new Error('bad point: is not on curve, wrong x');\n            const y2 = weierstrassEquation(x); // y¬≤ = x¬≥ + ax + b\n            let y;\n            try {\n                y = Fp.sqrt(y2); // y = y¬≤ ^ (p+1)/4\n            }\n            catch (sqrtError) {\n                const err = sqrtError instanceof Error ? ': ' + sqrtError.message : '';\n                throw new Error('bad point: is not on curve, sqrt error' + err);\n            }\n            assertCompressionIsSupported();\n            const isYOdd = Fp.isOdd(y); // (y & _1n) === _1n;\n            const isHeadOdd = (head & 1) === 1; // ECDSA-specific\n            if (isHeadOdd !== isYOdd)\n                y = Fp.neg(y);\n            return { x, y };\n        }\n        else if (length === uncomp && head === 0x04) {\n            // TODO: more checks\n            const L = Fp.BYTES;\n            const x = Fp.fromBytes(tail.subarray(0, L));\n            const y = Fp.fromBytes(tail.subarray(L, L * 2));\n            if (!isValidXY(x, y))\n                throw new Error('bad point: is not on curve');\n            return { x, y };\n        }\n        else {\n            throw new Error(`bad point: got length ${length}, expected compressed=${comp} or uncompressed=${uncomp}`);\n        }\n    }\n    const encodePoint = extraOpts.toBytes || pointToBytes;\n    const decodePoint = extraOpts.fromBytes || pointFromBytes;\n    function weierstrassEquation(x) {\n        const x2 = Fp.sqr(x); // x * x\n        const x3 = Fp.mul(x2, x); // x¬≤ * x\n        return Fp.add(Fp.add(x3, Fp.mul(x, CURVE.a)), CURVE.b); // x¬≥ + a * x + b\n    }\n    // TODO: move top-level\n    /** Checks whether equation holds for given x, y: y¬≤ == x¬≥ + ax + b */\n    function isValidXY(x, y) {\n        const left = Fp.sqr(y); // y¬≤\n        const right = weierstrassEquation(x); // x¬≥ + ax + b\n        return Fp.eql(left, right);\n    }\n    // Validate whether the passed curve params are valid.\n    // Test 1: equation y¬≤ = x¬≥ + ax + b should work for generator point.\n    if (!isValidXY(CURVE.Gx, CURVE.Gy))\n        throw new Error('bad curve params: generator point');\n    // Test 2: discriminant Œî part should be non-zero: 4a¬≥ + 27b¬≤ != 0.\n    // Guarantees curve is genus-1, smooth (non-singular).\n    const _4a3 = Fp.mul(Fp.pow(CURVE.a, _3n), _4n);\n    const _27b2 = Fp.mul(Fp.sqr(CURVE.b), BigInt(27));\n    if (Fp.is0(Fp.add(_4a3, _27b2)))\n        throw new Error('bad curve params: a or b');\n    /** Asserts coordinate is valid: 0 <= n < Fp.ORDER. */\n    function acoord(title, n, banZero = false) {\n        if (!Fp.isValid(n) || (banZero && Fp.is0(n)))\n            throw new Error(`bad point coordinate ${title}`);\n        return n;\n    }\n    function aprjpoint(other) {\n        if (!(other instanceof Point))\n            throw new Error('ProjectivePoint expected');\n    }\n    function splitEndoScalarN(k) {\n        if (!endo || !endo.basises)\n            throw new Error('no endo');\n        return _splitEndoScalar(k, endo.basises, Fn.ORDER);\n    }\n    // Memoized toAffine / validity check. They are heavy. Points are immutable.\n    // Converts Projective point to affine (x, y) coordinates.\n    // Can accept precomputed Z^-1 - for example, from invertBatch.\n    // (X, Y, Z) ‚àã (x=X/Z, y=Y/Z)\n    const toAffineMemo = memoized((p, iz) => {\n        const { X, Y, Z } = p;\n        // Fast-path for normalized points\n        if (Fp.eql(Z, Fp.ONE))\n            return { x: X, y: Y };\n        const is0 = p.is0();\n        // If invZ was 0, we return zero point. However we still want to execute\n        // all operations, so we replace invZ with a random number, 1.\n        if (iz == null)\n            iz = is0 ? Fp.ONE : Fp.inv(Z);\n        const x = Fp.mul(X, iz);\n        const y = Fp.mul(Y, iz);\n        const zz = Fp.mul(Z, iz);\n        if (is0)\n            return { x: Fp.ZERO, y: Fp.ZERO };\n        if (!Fp.eql(zz, Fp.ONE))\n            throw new Error('invZ was invalid');\n        return { x, y };\n    });\n    // NOTE: on exception this will crash 'cached' and no value will be set.\n    // Otherwise true will be return\n    const assertValidMemo = memoized((p) => {\n        if (p.is0()) {\n            // (0, 1, 0) aka ZERO is invalid in most contexts.\n            // In BLS, ZERO can be serialized, so we allow it.\n            // (0, 0, 0) is invalid representation of ZERO.\n            if (extraOpts.allowInfinityPoint && !Fp.is0(p.Y))\n                return;\n            throw new Error('bad point: ZERO');\n        }\n        // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n        const { x, y } = p.toAffine();\n        if (!Fp.isValid(x) || !Fp.isValid(y))\n            throw new Error('bad point: x or y not field elements');\n        if (!isValidXY(x, y))\n            throw new Error('bad point: equation left != right');\n        if (!p.isTorsionFree())\n            throw new Error('bad point: not in prime-order subgroup');\n        return true;\n    });\n    function finishEndo(endoBeta, k1p, k2p, k1neg, k2neg) {\n        k2p = new Point(Fp.mul(k2p.X, endoBeta), k2p.Y, k2p.Z);\n        k1p = negateCt(k1neg, k1p);\n        k2p = negateCt(k2neg, k2p);\n        return k1p.add(k2p);\n    }\n    /**\n     * Projective Point works in 3d / projective (homogeneous) coordinates:(X, Y, Z) ‚àã (x=X/Z, y=Y/Z).\n     * Default Point works in 2d / affine coordinates: (x, y).\n     * We're doing calculations in projective, because its operations don't require costly inversion.\n     */\n    class Point {\n        /** Does NOT validate if the point is valid. Use `.assertValidity()`. */\n        constructor(X, Y, Z) {\n            this.X = acoord('x', X);\n            this.Y = acoord('y', Y, true);\n            this.Z = acoord('z', Z);\n            Object.freeze(this);\n        }\n        static CURVE() {\n            return CURVE;\n        }\n        /** Does NOT validate if the point is valid. Use `.assertValidity()`. */\n        static fromAffine(p) {\n            const { x, y } = p || {};\n            if (!p || !Fp.isValid(x) || !Fp.isValid(y))\n                throw new Error('invalid affine point');\n            if (p instanceof Point)\n                throw new Error('projective point not allowed');\n            // (0, 0) would've produced (0, 0, 1) - instead, we need (0, 1, 0)\n            if (Fp.is0(x) && Fp.is0(y))\n                return Point.ZERO;\n            return new Point(x, y, Fp.ONE);\n        }\n        static fromBytes(bytes) {\n            const P = Point.fromAffine(decodePoint(_abytes2(bytes, undefined, 'point')));\n            P.assertValidity();\n            return P;\n        }\n        static fromHex(hex) {\n            return Point.fromBytes(ensureBytes('pointHex', hex));\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        /**\n         *\n         * @param windowSize\n         * @param isLazy true will defer table computation until the first multiplication\n         * @returns\n         */\n        precompute(windowSize = 8, isLazy = true) {\n            wnaf.createCache(this, windowSize);\n            if (!isLazy)\n                this.multiply(_3n); // random number\n            return this;\n        }\n        // TODO: return `this`\n        /** A point on curve is valid if it conforms to equation. */\n        assertValidity() {\n            assertValidMemo(this);\n        }\n        hasEvenY() {\n            const { y } = this.toAffine();\n            if (!Fp.isOdd)\n                throw new Error(\"Field doesn't support isOdd\");\n            return !Fp.isOdd(y);\n        }\n        /** Compare one point to another. */\n        equals(other) {\n            aprjpoint(other);\n            const { X: X1, Y: Y1, Z: Z1 } = this;\n            const { X: X2, Y: Y2, Z: Z2 } = other;\n            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n            return U1 && U2;\n        }\n        /** Flips point to one corresponding to (x, -y) in Affine coordinates. */\n        negate() {\n            return new Point(this.X, Fp.neg(this.Y), this.Z);\n        }\n        // Renes-Costello-Batina exception-free doubling formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 3\n        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n        double() {\n            const { a, b } = CURVE;\n            const b3 = Fp.mul(b, _3n);\n            const { X: X1, Y: Y1, Z: Z1 } = this;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            let t0 = Fp.mul(X1, X1); // step 1\n            let t1 = Fp.mul(Y1, Y1);\n            let t2 = Fp.mul(Z1, Z1);\n            let t3 = Fp.mul(X1, Y1);\n            t3 = Fp.add(t3, t3); // step 5\n            Z3 = Fp.mul(X1, Z1);\n            Z3 = Fp.add(Z3, Z3);\n            X3 = Fp.mul(a, Z3);\n            Y3 = Fp.mul(b3, t2);\n            Y3 = Fp.add(X3, Y3); // step 10\n            X3 = Fp.sub(t1, Y3);\n            Y3 = Fp.add(t1, Y3);\n            Y3 = Fp.mul(X3, Y3);\n            X3 = Fp.mul(t3, X3);\n            Z3 = Fp.mul(b3, Z3); // step 15\n            t2 = Fp.mul(a, t2);\n            t3 = Fp.sub(t0, t2);\n            t3 = Fp.mul(a, t3);\n            t3 = Fp.add(t3, Z3);\n            Z3 = Fp.add(t0, t0); // step 20\n            t0 = Fp.add(Z3, t0);\n            t0 = Fp.add(t0, t2);\n            t0 = Fp.mul(t0, t3);\n            Y3 = Fp.add(Y3, t0);\n            t2 = Fp.mul(Y1, Z1); // step 25\n            t2 = Fp.add(t2, t2);\n            t0 = Fp.mul(t2, t3);\n            X3 = Fp.sub(X3, t0);\n            Z3 = Fp.mul(t2, t1);\n            Z3 = Fp.add(Z3, Z3); // step 30\n            Z3 = Fp.add(Z3, Z3);\n            return new Point(X3, Y3, Z3);\n        }\n        // Renes-Costello-Batina exception-free addition formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 1\n        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n        add(other) {\n            aprjpoint(other);\n            const { X: X1, Y: Y1, Z: Z1 } = this;\n            const { X: X2, Y: Y2, Z: Z2 } = other;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            const a = CURVE.a;\n            const b3 = Fp.mul(CURVE.b, _3n);\n            let t0 = Fp.mul(X1, X2); // step 1\n            let t1 = Fp.mul(Y1, Y2);\n            let t2 = Fp.mul(Z1, Z2);\n            let t3 = Fp.add(X1, Y1);\n            let t4 = Fp.add(X2, Y2); // step 5\n            t3 = Fp.mul(t3, t4);\n            t4 = Fp.add(t0, t1);\n            t3 = Fp.sub(t3, t4);\n            t4 = Fp.add(X1, Z1);\n            let t5 = Fp.add(X2, Z2); // step 10\n            t4 = Fp.mul(t4, t5);\n            t5 = Fp.add(t0, t2);\n            t4 = Fp.sub(t4, t5);\n            t5 = Fp.add(Y1, Z1);\n            X3 = Fp.add(Y2, Z2); // step 15\n            t5 = Fp.mul(t5, X3);\n            X3 = Fp.add(t1, t2);\n            t5 = Fp.sub(t5, X3);\n            Z3 = Fp.mul(a, t4);\n            X3 = Fp.mul(b3, t2); // step 20\n            Z3 = Fp.add(X3, Z3);\n            X3 = Fp.sub(t1, Z3);\n            Z3 = Fp.add(t1, Z3);\n            Y3 = Fp.mul(X3, Z3);\n            t1 = Fp.add(t0, t0); // step 25\n            t1 = Fp.add(t1, t0);\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.mul(b3, t4);\n            t1 = Fp.add(t1, t2);\n            t2 = Fp.sub(t0, t2); // step 30\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.add(t4, t2);\n            t0 = Fp.mul(t1, t4);\n            Y3 = Fp.add(Y3, t0);\n            t0 = Fp.mul(t5, t4); // step 35\n            X3 = Fp.mul(t3, X3);\n            X3 = Fp.sub(X3, t0);\n            t0 = Fp.mul(t3, t1);\n            Z3 = Fp.mul(t5, Z3);\n            Z3 = Fp.add(Z3, t0); // step 40\n            return new Point(X3, Y3, Z3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        /**\n         * Constant time multiplication.\n         * Uses wNAF method. Windowed method may be 10% faster,\n         * but takes 2x longer to generate and consumes 2x memory.\n         * Uses precomputes when available.\n         * Uses endomorphism for Koblitz curves.\n         * @param scalar by which the point would be multiplied\n         * @returns New point\n         */\n        multiply(scalar) {\n            const { endo } = extraOpts;\n            if (!Fn.isValidNot0(scalar))\n                throw new Error('invalid scalar: out of range'); // 0 is invalid\n            let point, fake; // Fake point is used to const-time mult\n            const mul = (n) => wnaf.cached(this, n, (p) => normalizeZ(Point, p));\n            /** See docs for {@link EndomorphismOpts} */\n            if (endo) {\n                const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(scalar);\n                const { p: k1p, f: k1f } = mul(k1);\n                const { p: k2p, f: k2f } = mul(k2);\n                fake = k1f.add(k2f);\n                point = finishEndo(endo.beta, k1p, k2p, k1neg, k2neg);\n            }\n            else {\n                const { p, f } = mul(scalar);\n                point = p;\n                fake = f;\n            }\n            // Normalize `z` for both points, but return only real one\n            return normalizeZ(Point, [point, fake])[0];\n        }\n        /**\n         * Non-constant-time multiplication. Uses double-and-add algorithm.\n         * It's faster, but should only be used when you don't care about\n         * an exposed secret key e.g. sig verification, which works over *public* keys.\n         */\n        multiplyUnsafe(sc) {\n            const { endo } = extraOpts;\n            const p = this;\n            if (!Fn.isValid(sc))\n                throw new Error('invalid scalar: out of range'); // 0 is valid\n            if (sc === _0n || p.is0())\n                return Point.ZERO;\n            if (sc === _1n)\n                return p; // fast-path\n            if (wnaf.hasCache(this))\n                return this.multiply(sc);\n            if (endo) {\n                const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(sc);\n                const { p1, p2 } = mulEndoUnsafe(Point, p, k1, k2); // 30% faster vs wnaf.unsafe\n                return finishEndo(endo.beta, p1, p2, k1neg, k2neg);\n            }\n            else {\n                return wnaf.unsafe(p, sc);\n            }\n        }\n        multiplyAndAddUnsafe(Q, a, b) {\n            const sum = this.multiplyUnsafe(a).add(Q.multiplyUnsafe(b));\n            return sum.is0() ? undefined : sum;\n        }\n        /**\n         * Converts Projective point to affine (x, y) coordinates.\n         * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch\n         */\n        toAffine(invertedZ) {\n            return toAffineMemo(this, invertedZ);\n        }\n        /**\n         * Checks whether Point is free of torsion elements (is in prime subgroup).\n         * Always torsion-free for cofactor=1 curves.\n         */\n        isTorsionFree() {\n            const { isTorsionFree } = extraOpts;\n            if (cofactor === _1n)\n                return true;\n            if (isTorsionFree)\n                return isTorsionFree(Point, this);\n            return wnaf.unsafe(this, CURVE_ORDER).is0();\n        }\n        clearCofactor() {\n            const { clearCofactor } = extraOpts;\n            if (cofactor === _1n)\n                return this; // Fast-path\n            if (clearCofactor)\n                return clearCofactor(Point, this);\n            return this.multiplyUnsafe(cofactor);\n        }\n        isSmallOrder() {\n            // can we use this.clearCofactor()?\n            return this.multiplyUnsafe(cofactor).is0();\n        }\n        toBytes(isCompressed = true) {\n            _abool2(isCompressed, 'isCompressed');\n            this.assertValidity();\n            return encodePoint(Point, this, isCompressed);\n        }\n        toHex(isCompressed = true) {\n            return bytesToHex(this.toBytes(isCompressed));\n        }\n        toString() {\n            return `<Point ${this.is0() ? 'ZERO' : this.toHex()}>`;\n        }\n        // TODO: remove\n        get px() {\n            return this.X;\n        }\n        get py() {\n            return this.X;\n        }\n        get pz() {\n            return this.Z;\n        }\n        toRawBytes(isCompressed = true) {\n            return this.toBytes(isCompressed);\n        }\n        _setWindowSize(windowSize) {\n            this.precompute(windowSize);\n        }\n        static normalizeZ(points) {\n            return normalizeZ(Point, points);\n        }\n        static msm(points, scalars) {\n            return pippenger(Point, Fn, points, scalars);\n        }\n        static fromPrivateKey(privateKey) {\n            return Point.BASE.multiply(_normFnElement(Fn, privateKey));\n        }\n    }\n    // base / generator point\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n    // zero / infinity / identity point\n    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO); // 0, 1, 0\n    // math field\n    Point.Fp = Fp;\n    // scalar field\n    Point.Fn = Fn;\n    const bits = Fn.BITS;\n    const wnaf = new wNAF(Point, extraOpts.endo ? Math.ceil(bits / 2) : bits);\n    Point.BASE.precompute(8); // Enable precomputes. Slows down first publicKey computation by 20ms.\n    return Point;\n}\n// Points start with byte 0x02 when y is even; otherwise 0x03\nfunction pprefix(hasEvenY) {\n    return Uint8Array.of(hasEvenY ? 0x02 : 0x03);\n}\nfunction getWLengths(Fp, Fn) {\n    return {\n        secretKey: Fn.BYTES,\n        publicKey: 1 + Fp.BYTES,\n        publicKeyUncompressed: 1 + 2 * Fp.BYTES,\n        publicKeyHasPrefix: true,\n        signature: 2 * Fn.BYTES,\n    };\n}\n/**\n * Sometimes users only need getPublicKey, getSharedSecret, and secret key handling.\n * This helper ensures no signature functionality is present. Less code, smaller bundle size.\n */\nfunction ecdh(Point, ecdhOpts = {}) {\n    const { Fn } = Point;\n    const randomBytes_ = ecdhOpts.randomBytes || randomBytes;\n    const lengths = Object.assign(getWLengths(Point.Fp, Fn), { seed: getMinHashLength(Fn.ORDER) });\n    function isValidSecretKey(secretKey) {\n        try {\n            return !!_normFnElement(Fn, secretKey);\n        }\n        catch (error) {\n            return false;\n        }\n    }\n    function isValidPublicKey(publicKey, isCompressed) {\n        const { publicKey: comp, publicKeyUncompressed } = lengths;\n        try {\n            const l = publicKey.length;\n            if (isCompressed === true && l !== comp)\n                return false;\n            if (isCompressed === false && l !== publicKeyUncompressed)\n                return false;\n            return !!Point.fromBytes(publicKey);\n        }\n        catch (error) {\n            return false;\n        }\n    }\n    /**\n     * Produces cryptographically secure secret key from random of size\n     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.\n     */\n    function randomSecretKey(seed = randomBytes_(lengths.seed)) {\n        return mapHashToField(_abytes2(seed, lengths.seed, 'seed'), Fn.ORDER);\n    }\n    /**\n     * Computes public key for a secret key. Checks for validity of the secret key.\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns Public key, full when isCompressed=false; short when isCompressed=true\n     */\n    function getPublicKey(secretKey, isCompressed = true) {\n        return Point.BASE.multiply(_normFnElement(Fn, secretKey)).toBytes(isCompressed);\n    }\n    function keygen(seed) {\n        const secretKey = randomSecretKey(seed);\n        return { secretKey, publicKey: getPublicKey(secretKey) };\n    }\n    /**\n     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n     */\n    function isProbPub(item) {\n        if (typeof item === 'bigint')\n            return false;\n        if (item instanceof Point)\n            return true;\n        const { secretKey, publicKey, publicKeyUncompressed } = lengths;\n        if (Fn.allowedLengths || secretKey === publicKey)\n            return undefined;\n        const l = ensureBytes('key', item).length;\n        return l === publicKey || l === publicKeyUncompressed;\n    }\n    /**\n     * ECDH (Elliptic Curve Diffie Hellman).\n     * Computes shared public key from secret key A and public key B.\n     * Checks: 1) secret key validity 2) shared key is on-curve.\n     * Does NOT hash the result.\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns shared public key\n     */\n    function getSharedSecret(secretKeyA, publicKeyB, isCompressed = true) {\n        if (isProbPub(secretKeyA) === true)\n            throw new Error('first arg must be private key');\n        if (isProbPub(publicKeyB) === false)\n            throw new Error('second arg must be public key');\n        const s = _normFnElement(Fn, secretKeyA);\n        const b = Point.fromHex(publicKeyB); // checks for being on-curve\n        return b.multiply(s).toBytes(isCompressed);\n    }\n    const utils = {\n        isValidSecretKey,\n        isValidPublicKey,\n        randomSecretKey,\n        // TODO: remove\n        isValidPrivateKey: isValidSecretKey,\n        randomPrivateKey: randomSecretKey,\n        normPrivateKeyToScalar: (key) => _normFnElement(Fn, key),\n        precompute(windowSize = 8, point = Point.BASE) {\n            return point.precompute(windowSize, false);\n        },\n    };\n    return Object.freeze({ getPublicKey, getSharedSecret, keygen, Point, utils, lengths });\n}\n/**\n * Creates ECDSA signing interface for given elliptic curve `Point` and `hash` function.\n * We need `hash` for 2 features:\n * 1. Message prehash-ing. NOT used if `sign` / `verify` are called with `prehash: false`\n * 2. k generation in `sign`, using HMAC-drbg(hash)\n *\n * ECDSAOpts are only rarely needed.\n *\n * @example\n * ```js\n * const p256_Point = weierstrass(...);\n * const p256_sha256 = ecdsa(p256_Point, sha256);\n * const p256_sha224 = ecdsa(p256_Point, sha224);\n * const p256_sha224_r = ecdsa(p256_Point, sha224, { randomBytes: (length) => { ... } });\n * ```\n */\nfunction ecdsa(Point, hash, ecdsaOpts = {}) {\n    ahash(hash);\n    _validateObject(ecdsaOpts, {}, {\n        hmac: 'function',\n        lowS: 'boolean',\n        randomBytes: 'function',\n        bits2int: 'function',\n        bits2int_modN: 'function',\n    });\n    const randomBytes$1 = ecdsaOpts.randomBytes || randomBytes;\n    const hmac$1 = ecdsaOpts.hmac ||\n        ((key, ...msgs) => hmac(hash, key, concatBytes(...msgs)));\n    const { Fp, Fn } = Point;\n    const { ORDER: CURVE_ORDER, BITS: fnBits } = Fn;\n    const { keygen, getPublicKey, getSharedSecret, utils, lengths } = ecdh(Point, ecdsaOpts);\n    const defaultSigOpts = {\n        prehash: false,\n        lowS: typeof ecdsaOpts.lowS === 'boolean' ? ecdsaOpts.lowS : false,\n        format: undefined, //'compact' as ECDSASigFormat,\n        extraEntropy: false,\n    };\n    const defaultSigOpts_format = 'compact';\n    function isBiggerThanHalfOrder(number) {\n        const HALF = CURVE_ORDER >> _1n;\n        return number > HALF;\n    }\n    function validateRS(title, num) {\n        if (!Fn.isValidNot0(num))\n            throw new Error(`invalid signature ${title}: out of range 1..Point.Fn.ORDER`);\n        return num;\n    }\n    function validateSigLength(bytes, format) {\n        validateSigFormat(format);\n        const size = lengths.signature;\n        const sizer = format === 'compact' ? size : format === 'recovered' ? size + 1 : undefined;\n        return _abytes2(bytes, sizer, `${format} signature`);\n    }\n    /**\n     * ECDSA signature with its (r, s) properties. Supports compact, recovered & DER representations.\n     */\n    class Signature {\n        constructor(r, s, recovery) {\n            this.r = validateRS('r', r); // r in [1..N-1];\n            this.s = validateRS('s', s); // s in [1..N-1];\n            if (recovery != null)\n                this.recovery = recovery;\n            Object.freeze(this);\n        }\n        static fromBytes(bytes, format = defaultSigOpts_format) {\n            validateSigLength(bytes, format);\n            let recid;\n            if (format === 'der') {\n                const { r, s } = DER.toSig(_abytes2(bytes));\n                return new Signature(r, s);\n            }\n            if (format === 'recovered') {\n                recid = bytes[0];\n                format = 'compact';\n                bytes = bytes.subarray(1);\n            }\n            const L = Fn.BYTES;\n            const r = bytes.subarray(0, L);\n            const s = bytes.subarray(L, L * 2);\n            return new Signature(Fn.fromBytes(r), Fn.fromBytes(s), recid);\n        }\n        static fromHex(hex, format) {\n            return this.fromBytes(hexToBytes(hex), format);\n        }\n        addRecoveryBit(recovery) {\n            return new Signature(this.r, this.s, recovery);\n        }\n        recoverPublicKey(messageHash) {\n            const FIELD_ORDER = Fp.ORDER;\n            const { r, s, recovery: rec } = this;\n            if (rec == null || ![0, 1, 2, 3].includes(rec))\n                throw new Error('recovery id invalid');\n            // ECDSA recovery is hard for cofactor > 1 curves.\n            // In sign, `r = q.x mod n`, and here we recover q.x from r.\n            // While recovering q.x >= n, we need to add r+n for cofactor=1 curves.\n            // However, for cofactor>1, r+n may not get q.x:\n            // r+n*i would need to be done instead where i is unknown.\n            // To easily get i, we either need to:\n            // a. increase amount of valid recid values (4, 5...); OR\n            // b. prohibit non-prime-order signatures (recid > 1).\n            const hasCofactor = CURVE_ORDER * _2n < FIELD_ORDER;\n            if (hasCofactor && rec > 1)\n                throw new Error('recovery id is ambiguous for h>1 curve');\n            const radj = rec === 2 || rec === 3 ? r + CURVE_ORDER : r;\n            if (!Fp.isValid(radj))\n                throw new Error('recovery id 2 or 3 invalid');\n            const x = Fp.toBytes(radj);\n            const R = Point.fromBytes(concatBytes(pprefix((rec & 1) === 0), x));\n            const ir = Fn.inv(radj); // r^-1\n            const h = bits2int_modN(ensureBytes('msgHash', messageHash)); // Truncate hash\n            const u1 = Fn.create(-h * ir); // -hr^-1\n            const u2 = Fn.create(s * ir); // sr^-1\n            // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1). unsafe is fine: there is no private data.\n            const Q = Point.BASE.multiplyUnsafe(u1).add(R.multiplyUnsafe(u2));\n            if (Q.is0())\n                throw new Error('point at infinify');\n            Q.assertValidity();\n            return Q;\n        }\n        // Signatures should be low-s, to prevent malleability.\n        hasHighS() {\n            return isBiggerThanHalfOrder(this.s);\n        }\n        toBytes(format = defaultSigOpts_format) {\n            validateSigFormat(format);\n            if (format === 'der')\n                return hexToBytes(DER.hexFromSig(this));\n            const r = Fn.toBytes(this.r);\n            const s = Fn.toBytes(this.s);\n            if (format === 'recovered') {\n                if (this.recovery == null)\n                    throw new Error('recovery bit must be present');\n                return concatBytes(Uint8Array.of(this.recovery), r, s);\n            }\n            return concatBytes(r, s);\n        }\n        toHex(format) {\n            return bytesToHex(this.toBytes(format));\n        }\n        // TODO: remove\n        assertValidity() { }\n        static fromCompact(hex) {\n            return Signature.fromBytes(ensureBytes('sig', hex), 'compact');\n        }\n        static fromDER(hex) {\n            return Signature.fromBytes(ensureBytes('sig', hex), 'der');\n        }\n        normalizeS() {\n            return this.hasHighS() ? new Signature(this.r, Fn.neg(this.s), this.recovery) : this;\n        }\n        toDERRawBytes() {\n            return this.toBytes('der');\n        }\n        toDERHex() {\n            return bytesToHex(this.toBytes('der'));\n        }\n        toCompactRawBytes() {\n            return this.toBytes('compact');\n        }\n        toCompactHex() {\n            return bytesToHex(this.toBytes('compact'));\n        }\n    }\n    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n    const bits2int = ecdsaOpts.bits2int ||\n        function bits2int_def(bytes) {\n            // Our custom check \"just in case\", for protection against DoS\n            if (bytes.length > 8192)\n                throw new Error('input is too large');\n            // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n            // for some cases, since bytes.length * 8 is not actual bitLength.\n            const num = bytesToNumberBE(bytes); // check for == u8 done here\n            const delta = bytes.length * 8 - fnBits; // truncate to nBitLength leftmost bits\n            return delta > 0 ? num >> BigInt(delta) : num;\n        };\n    const bits2int_modN = ecdsaOpts.bits2int_modN ||\n        function bits2int_modN_def(bytes) {\n            return Fn.create(bits2int(bytes)); // can't use bytesToNumberBE here\n        };\n    // Pads output with zero as per spec\n    const ORDER_MASK = bitMask(fnBits);\n    /** Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`. */\n    function int2octets(num) {\n        // IMPORTANT: the check ensures working for case `Fn.BYTES != Fn.BITS * 8`\n        aInRange('num < 2^' + fnBits, num, _0n, ORDER_MASK);\n        return Fn.toBytes(num);\n    }\n    function validateMsgAndHash(message, prehash) {\n        _abytes2(message, undefined, 'message');\n        return prehash ? _abytes2(hash(message), undefined, 'prehashed message') : message;\n    }\n    /**\n     * Steps A, D of RFC6979 3.2.\n     * Creates RFC6979 seed; converts msg/privKey to numbers.\n     * Used only in sign, not in verify.\n     *\n     * Warning: we cannot assume here that message has same amount of bytes as curve order,\n     * this will be invalid at least for P521. Also it can be bigger for P224 + SHA256.\n     */\n    function prepSig(message, privateKey, opts) {\n        if (['recovered', 'canonical'].some((k) => k in opts))\n            throw new Error('sign() legacy options not supported');\n        const { lowS, prehash, extraEntropy } = validateSigOpts(opts, defaultSigOpts);\n        message = validateMsgAndHash(message, prehash); // RFC6979 3.2 A: h1 = H(m)\n        // We can't later call bits2octets, since nested bits2int is broken for curves\n        // with fnBits % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n        const h1int = bits2int_modN(message);\n        const d = _normFnElement(Fn, privateKey); // validate secret key, convert to bigint\n        const seedArgs = [int2octets(d), int2octets(h1int)];\n        // extraEntropy. RFC6979 3.6: additional k' (optional).\n        if (extraEntropy != null && extraEntropy !== false) {\n            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n            // gen random bytes OR pass as-is\n            const e = extraEntropy === true ? randomBytes$1(lengths.secretKey) : extraEntropy;\n            seedArgs.push(ensureBytes('extraEntropy', e)); // check for being bytes\n        }\n        const seed = concatBytes(...seedArgs); // Step D of RFC6979 3.2\n        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\n        // Converts signature params into point w r/s, checks result for validity.\n        // To transform k => Signature:\n        // q = k‚ãÖG\n        // r = q.x mod n\n        // s = k^-1(m + rd) mod n\n        // Can use scalar blinding b^-1(bm + bdr) where b ‚àà [1,q‚àí1] according to\n        // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n        // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n        function k2sig(kBytes) {\n            // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n            // Important: all mod() calls here must be done over N\n            const k = bits2int(kBytes); // mod n, not mod p\n            if (!Fn.isValidNot0(k))\n                return; // Valid scalars (including k) must be in 1..N-1\n            const ik = Fn.inv(k); // k^-1 mod n\n            const q = Point.BASE.multiply(k).toAffine(); // q = k‚ãÖG\n            const r = Fn.create(q.x); // r = q.x mod n\n            if (r === _0n)\n                return;\n            const s = Fn.create(ik * Fn.create(m + r * d)); // Not using blinding here, see comment above\n            if (s === _0n)\n                return;\n            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)\n            let normS = s;\n            if (lowS && isBiggerThanHalfOrder(s)) {\n                normS = Fn.neg(s); // if lowS was passed, ensure s is always\n                recovery ^= 1; // // in the bottom half of N\n            }\n            return new Signature(r, normS, recovery); // use normS, not s\n        }\n        return { seed, k2sig };\n    }\n    /**\n     * Signs message hash with a secret key.\n     *\n     * ```\n     * sign(m, d) where\n     *   k = rfc6979_hmac_drbg(m, d)\n     *   (x, y) = G √ó k\n     *   r = x mod n\n     *   s = (m + dr) / k mod n\n     * ```\n     */\n    function sign(message, secretKey, opts = {}) {\n        message = ensureBytes('message', message);\n        const { seed, k2sig } = prepSig(message, secretKey, opts); // Steps A, D of RFC6979 3.2.\n        const drbg = createHmacDrbg(hash.outputLen, Fn.BYTES, hmac$1);\n        const sig = drbg(seed, k2sig); // Steps B, C, D, E, F, G\n        return sig;\n    }\n    function tryParsingSig(sg) {\n        // Try to deduce format\n        let sig = undefined;\n        const isHex = typeof sg === 'string' || isBytes(sg);\n        const isObj = !isHex &&\n            sg !== null &&\n            typeof sg === 'object' &&\n            typeof sg.r === 'bigint' &&\n            typeof sg.s === 'bigint';\n        if (!isHex && !isObj)\n            throw new Error('invalid signature, expected Uint8Array, hex string or Signature instance');\n        if (isObj) {\n            sig = new Signature(sg.r, sg.s);\n        }\n        else if (isHex) {\n            try {\n                sig = Signature.fromBytes(ensureBytes('sig', sg), 'der');\n            }\n            catch (derError) {\n                if (!(derError instanceof DER.Err))\n                    throw derError;\n            }\n            if (!sig) {\n                try {\n                    sig = Signature.fromBytes(ensureBytes('sig', sg), 'compact');\n                }\n                catch (error) {\n                    return false;\n                }\n            }\n        }\n        if (!sig)\n            return false;\n        return sig;\n    }\n    /**\n     * Verifies a signature against message and public key.\n     * Rejects lowS signatures by default: see {@link ECDSAVerifyOpts}.\n     * Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n     *\n     * ```\n     * verify(r, s, h, P) where\n     *   u1 = hs^-1 mod n\n     *   u2 = rs^-1 mod n\n     *   R = u1‚ãÖG + u2‚ãÖP\n     *   mod(R.x, n) == r\n     * ```\n     */\n    function verify(signature, message, publicKey, opts = {}) {\n        const { lowS, prehash, format } = validateSigOpts(opts, defaultSigOpts);\n        publicKey = ensureBytes('publicKey', publicKey);\n        message = validateMsgAndHash(ensureBytes('message', message), prehash);\n        if ('strict' in opts)\n            throw new Error('options.strict was renamed to lowS');\n        const sig = format === undefined\n            ? tryParsingSig(signature)\n            : Signature.fromBytes(ensureBytes('sig', signature), format);\n        if (sig === false)\n            return false;\n        try {\n            const P = Point.fromBytes(publicKey);\n            if (lowS && sig.hasHighS())\n                return false;\n            const { r, s } = sig;\n            const h = bits2int_modN(message); // mod n, not mod p\n            const is = Fn.inv(s); // s^-1 mod n\n            const u1 = Fn.create(h * is); // u1 = hs^-1 mod n\n            const u2 = Fn.create(r * is); // u2 = rs^-1 mod n\n            const R = Point.BASE.multiplyUnsafe(u1).add(P.multiplyUnsafe(u2)); // u1‚ãÖG + u2‚ãÖP\n            if (R.is0())\n                return false;\n            const v = Fn.create(R.x); // v = r.x mod n\n            return v === r;\n        }\n        catch (e) {\n            return false;\n        }\n    }\n    function recoverPublicKey(signature, message, opts = {}) {\n        const { prehash } = validateSigOpts(opts, defaultSigOpts);\n        message = validateMsgAndHash(message, prehash);\n        return Signature.fromBytes(signature, 'recovered').recoverPublicKey(message).toBytes();\n    }\n    return Object.freeze({\n        keygen,\n        getPublicKey,\n        getSharedSecret,\n        utils,\n        lengths,\n        Point,\n        sign,\n        verify,\n        recoverPublicKey,\n        Signature,\n        hash,\n    });\n}\nfunction _weierstrass_legacy_opts_to_new(c) {\n    const CURVE = {\n        a: c.a,\n        b: c.b,\n        p: c.Fp.ORDER,\n        n: c.n,\n        h: c.h,\n        Gx: c.Gx,\n        Gy: c.Gy,\n    };\n    const Fp = c.Fp;\n    let allowedLengths = c.allowedPrivateKeyLengths\n        ? Array.from(new Set(c.allowedPrivateKeyLengths.map((l) => Math.ceil(l / 2))))\n        : undefined;\n    const Fn = Field(CURVE.n, {\n        BITS: c.nBitLength,\n        allowedLengths: allowedLengths,\n        modFromBytes: c.wrapPrivateKey,\n    });\n    const curveOpts = {\n        Fp,\n        Fn,\n        allowInfinityPoint: c.allowInfinityPoint,\n        endo: c.endo,\n        isTorsionFree: c.isTorsionFree,\n        clearCofactor: c.clearCofactor,\n        fromBytes: c.fromBytes,\n        toBytes: c.toBytes,\n    };\n    return { CURVE, curveOpts };\n}\nfunction _ecdsa_legacy_opts_to_new(c) {\n    const { CURVE, curveOpts } = _weierstrass_legacy_opts_to_new(c);\n    const ecdsaOpts = {\n        hmac: c.hmac,\n        randomBytes: c.randomBytes,\n        lowS: c.lowS,\n        bits2int: c.bits2int,\n        bits2int_modN: c.bits2int_modN,\n    };\n    return { CURVE, curveOpts, hash: c.hash, ecdsaOpts };\n}\nfunction _ecdsa_new_output_to_legacy(c, _ecdsa) {\n    const Point = _ecdsa.Point;\n    return Object.assign({}, _ecdsa, {\n        ProjectivePoint: Point,\n        CURVE: Object.assign({}, c, nLength(Point.Fn.ORDER, Point.Fn.BITS)),\n    });\n}\n// _ecdsa_legacy\nfunction weierstrass(c) {\n    const { CURVE, curveOpts, hash, ecdsaOpts } = _ecdsa_legacy_opts_to_new(c);\n    const Point = weierstrassN(CURVE, curveOpts);\n    const signs = ecdsa(Point, hash, ecdsaOpts);\n    return _ecdsa_new_output_to_legacy(c, signs);\n}\n\n/**\n * Utilities for short weierstrass curves, combined with noble-hashes.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n/** @deprecated use new `weierstrass()` and `ecdsa()` methods */\nfunction createCurve(curveDef, defHash) {\n    const create = (hash) => weierstrass({ ...curveDef, hash: hash });\n    return { ...create(defHash), create };\n}\n\nexport { Field as F, _createCurveFields as _, _validateObject as a, copyBytes as b, createCurve as c, _abytes2 as d, _abool2 as e, bytesToNumberLE as f, aInRange as g, ensureBytes as h, mod as i, pow2 as j, isNegativeLE as k, memoized as m, normalizeZ as n, pippenger as p, wNAF as w };\n","import { s as sha256, a as sha384, b as sha512 } from './hmac.mjs';\nimport { c as createCurve, F as Field } from './_shortw_utils.mjs';\n\n/**\n * Internal module for NIST P256, P384, P521 curves.\n * Do not use for now.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// p = 2n**224n * (2n**32n-1n) + 2n**192n + 2n**96n - 1n\n// a = Fp256.create(BigInt('-3'));\nconst p256_CURVE = {\n    p: BigInt('0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff'),\n    n: BigInt('0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551'),\n    h: BigInt(1),\n    a: BigInt('0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc'),\n    b: BigInt('0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b'),\n    Gx: BigInt('0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296'),\n    Gy: BigInt('0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5'),\n};\n// p = 2n**384n - 2n**128n - 2n**96n + 2n**32n - 1n\nconst p384_CURVE = {\n    p: BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000ffffffff'),\n    n: BigInt('0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973'),\n    h: BigInt(1),\n    a: BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000fffffffc'),\n    b: BigInt('0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef'),\n    Gx: BigInt('0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7'),\n    Gy: BigInt('0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f'),\n};\n// p = 2n**521n - 1n\nconst p521_CURVE = {\n    p: BigInt('0x1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff'),\n    n: BigInt('0x01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb71e91386409'),\n    h: BigInt(1),\n    a: BigInt('0x1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc'),\n    b: BigInt('0x0051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00'),\n    Gx: BigInt('0x00c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66'),\n    Gy: BigInt('0x011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650'),\n};\nconst Fp256 = Field(p256_CURVE.p);\nconst Fp384 = Field(p384_CURVE.p);\nconst Fp521 = Field(p521_CURVE.p);\n/** NIST P256 (aka secp256r1, prime256v1) curve, ECDSA and ECDH methods. */\nconst p256$1 = createCurve({ ...p256_CURVE, Fp: Fp256, lowS: false }, sha256);\n// export const p256_oprf: OPRF = createORPF({\n//   name: 'P256-SHA256',\n//   Point: p256.Point,\n//   hash: sha256,\n//   hashToGroup: p256_hasher.hashToCurve,\n//   hashToScalar: p256_hasher.hashToScalar,\n// });\n/** NIST P384 (aka secp384r1) curve, ECDSA and ECDH methods. */\ncreateCurve({ ...p384_CURVE, Fp: Fp384, lowS: false }, sha384);\n// export const p384_oprf: OPRF = createORPF({\n//   name: 'P384-SHA384',\n//   Point: p384.Point,\n//   hash: sha384,\n//   hashToGroup: p384_hasher.hashToCurve,\n//   hashToScalar: p384_hasher.hashToScalar,\n// });\n// const Fn521 = Field(p521_CURVE.n, { allowedScalarLengths: [65, 66] });\n/** NIST P521 (aka secp521r1) curve, ECDSA and ECDH methods. */\ncreateCurve({ ...p521_CURVE, Fp: Fp521, lowS: false, allowedPrivateKeyLengths: [130, 131, 132] }, sha512);\n// export const p521_oprf: OPRF = createORPF({\n//   name: 'P521-SHA512',\n//   Point: p521.Point,\n//   hash: sha512,\n//   hashToGroup: p521_hasher.hashToCurve,\n//   hashToScalar: p521_hasher.hashToScalar, // produces L=98 just like in RFC\n// });\n\n/**\n * NIST secp256r1 aka p256.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n/** @deprecated use `import { p256 } from '@noble/curves/nist.js';` */\nconst p256 = p256$1;\n\nexport { p256 };\n"],"names":["sha256"],"mappings":"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AACnC,YAAY,EAAE,GAAG,EAAE,CAAC,GAAG,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC;AAChC,YAAY,EAAE,GAAG,EAAE,CAAC,GAAG,CAAC,EAAE,EAAE,EAAE,CAAC;AAC/B,YAAY,EAAE,GAAG,EAAE,CAAC,GAAG,CAAC,EAAE,EAAE,EAAE,CAAC;AAC/B,YAAY,EAAE,GAAG,EAAE,CAAC,GAAG,CAAC,CAAC,EAAE,EAAE,CAAC;AAC9B,YAAY,EAAE,GAAG,EAAE,CAAC,GAAG,CAAC,EAAE,EAAE,EAAE,CAAC;AAC/B,YAAY,EAAE,GAAG,EAAE,CAAC,GAAG,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC;AAChC,YAAY,EAAE,GAAG,EAAE,CAAC,GAAG,CAAC,EAAE,EAAE,EAAE,CAAC;AAC/B,YAAY,EAAE,GAAG,EAAE,CAAC,GAAG,CAAC,EAAE,EAAE,EAAE,CAAC;AAC/B,YAAY,EAAE,GAAG,EAAE,CAAC,GAAG,CAAC,EAAE,EAAE,EAAE,CAAC;AAC/B,YAAY,EAAE,GAAG,EAAE,CAAC,GAAG,CAAC,EAAE,EAAE,EAAE,CAAC;AAC/B,YAAY,EAAE,GAAG,EAAE,CAAC,GAAG,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC;AAChC,YAAY,EAAE,GAAG,EAAE,CAAC,GAAG,CAAC,CAAC,EAAE,EAAE,CAAC;AAC9B,YAAY,EAAE,GAAG,EAAE,CAAC,GAAG,CAAC,EAAE,EAAE,EAAE,CAAC;AAC/B,YAAY,EAAE,GAAG,EAAE,CAAC,GAAG,CAAC,CAAC,EAAE,EAAE,CAAC;AAC9B,YAAY,EAAE,GAAG,EAAE,CAAC,GAAG,CAAC,EAAE,EAAE,EAAE,CAAC;AAC/B,YAAY,EAAE,GAAG,EAAE,CAAC,GAAG,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC;AAChC,YAAY,EAAE,GAAG,EAAE,CAAC,GAAG,CAAC,EAAE,EAAE,EAAE,CAAC;AAC/B,YAAY,EAAE,GAAG,EAAE,CAAC,GAAG,CAAC,EAAE,EAAE,EAAE,CAAC;AAC/B,YAAY,EAAE,GAAG,EAAE,CAAC,GAAG,CAAC,EAAE,EAAE,EAAE,CAAC;AAC/B,YAAY,EAAE,GAAG,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"}