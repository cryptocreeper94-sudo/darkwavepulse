{"version":3,"file":"subscriptionCheck.mjs","sources":["../../src/mastra/middleware/subscriptionCheck.ts"],"sourcesContent":["import { db } from \"../../db/client.js\";\nimport { subscriptions, userUsage, whitelistedUsers } from \"../../db/schema.js\";\nimport { eq, or } from \"drizzle-orm\";\n\n// Helper: Get email from session token\nasync function getEmailFromSession(sessionToken?: string): Promise<string | null> {\n  if (!sessionToken) return null;\n  \n  try {\n    const { sessions } = await import('../../db/schema.js');\n    const [session] = await db.select()\n      .from(sessions)\n      .where(eq(sessions.token, sessionToken))\n      .limit(1);\n    \n    return session?.email || null;\n  } catch {\n    return null;\n  }\n}\n\nexport async function checkSubscriptionLimit(userId: string, feature: 'search' | 'alert', sessionToken?: string): Promise<{ allowed: boolean; isPremium: boolean; isWhitelisted?: boolean; message?: string }> {\n  try {\n    // TEMPORARY: Disable limits for owner testing\n    console.log(`ðŸ”“ [SubscriptionCheck] LIMITS DISABLED FOR TESTING - User ${userId} granted unlimited access`);\n    return { allowed: true, isPremium: true, isWhitelisted: true };\n    \n    /* ORIGINAL LOGIC - RE-ENABLE BEFORE PRODUCTION\n    // Get email from session if token provided\n    const userEmail = await getEmailFromSession(sessionToken);\n    \n    // Check if user is whitelisted first (by userId OR email)\n    let whitelist;\n    if (userEmail) {\n      // Check by userId OR email\n      whitelist = await db.select()\n        .from(whitelistedUsers)\n        .where(or(\n          eq(whitelistedUsers.userId, userId),\n          eq(whitelistedUsers.email, userEmail)\n        ))\n        .limit(1);\n    } else {\n      // Check by userId only\n      whitelist = await db.select()\n        .from(whitelistedUsers)\n        .where(eq(whitelistedUsers.userId, userId))\n        .limit(1);\n    }\n    \n    if (whitelist.length > 0) {\n      const whitelistEntry = whitelist[0];\n      \n      // Check if whitelist has expired\n      if (whitelistEntry.expiresAt && new Date(whitelistEntry.expiresAt) < new Date()) {\n        // Whitelist expired, continue with normal checks\n      } else {\n        // Active whitelist - grant premium access\n        console.log(`âœ… [Whitelist] User ${userId} granted premium access (${whitelistEntry.reason || 'No reason'})`);\n        return { allowed: true, isPremium: true, isWhitelisted: true };\n      }\n    }\n    */\n    \n    // Get user's subscription status\n    const [subscription] = await db\n      .select()\n      .from(subscriptions)\n      .where(eq(subscriptions.userId, userId));\n    \n    const isPremium = subscription?.plan === 'premium' && subscription?.status === 'active';\n    const isBasic = subscription?.plan === 'basic' && subscription?.status === 'active';\n    \n    // Premium users have unlimited access\n    if (isPremium) {\n      return { allowed: true, isPremium: true };\n    }\n    \n    // Basic and Free tier limits (updated Nov 2025)\n    const limits = {\n      search: 20,  // 20 searches/day for both Basic ($2/mo) and Free trial (7 days)\n      alert: 3     // 3 price alerts/day\n    };\n    \n    // Get or create usage record\n    let [usage] = await db\n      .select()\n      .from(userUsage)\n      .where(eq(userUsage.userId, userId));\n    \n    if (!usage) {\n      // Create new usage record\n      await db.insert(userUsage).values({\n        userId,\n        searchCount: 0,\n        alertCount: 0,\n      });\n      usage = { userId, searchCount: 0, alertCount: 0, lastResetDate: new Date(), createdAt: new Date(), updatedAt: new Date() };\n    }\n    \n    // Check if we need to reset (daily reset)\n    const now = new Date();\n    const lastReset = new Date(usage.lastResetDate);\n    const daysSinceReset = Math.floor((now.getTime() - lastReset.getTime()) / (1000 * 60 * 60 * 24));\n    \n    if (daysSinceReset >= 1) {\n      // Reset counts\n      await db.update(userUsage)\n        .set({ searchCount: 0, alertCount: 0, lastResetDate: now, updatedAt: now })\n        .where(eq(userUsage.userId, userId));\n      usage.searchCount = 0;\n      usage.alertCount = 0;\n    }\n    \n    // Check current usage\n    const currentCount = feature === 'search' ? usage.searchCount : usage.alertCount;\n    const limit = limits[feature];\n    \n    if (currentCount >= limit) {\n      return {\n        allowed: false,\n        isPremium: false,\n        message: `Daily limit reached (${limit} ${feature}es per day on free plan). Upgrade to Premium for unlimited access!`\n      };\n    }\n    \n    // Increment usage\n    const updateField = feature === 'search' ? { searchCount: currentCount + 1 } : { alertCount: currentCount + 1 };\n    await db.update(userUsage)\n      .set({ ...updateField, updatedAt: now })\n      .where(eq(userUsage.userId, userId));\n    \n    // Basic and Free tiers both have same limits, just return allowed\n    return { allowed: true, isPremium: false };\n  } catch (error) {\n    // SECURITY: Fail closed on errors to prevent bypass\n    console.error('Subscription check error:', error);\n    return { \n      allowed: false, \n      isPremium: false, \n      message: 'Unable to verify subscription status. Please try again.' \n    };\n  }\n}\n"],"names":[],"mappings":"AAqBA,eAAsB,sBAAA,CAAuB,MAAA,EAAgB,OAAA,EAA6B,YAAA,EAAqH;AAC7M,EAAA,IAAI;AAEF,IAAA,OAAA,CAAQ,GAAA,CAAI,CAAA,iEAAA,EAA6D,MAAM,CAAA,yBAAA,CAA2B,CAAA;AAC1G,IAAA,OAAO,EAAE,OAAA,EAAS,IAAA,EAAM,SAAA,EAAW,IAAA,EAAM,eAAe,IAAA,EAAK;AA4GpB,EAC3C,SAAS,KAAA,EAAO;AAEd,IAAA,OAAA,CAAQ,KAAA,CAAM,6BAA6B,KAAK,CAAA;AAChD,IAAA,OAAO;AAAA,MACL,OAAA,EAAS,KAAA;AAAA,MACT,SAAA,EAAW,KAAA;AAAA,MACX,OAAA,EAAS;AAAA,KACX;AAAA,EACF;AACF;;;;"}