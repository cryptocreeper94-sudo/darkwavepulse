{"version":3,"file":"accessControl.mjs","sources":["../../src/mastra/middleware/accessControl.ts"],"sourcesContent":["import { randomBytes } from 'crypto';\nimport { db } from '../../db/client.js';\nimport { sessions } from '../../db/schema.js';\nimport { eq, lt } from 'drizzle-orm';\n\n// Session expiry durations\nconst FREE_TIER_DURATION_MS = 2 * 24 * 60 * 60 * 1000;     // 2 days for free tier (777 trial)\nconst PREMIUM_DURATION_MS = 30 * 24 * 60 * 60 * 1000;      // 30 days for paid premium\nconst WHITELIST_DURATION_MS = 10 * 365 * 24 * 60 * 60 * 1000; // 10 years for whitelisted (effectively permanent)\n\n// Rotation thresholds\nconst ROTATION_LAST_USED_THRESHOLD_MS = 60 * 60 * 1000; // 1 hour\nconst ROTATION_EXPIRY_THRESHOLD_MS = 24 * 60 * 60 * 1000; // 1 day\n\nexport interface SessionInfo {\n  token: string;\n  userId: string;\n  email: string | null;\n  accessLevel: string | null;\n}\n\nexport interface VerifyAndRotateResult {\n  valid: boolean;\n  session?: SessionInfo;\n  rotated?: boolean;\n}\n\nexport async function generateSessionToken(\n  userId: string, \n  email?: string, \n  isPremium: boolean = false, \n  isWhitelisted: boolean = false,\n  accessLevel: string = 'user'\n): Promise<string> {\n  if (!userId || userId === 'demo-user') {\n    throw new Error('Valid userId required for session generation');\n  }\n  \n  const token = randomBytes(32).toString('hex');\n  const now = new Date();\n  \n  // Whitelisted users get permanent access (10 years)\n  let sessionDuration: number;\n  if (isWhitelisted) {\n    sessionDuration = WHITELIST_DURATION_MS;\n  } else if (isPremium) {\n    sessionDuration = PREMIUM_DURATION_MS;\n  } else {\n    sessionDuration = FREE_TIER_DURATION_MS;\n  }\n  \n  const expiresAt = new Date(now.getTime() + sessionDuration);\n  \n  await db.insert(sessions).values({\n    token,\n    userId,\n    email: email || null,\n    issuedAt: now,\n    expiresAt,\n    lastUsed: now,\n    accessLevel\n  });\n  \n  // Clean up expired sessions periodically\n  cleanExpiredSessions();\n  \n  return token;\n}\n\nexport async function verifyAndRotateSession(token: string | null | undefined): Promise<VerifyAndRotateResult> {\n  if (!token) {\n    return { valid: false };\n  }\n\n  try {\n    const [session] = await db\n      .select()\n      .from(sessions)\n      .where(eq(sessions.token, token))\n      .limit(1);\n\n    if (!session) {\n      return { valid: false };\n    }\n\n    const now = new Date();\n    const expiresAt = new Date(session.expiresAt);\n\n    // Check if expired - delete and reject\n    if (now > expiresAt) {\n      await db.delete(sessions).where(eq(sessions.token, token));\n      return { valid: false };\n    }\n\n    // Check if rotation is needed\n    const lastUsed = new Date(session.lastUsed);\n    const lastUsedAgeMs = now.getTime() - lastUsed.getTime();\n    const timeToExpiryMs = expiresAt.getTime() - now.getTime();\n    \n    const needsRotation = \n      lastUsedAgeMs > ROTATION_LAST_USED_THRESHOLD_MS || \n      timeToExpiryMs < ROTATION_EXPIRY_THRESHOLD_MS;\n\n    if (needsRotation) {\n      // Generate new token with same user data\n      const newToken = randomBytes(32).toString('hex');\n      \n      // Determine session duration based on access level\n      let sessionDuration: number;\n      const accessLevel = session.accessLevel || 'user';\n      if (accessLevel === 'owner' || accessLevel === 'admin') {\n        sessionDuration = WHITELIST_DURATION_MS;\n      } else if (accessLevel === 'premium') {\n        sessionDuration = PREMIUM_DURATION_MS;\n      } else {\n        sessionDuration = FREE_TIER_DURATION_MS;\n      }\n\n      const newExpiresAt = new Date(now.getTime() + sessionDuration);\n\n      // Insert new session first (for safety)\n      await db.insert(sessions).values({\n        token: newToken,\n        userId: session.userId,\n        email: session.email,\n        verifiedAt: session.verifiedAt,\n        issuedAt: now,\n        expiresAt: newExpiresAt,\n        lastUsed: now,\n        accessLevel: session.accessLevel\n      });\n\n      // Delete old session after successful insert\n      await db.delete(sessions).where(eq(sessions.token, token));\n\n      return {\n        valid: true,\n        session: {\n          token: newToken,\n          userId: session.userId!,\n          email: session.email,\n          accessLevel: session.accessLevel\n        },\n        rotated: true\n      };\n    }\n\n    // No rotation needed - just update lastUsed\n    await db\n      .update(sessions)\n      .set({ lastUsed: now })\n      .where(eq(sessions.token, token));\n\n    return {\n      valid: true,\n      session: {\n        token,\n        userId: session.userId!,\n        email: session.email,\n        accessLevel: session.accessLevel\n      },\n      rotated: false\n    };\n  } catch (error) {\n    console.error('Session verify/rotate error:', error);\n    return { valid: false };\n  }\n}\n\nexport async function verifySessionToken(token: string | null | undefined): Promise<boolean> {\n  if (!token) return false;\n  \n  try {\n    const [session] = await db\n      .select()\n      .from(sessions)\n      .where(eq(sessions.token, token))\n      .limit(1);\n    \n    if (!session) return false;\n    \n    // Check if expired\n    if (new Date() > new Date(session.expiresAt)) {\n      await db.delete(sessions).where(eq(sessions.token, token));\n      return false;\n    }\n    \n    // Update last used timestamp\n    await db\n      .update(sessions)\n      .set({ lastUsed: new Date() })\n      .where(eq(sessions.token, token));\n    \n    return true;\n  } catch (error) {\n    console.error('Session verification error:', error);\n    return false;\n  }\n}\n\nexport async function revokeSessionToken(token: string): Promise<void> {\n  await db.delete(sessions).where(eq(sessions.token, token));\n}\n\nasync function cleanExpiredSessions(): Promise<void> {\n  try {\n    const now = new Date();\n    await db.delete(sessions).where(lt(sessions.expiresAt, now));\n  } catch (error) {\n    console.error('Session cleanup error:', error);\n  }\n}\n\n// Clean expired sessions every hour\nsetInterval(cleanExpiredSessions, 60 * 60 * 1000);\n\n// Helper to check session in request (async now that we use database)\nexport async function checkAccessSession(c: any): Promise<{ valid: boolean; userId?: string; error?: any }> {\n  const sessionToken = c.req.header('X-Session-Token');\n  \n  if (!sessionToken) {\n    return {\n      valid: false,\n      error: c.json({ \n        error: 'Access denied. Please enter the access code.',\n        requiresAccessCode: true \n      }, 401)\n    };\n  }\n  \n  try {\n    // Fetch session and extract userId\n    const [session] = await db\n      .select()\n      .from(sessions)\n      .where(eq(sessions.token, sessionToken))\n      .limit(1);\n    \n    if (!session) {\n      return {\n        valid: false,\n        error: c.json({ \n          error: 'Access denied. Please enter the access code.',\n          requiresAccessCode: true \n        }, 401)\n      };\n    }\n    \n    // Check if expired\n    if (new Date() > new Date(session.expiresAt)) {\n      await db.delete(sessions).where(eq(sessions.token, sessionToken));\n      return {\n        valid: false,\n        error: c.json({ \n          error: 'Session expired. Please enter the access code again.',\n          requiresAccessCode: true \n        }, 401)\n      };\n    }\n    \n    // Update last used timestamp\n    await db\n      .update(sessions)\n      .set({ lastUsed: new Date() })\n      .where(eq(sessions.token, sessionToken));\n    \n    if (!session.userId) {\n      return {\n        valid: false,\n        error: c.json({ error: 'Invalid session: no user ID' }, 401)\n      };\n    }\n    \n    return { valid: true, userId: session.userId };\n  } catch (error) {\n    console.error('Session verification error:', error);\n    return {\n      valid: false,\n      error: c.json({ error: 'Session validation failed' }, 500)\n    };\n  }\n}\n"],"names":[],"mappings":"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"}